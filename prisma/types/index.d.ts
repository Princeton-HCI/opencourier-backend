
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Courier
 * 
 */
export type Courier = $Result.DefaultSelection<Prisma.$CourierPayload>
/**
 * Model Earning
 * 
 */
export type Earning = $Result.DefaultSelection<Prisma.$EarningPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Partner
 * 
 */
export type Partner = $Result.DefaultSelection<Prisma.$PartnerPayload>
/**
 * Model DeliveryQuote
 * 
 */
export type DeliveryQuote = $Result.DefaultSelection<Prisma.$DeliveryQuotePayload>
/**
 * Model Delivery
 * 
 */
export type Delivery = $Result.DefaultSelection<Prisma.$DeliveryPayload>
/**
 * Model DeliveryEvent
 * 
 */
export type DeliveryEvent = $Result.DefaultSelection<Prisma.$DeliveryEventPayload>
/**
 * Model LocationNote
 * 
 */
export type LocationNote = $Result.DefaultSelection<Prisma.$LocationNotePayload>
/**
 * Model LocationNoteReaction
 * 
 */
export type LocationNoteReaction = $Result.DefaultSelection<Prisma.$LocationNoteReactionPayload>
/**
 * Model CourierSetting
 * 
 */
export type CourierSetting = $Result.DefaultSelection<Prisma.$CourierSettingPayload>
/**
 * Model Payout
 * 
 */
export type Payout = $Result.DefaultSelection<Prisma.$PayoutPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model StripePaymentData
 * 
 */
export type StripePaymentData = $Result.DefaultSelection<Prisma.$StripePaymentDataPayload>
/**
 * Model Transfer
 * 
 */
export type Transfer = $Result.DefaultSelection<Prisma.$TransferPayload>
/**
 * Model Refund
 * 
 */
export type Refund = $Result.DefaultSelection<Prisma.$RefundPayload>
/**
 * Model Config
 * 
 */
export type Config = $Result.DefaultSelection<Prisma.$ConfigPayload>
/**
 * Model spatial_ref_sys
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type spatial_ref_sys = $Result.DefaultSelection<Prisma.$spatial_ref_sysPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const EnumUserRole: {
  ADMIN: 'ADMIN',
  COURIER: 'COURIER',
  PARTNER: 'PARTNER'
};

export type EnumUserRole = (typeof EnumUserRole)[keyof typeof EnumUserRole]


export const EnumCourierStatus: {
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE',
  LAST_CALL: 'LAST_CALL'
};

export type EnumCourierStatus = (typeof EnumCourierStatus)[keyof typeof EnumCourierStatus]


export const EnumCourierDeliverySetting: {
  AUTO_ACCEPT: 'AUTO_ACCEPT',
  AUTO_REJECT: 'AUTO_REJECT',
  MANUAL: 'MANUAL',
  NONE: 'NONE'
};

export type EnumCourierDeliverySetting = (typeof EnumCourierDeliverySetting)[keyof typeof EnumCourierDeliverySetting]


export const EnumStripeAccountStatus: {
  COMPLETE: 'COMPLETE',
  ENABLED: 'ENABLED',
  PENDING: 'PENDING',
  REJECTED: 'REJECTED',
  RESTRICTED: 'RESTRICTED',
  ATTENTION_NEEDED: 'ATTENTION_NEEDED'
};

export type EnumStripeAccountStatus = (typeof EnumStripeAccountStatus)[keyof typeof EnumStripeAccountStatus]


export const EnumCountryCode: {
  US: 'US'
};

export type EnumCountryCode = (typeof EnumCountryCode)[keyof typeof EnumCountryCode]


export const EnumDistanceUnit: {
  KILOMETERS: 'KILOMETERS',
  MILES: 'MILES'
};

export type EnumDistanceUnit = (typeof EnumDistanceUnit)[keyof typeof EnumDistanceUnit]


export const EnumDeliverableAction: {
  MEET_AT_DOOR: 'MEET_AT_DOOR',
  LEAVE_AT_DOOR: 'LEAVE_AT_DOOR'
};

export type EnumDeliverableAction = (typeof EnumDeliverableAction)[keyof typeof EnumDeliverableAction]


export const EnumUndeliverableAction: {
  LEAVE_AT_DOOR: 'LEAVE_AT_DOOR',
  RETURN: 'RETURN',
  DISCARD: 'DISCARD'
};

export type EnumUndeliverableAction = (typeof EnumUndeliverableAction)[keyof typeof EnumUndeliverableAction]


export const EnumDeliveryStatus: {
  CREATED: 'CREATED',
  ASSIGNING_COURIER: 'ASSIGNING_COURIER',
  ACCEPTED: 'ACCEPTED',
  DISPATCHED: 'DISPATCHED',
  PICKED_UP: 'PICKED_UP',
  ON_THE_WAY: 'ON_THE_WAY',
  DROPPED_OFF: 'DROPPED_OFF',
  CANCELED: 'CANCELED',
  FAILED: 'FAILED'
};

export type EnumDeliveryStatus = (typeof EnumDeliveryStatus)[keyof typeof EnumDeliveryStatus]


export const EnumDeliveryEventType: {
  CREATED: 'CREATED',
  CONFIRMED: 'CONFIRMED',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  DISPATCHED: 'DISPATCHED',
  CANCELED: 'CANCELED',
  FULFILLED: 'FULFILLED',
  DROPPED_OFF: 'DROPPED_OFF',
  PICKED_UP: 'PICKED_UP',
  ON_THE_WAY: 'ON_THE_WAY',
  FAILED: 'FAILED'
};

export type EnumDeliveryEventType = (typeof EnumDeliveryEventType)[keyof typeof EnumDeliveryEventType]


export const EnumEventActor: {
  COURIER: 'COURIER',
  ADMIN: 'ADMIN',
  PARTNER: 'PARTNER'
};

export type EnumEventActor = (typeof EnumEventActor)[keyof typeof EnumEventActor]


export const EnumDeliveryEventSource: {
  OPENCOURIER: 'OPENCOURIER',
  PARTNER_APP: 'PARTNER_APP'
};

export type EnumDeliveryEventSource = (typeof EnumDeliveryEventSource)[keyof typeof EnumDeliveryEventSource]


export const EnumLocationNoteActor: {
  COURIER: 'COURIER',
  ADMIN: 'ADMIN',
  PARTNER: 'PARTNER'
};

export type EnumLocationNoteActor = (typeof EnumLocationNoteActor)[keyof typeof EnumLocationNoteActor]


export const EnumLocationNoteReactionType: {
  UPVOTE: 'UPVOTE',
  DOWNVOTE: 'DOWNVOTE'
};

export type EnumLocationNoteReactionType = (typeof EnumLocationNoteReactionType)[keyof typeof EnumLocationNoteReactionType]


export const EnumSettingVehicleType: {
  BICYCLE: 'BICYCLE',
  MOTORCYCLE: 'MOTORCYCLE',
  CAR: 'CAR',
  SCOOTER: 'SCOOTER',
  ON_FOOT: 'ON_FOOT'
};

export type EnumSettingVehicleType = (typeof EnumSettingVehicleType)[keyof typeof EnumSettingVehicleType]


export const EnumSettingDeliverySpeed: {
  REGULAR: 'REGULAR',
  RUSH: 'RUSH'
};

export type EnumSettingDeliverySpeed = (typeof EnumSettingDeliverySpeed)[keyof typeof EnumSettingDeliverySpeed]


export const EnumPayoutStatus: {
  PAID: 'PAID',
  PENDING: 'PENDING',
  IN_TRANSIT: 'IN_TRANSIT',
  CANCELED: 'CANCELED',
  FAILED: 'FAILED'
};

export type EnumPayoutStatus = (typeof EnumPayoutStatus)[keyof typeof EnumPayoutStatus]


export const EnumPaymentStatus: {
  CANCELED: 'CANCELED',
  REQUIRES_CONFIRMATION: 'REQUIRES_CONFIRMATION',
  REQUIRES_CAPTURE: 'REQUIRES_CAPTURE',
  PROCESSING: 'PROCESSING',
  REQUIRES_ACTION: 'REQUIRES_ACTION',
  REQUIRES_PAYMENT_METHOD: 'REQUIRES_PAYMENT_METHOD',
  SUCCEEDED: 'SUCCEEDED'
};

export type EnumPaymentStatus = (typeof EnumPaymentStatus)[keyof typeof EnumPaymentStatus]


export const EnumPaymentProvider: {
  STRIPE: 'STRIPE'
};

export type EnumPaymentProvider = (typeof EnumPaymentProvider)[keyof typeof EnumPaymentProvider]


export const EnumRefundReason: {
  DUPLICATE: 'DUPLICATE',
  FRAUDULENT: 'FRAUDULENT',
  REQUESTED_BY_CUSTOMER: 'REQUESTED_BY_CUSTOMER',
  EXPIRED_UNCAPTURED_CHARGE: 'EXPIRED_UNCAPTURED_CHARGE'
};

export type EnumRefundReason = (typeof EnumRefundReason)[keyof typeof EnumRefundReason]


export const EnumRefundStatus: {
  PENDING: 'PENDING',
  REQUIRES_ACTION: 'REQUIRES_ACTION',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED'
};

export type EnumRefundStatus = (typeof EnumRefundStatus)[keyof typeof EnumRefundStatus]

}

export type EnumUserRole = $Enums.EnumUserRole

export const EnumUserRole: typeof $Enums.EnumUserRole

export type EnumCourierStatus = $Enums.EnumCourierStatus

export const EnumCourierStatus: typeof $Enums.EnumCourierStatus

export type EnumCourierDeliverySetting = $Enums.EnumCourierDeliverySetting

export const EnumCourierDeliverySetting: typeof $Enums.EnumCourierDeliverySetting

export type EnumStripeAccountStatus = $Enums.EnumStripeAccountStatus

export const EnumStripeAccountStatus: typeof $Enums.EnumStripeAccountStatus

export type EnumCountryCode = $Enums.EnumCountryCode

export const EnumCountryCode: typeof $Enums.EnumCountryCode

export type EnumDistanceUnit = $Enums.EnumDistanceUnit

export const EnumDistanceUnit: typeof $Enums.EnumDistanceUnit

export type EnumDeliverableAction = $Enums.EnumDeliverableAction

export const EnumDeliverableAction: typeof $Enums.EnumDeliverableAction

export type EnumUndeliverableAction = $Enums.EnumUndeliverableAction

export const EnumUndeliverableAction: typeof $Enums.EnumUndeliverableAction

export type EnumDeliveryStatus = $Enums.EnumDeliveryStatus

export const EnumDeliveryStatus: typeof $Enums.EnumDeliveryStatus

export type EnumDeliveryEventType = $Enums.EnumDeliveryEventType

export const EnumDeliveryEventType: typeof $Enums.EnumDeliveryEventType

export type EnumEventActor = $Enums.EnumEventActor

export const EnumEventActor: typeof $Enums.EnumEventActor

export type EnumDeliveryEventSource = $Enums.EnumDeliveryEventSource

export const EnumDeliveryEventSource: typeof $Enums.EnumDeliveryEventSource

export type EnumLocationNoteActor = $Enums.EnumLocationNoteActor

export const EnumLocationNoteActor: typeof $Enums.EnumLocationNoteActor

export type EnumLocationNoteReactionType = $Enums.EnumLocationNoteReactionType

export const EnumLocationNoteReactionType: typeof $Enums.EnumLocationNoteReactionType

export type EnumSettingVehicleType = $Enums.EnumSettingVehicleType

export const EnumSettingVehicleType: typeof $Enums.EnumSettingVehicleType

export type EnumSettingDeliverySpeed = $Enums.EnumSettingDeliverySpeed

export const EnumSettingDeliverySpeed: typeof $Enums.EnumSettingDeliverySpeed

export type EnumPayoutStatus = $Enums.EnumPayoutStatus

export const EnumPayoutStatus: typeof $Enums.EnumPayoutStatus

export type EnumPaymentStatus = $Enums.EnumPaymentStatus

export const EnumPaymentStatus: typeof $Enums.EnumPaymentStatus

export type EnumPaymentProvider = $Enums.EnumPaymentProvider

export const EnumPaymentProvider: typeof $Enums.EnumPaymentProvider

export type EnumRefundReason = $Enums.EnumRefundReason

export const EnumRefundReason: typeof $Enums.EnumRefundReason

export type EnumRefundStatus = $Enums.EnumRefundStatus

export const EnumRefundStatus: typeof $Enums.EnumRefundStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.courier`: Exposes CRUD operations for the **Courier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Couriers
    * const couriers = await prisma.courier.findMany()
    * ```
    */
  get courier(): Prisma.CourierDelegate<ExtArgs>;

  /**
   * `prisma.earning`: Exposes CRUD operations for the **Earning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Earnings
    * const earnings = await prisma.earning.findMany()
    * ```
    */
  get earning(): Prisma.EarningDelegate<ExtArgs>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs>;

  /**
   * `prisma.partner`: Exposes CRUD operations for the **Partner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partners
    * const partners = await prisma.partner.findMany()
    * ```
    */
  get partner(): Prisma.PartnerDelegate<ExtArgs>;

  /**
   * `prisma.deliveryQuote`: Exposes CRUD operations for the **DeliveryQuote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryQuotes
    * const deliveryQuotes = await prisma.deliveryQuote.findMany()
    * ```
    */
  get deliveryQuote(): Prisma.DeliveryQuoteDelegate<ExtArgs>;

  /**
   * `prisma.delivery`: Exposes CRUD operations for the **Delivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliveries
    * const deliveries = await prisma.delivery.findMany()
    * ```
    */
  get delivery(): Prisma.DeliveryDelegate<ExtArgs>;

  /**
   * `prisma.deliveryEvent`: Exposes CRUD operations for the **DeliveryEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryEvents
    * const deliveryEvents = await prisma.deliveryEvent.findMany()
    * ```
    */
  get deliveryEvent(): Prisma.DeliveryEventDelegate<ExtArgs>;

  /**
   * `prisma.locationNote`: Exposes CRUD operations for the **LocationNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationNotes
    * const locationNotes = await prisma.locationNote.findMany()
    * ```
    */
  get locationNote(): Prisma.LocationNoteDelegate<ExtArgs>;

  /**
   * `prisma.locationNoteReaction`: Exposes CRUD operations for the **LocationNoteReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationNoteReactions
    * const locationNoteReactions = await prisma.locationNoteReaction.findMany()
    * ```
    */
  get locationNoteReaction(): Prisma.LocationNoteReactionDelegate<ExtArgs>;

  /**
   * `prisma.courierSetting`: Exposes CRUD operations for the **CourierSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourierSettings
    * const courierSettings = await prisma.courierSetting.findMany()
    * ```
    */
  get courierSetting(): Prisma.CourierSettingDelegate<ExtArgs>;

  /**
   * `prisma.payout`: Exposes CRUD operations for the **Payout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payouts
    * const payouts = await prisma.payout.findMany()
    * ```
    */
  get payout(): Prisma.PayoutDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.stripePaymentData`: Exposes CRUD operations for the **StripePaymentData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StripePaymentData
    * const stripePaymentData = await prisma.stripePaymentData.findMany()
    * ```
    */
  get stripePaymentData(): Prisma.StripePaymentDataDelegate<ExtArgs>;

  /**
   * `prisma.transfer`: Exposes CRUD operations for the **Transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transfers
    * const transfers = await prisma.transfer.findMany()
    * ```
    */
  get transfer(): Prisma.TransferDelegate<ExtArgs>;

  /**
   * `prisma.refund`: Exposes CRUD operations for the **Refund** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refunds
    * const refunds = await prisma.refund.findMany()
    * ```
    */
  get refund(): Prisma.RefundDelegate<ExtArgs>;

  /**
   * `prisma.config`: Exposes CRUD operations for the **Config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configs
    * const configs = await prisma.config.findMany()
    * ```
    */
  get config(): Prisma.ConfigDelegate<ExtArgs>;

  /**
   * `prisma.spatial_ref_sys`: Exposes CRUD operations for the **spatial_ref_sys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spatial_ref_sys
    * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany()
    * ```
    */
  get spatial_ref_sys(): Prisma.spatial_ref_sysDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.3.1
   * Query Engine version: 61e140623197a131c2a6189271ffee05a7aa9a59
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Comment: 'Comment',
    Courier: 'Courier',
    Earning: 'Earning',
    Location: 'Location',
    Partner: 'Partner',
    DeliveryQuote: 'DeliveryQuote',
    Delivery: 'Delivery',
    DeliveryEvent: 'DeliveryEvent',
    LocationNote: 'LocationNote',
    LocationNoteReaction: 'LocationNoteReaction',
    CourierSetting: 'CourierSetting',
    Payout: 'Payout',
    Payment: 'Payment',
    StripePaymentData: 'StripePaymentData',
    Transfer: 'Transfer',
    Refund: 'Refund',
    Config: 'Config',
    spatial_ref_sys: 'spatial_ref_sys'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    postgres?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'comment' | 'courier' | 'earning' | 'location' | 'partner' | 'deliveryQuote' | 'delivery' | 'deliveryEvent' | 'locationNote' | 'locationNoteReaction' | 'courierSetting' | 'payout' | 'payment' | 'stripePaymentData' | 'transfer' | 'refund' | 'config' | 'spatial_ref_sys'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Courier: {
        payload: Prisma.$CourierPayload<ExtArgs>
        fields: Prisma.CourierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourierFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourierFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          findFirst: {
            args: Prisma.CourierFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourierFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          findMany: {
            args: Prisma.CourierFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>[]
          }
          create: {
            args: Prisma.CourierCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          createMany: {
            args: Prisma.CourierCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CourierDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          update: {
            args: Prisma.CourierUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          deleteMany: {
            args: Prisma.CourierDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CourierUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CourierUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          aggregate: {
            args: Prisma.CourierAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCourier>
          }
          groupBy: {
            args: Prisma.CourierGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CourierGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourierCountArgs<ExtArgs>,
            result: $Utils.Optional<CourierCountAggregateOutputType> | number
          }
        }
      }
      Earning: {
        payload: Prisma.$EarningPayload<ExtArgs>
        fields: Prisma.EarningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EarningFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EarningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EarningFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EarningPayload>
          }
          findFirst: {
            args: Prisma.EarningFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EarningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EarningFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EarningPayload>
          }
          findMany: {
            args: Prisma.EarningFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EarningPayload>[]
          }
          create: {
            args: Prisma.EarningCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EarningPayload>
          }
          createMany: {
            args: Prisma.EarningCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EarningDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EarningPayload>
          }
          update: {
            args: Prisma.EarningUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EarningPayload>
          }
          deleteMany: {
            args: Prisma.EarningDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EarningUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EarningUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EarningPayload>
          }
          aggregate: {
            args: Prisma.EarningAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEarning>
          }
          groupBy: {
            args: Prisma.EarningGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EarningGroupByOutputType>[]
          }
          count: {
            args: Prisma.EarningCountArgs<ExtArgs>,
            result: $Utils.Optional<EarningCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>,
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Partner: {
        payload: Prisma.$PartnerPayload<ExtArgs>
        fields: Prisma.PartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findFirst: {
            args: Prisma.PartnerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findMany: {
            args: Prisma.PartnerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          create: {
            args: Prisma.PartnerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          createMany: {
            args: Prisma.PartnerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PartnerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          update: {
            args: Prisma.PartnerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          deleteMany: {
            args: Prisma.PartnerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PartnerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          aggregate: {
            args: Prisma.PartnerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePartner>
          }
          groupBy: {
            args: Prisma.PartnerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerCountArgs<ExtArgs>,
            result: $Utils.Optional<PartnerCountAggregateOutputType> | number
          }
        }
      }
      DeliveryQuote: {
        payload: Prisma.$DeliveryQuotePayload<ExtArgs>
        fields: Prisma.DeliveryQuoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryQuoteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryQuoteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuotePayload>
          }
          findFirst: {
            args: Prisma.DeliveryQuoteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryQuoteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuotePayload>
          }
          findMany: {
            args: Prisma.DeliveryQuoteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuotePayload>[]
          }
          create: {
            args: Prisma.DeliveryQuoteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuotePayload>
          }
          createMany: {
            args: Prisma.DeliveryQuoteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DeliveryQuoteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuotePayload>
          }
          update: {
            args: Prisma.DeliveryQuoteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuotePayload>
          }
          deleteMany: {
            args: Prisma.DeliveryQuoteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryQuoteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryQuoteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuotePayload>
          }
          aggregate: {
            args: Prisma.DeliveryQuoteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDeliveryQuote>
          }
          groupBy: {
            args: Prisma.DeliveryQuoteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DeliveryQuoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryQuoteCountArgs<ExtArgs>,
            result: $Utils.Optional<DeliveryQuoteCountAggregateOutputType> | number
          }
        }
      }
      Delivery: {
        payload: Prisma.$DeliveryPayload<ExtArgs>
        fields: Prisma.DeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          findFirst: {
            args: Prisma.DeliveryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          findMany: {
            args: Prisma.DeliveryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          create: {
            args: Prisma.DeliveryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          createMany: {
            args: Prisma.DeliveryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DeliveryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          update: {
            args: Prisma.DeliveryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          aggregate: {
            args: Prisma.DeliveryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDelivery>
          }
          groupBy: {
            args: Prisma.DeliveryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryCountArgs<ExtArgs>,
            result: $Utils.Optional<DeliveryCountAggregateOutputType> | number
          }
        }
      }
      DeliveryEvent: {
        payload: Prisma.$DeliveryEventPayload<ExtArgs>
        fields: Prisma.DeliveryEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryEventFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryEventFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>
          }
          findFirst: {
            args: Prisma.DeliveryEventFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryEventFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>
          }
          findMany: {
            args: Prisma.DeliveryEventFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>[]
          }
          create: {
            args: Prisma.DeliveryEventCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>
          }
          createMany: {
            args: Prisma.DeliveryEventCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DeliveryEventDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>
          }
          update: {
            args: Prisma.DeliveryEventUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryEventDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryEventUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryEventUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DeliveryEventPayload>
          }
          aggregate: {
            args: Prisma.DeliveryEventAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDeliveryEvent>
          }
          groupBy: {
            args: Prisma.DeliveryEventGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DeliveryEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryEventCountArgs<ExtArgs>,
            result: $Utils.Optional<DeliveryEventCountAggregateOutputType> | number
          }
        }
      }
      LocationNote: {
        payload: Prisma.$LocationNotePayload<ExtArgs>
        fields: Prisma.LocationNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationNoteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationNoteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNotePayload>
          }
          findFirst: {
            args: Prisma.LocationNoteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationNoteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNotePayload>
          }
          findMany: {
            args: Prisma.LocationNoteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNotePayload>[]
          }
          create: {
            args: Prisma.LocationNoteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNotePayload>
          }
          createMany: {
            args: Prisma.LocationNoteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LocationNoteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNotePayload>
          }
          update: {
            args: Prisma.LocationNoteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNotePayload>
          }
          deleteMany: {
            args: Prisma.LocationNoteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LocationNoteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LocationNoteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNotePayload>
          }
          aggregate: {
            args: Prisma.LocationNoteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLocationNote>
          }
          groupBy: {
            args: Prisma.LocationNoteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LocationNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationNoteCountArgs<ExtArgs>,
            result: $Utils.Optional<LocationNoteCountAggregateOutputType> | number
          }
        }
      }
      LocationNoteReaction: {
        payload: Prisma.$LocationNoteReactionPayload<ExtArgs>
        fields: Prisma.LocationNoteReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationNoteReactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNoteReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationNoteReactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNoteReactionPayload>
          }
          findFirst: {
            args: Prisma.LocationNoteReactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNoteReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationNoteReactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNoteReactionPayload>
          }
          findMany: {
            args: Prisma.LocationNoteReactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNoteReactionPayload>[]
          }
          create: {
            args: Prisma.LocationNoteReactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNoteReactionPayload>
          }
          createMany: {
            args: Prisma.LocationNoteReactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LocationNoteReactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNoteReactionPayload>
          }
          update: {
            args: Prisma.LocationNoteReactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNoteReactionPayload>
          }
          deleteMany: {
            args: Prisma.LocationNoteReactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LocationNoteReactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LocationNoteReactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LocationNoteReactionPayload>
          }
          aggregate: {
            args: Prisma.LocationNoteReactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLocationNoteReaction>
          }
          groupBy: {
            args: Prisma.LocationNoteReactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LocationNoteReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationNoteReactionCountArgs<ExtArgs>,
            result: $Utils.Optional<LocationNoteReactionCountAggregateOutputType> | number
          }
        }
      }
      CourierSetting: {
        payload: Prisma.$CourierSettingPayload<ExtArgs>
        fields: Prisma.CourierSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourierSettingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourierSettingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierSettingPayload>
          }
          findFirst: {
            args: Prisma.CourierSettingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourierSettingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierSettingPayload>
          }
          findMany: {
            args: Prisma.CourierSettingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierSettingPayload>[]
          }
          create: {
            args: Prisma.CourierSettingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierSettingPayload>
          }
          createMany: {
            args: Prisma.CourierSettingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CourierSettingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierSettingPayload>
          }
          update: {
            args: Prisma.CourierSettingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierSettingPayload>
          }
          deleteMany: {
            args: Prisma.CourierSettingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CourierSettingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CourierSettingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourierSettingPayload>
          }
          aggregate: {
            args: Prisma.CourierSettingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCourierSetting>
          }
          groupBy: {
            args: Prisma.CourierSettingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CourierSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourierSettingCountArgs<ExtArgs>,
            result: $Utils.Optional<CourierSettingCountAggregateOutputType> | number
          }
        }
      }
      Payout: {
        payload: Prisma.$PayoutPayload<ExtArgs>
        fields: Prisma.PayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayoutFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayoutFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          findFirst: {
            args: Prisma.PayoutFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayoutFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          findMany: {
            args: Prisma.PayoutFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>[]
          }
          create: {
            args: Prisma.PayoutCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          createMany: {
            args: Prisma.PayoutCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PayoutDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          update: {
            args: Prisma.PayoutUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          deleteMany: {
            args: Prisma.PayoutDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PayoutUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PayoutUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          aggregate: {
            args: Prisma.PayoutAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayout>
          }
          groupBy: {
            args: Prisma.PayoutGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayoutCountArgs<ExtArgs>,
            result: $Utils.Optional<PayoutCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      StripePaymentData: {
        payload: Prisma.$StripePaymentDataPayload<ExtArgs>
        fields: Prisma.StripePaymentDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StripePaymentDataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripePaymentDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StripePaymentDataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripePaymentDataPayload>
          }
          findFirst: {
            args: Prisma.StripePaymentDataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripePaymentDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StripePaymentDataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripePaymentDataPayload>
          }
          findMany: {
            args: Prisma.StripePaymentDataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripePaymentDataPayload>[]
          }
          create: {
            args: Prisma.StripePaymentDataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripePaymentDataPayload>
          }
          createMany: {
            args: Prisma.StripePaymentDataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StripePaymentDataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripePaymentDataPayload>
          }
          update: {
            args: Prisma.StripePaymentDataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripePaymentDataPayload>
          }
          deleteMany: {
            args: Prisma.StripePaymentDataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StripePaymentDataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StripePaymentDataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StripePaymentDataPayload>
          }
          aggregate: {
            args: Prisma.StripePaymentDataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStripePaymentData>
          }
          groupBy: {
            args: Prisma.StripePaymentDataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StripePaymentDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.StripePaymentDataCountArgs<ExtArgs>,
            result: $Utils.Optional<StripePaymentDataCountAggregateOutputType> | number
          }
        }
      }
      Transfer: {
        payload: Prisma.$TransferPayload<ExtArgs>
        fields: Prisma.TransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findFirst: {
            args: Prisma.TransferFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findMany: {
            args: Prisma.TransferFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          create: {
            args: Prisma.TransferCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          createMany: {
            args: Prisma.TransferCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TransferDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          update: {
            args: Prisma.TransferUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          deleteMany: {
            args: Prisma.TransferDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TransferUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TransferUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          aggregate: {
            args: Prisma.TransferAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTransfer>
          }
          groupBy: {
            args: Prisma.TransferGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferCountArgs<ExtArgs>,
            result: $Utils.Optional<TransferCountAggregateOutputType> | number
          }
        }
      }
      Refund: {
        payload: Prisma.$RefundPayload<ExtArgs>
        fields: Prisma.RefundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefundFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefundFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          findFirst: {
            args: Prisma.RefundFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefundFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          findMany: {
            args: Prisma.RefundFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          create: {
            args: Prisma.RefundCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          createMany: {
            args: Prisma.RefundCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RefundDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          update: {
            args: Prisma.RefundUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          deleteMany: {
            args: Prisma.RefundDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RefundUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RefundUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          aggregate: {
            args: Prisma.RefundAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRefund>
          }
          groupBy: {
            args: Prisma.RefundGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RefundGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefundCountArgs<ExtArgs>,
            result: $Utils.Optional<RefundCountAggregateOutputType> | number
          }
        }
      }
      Config: {
        payload: Prisma.$ConfigPayload<ExtArgs>
        fields: Prisma.ConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          findFirst: {
            args: Prisma.ConfigFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          findMany: {
            args: Prisma.ConfigFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>[]
          }
          create: {
            args: Prisma.ConfigCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          createMany: {
            args: Prisma.ConfigCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConfigDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          update: {
            args: Prisma.ConfigUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          deleteMany: {
            args: Prisma.ConfigDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConfigUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConfigPayload>
          }
          aggregate: {
            args: Prisma.ConfigAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConfig>
          }
          groupBy: {
            args: Prisma.ConfigGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigCountArgs<ExtArgs>,
            result: $Utils.Optional<ConfigCountAggregateOutputType> | number
          }
        }
      }
      spatial_ref_sys: {
        payload: Prisma.$spatial_ref_sysPayload<ExtArgs>
        fields: Prisma.spatial_ref_sysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.spatial_ref_sysFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          findFirst: {
            args: Prisma.spatial_ref_sysFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.spatial_ref_sysFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          findMany: {
            args: Prisma.spatial_ref_sysFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>[]
          }
          create: {
            args: Prisma.spatial_ref_sysCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          createMany: {
            args: Prisma.spatial_ref_sysCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.spatial_ref_sysDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          update: {
            args: Prisma.spatial_ref_sysUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          deleteMany: {
            args: Prisma.spatial_ref_sysDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.spatial_ref_sysUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.spatial_ref_sysUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          aggregate: {
            args: Prisma.Spatial_ref_sysAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpatial_ref_sys>
          }
          groupBy: {
            args: Prisma.spatial_ref_sysGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Spatial_ref_sysGroupByOutputType>[]
          }
          count: {
            args: Prisma.spatial_ref_sysCountArgs<ExtArgs>,
            result: $Utils.Optional<Spatial_ref_sysCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CourierCountOutputType
   */

  export type CourierCountOutputType = {
    comments: number
    earnings: number
    deliveries: number
    Payout: number
    Transfer: number
    locationNotes: number
    locationNoteReactions: number
  }

  export type CourierCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    comments?: boolean | CourierCountOutputTypeCountCommentsArgs
    earnings?: boolean | CourierCountOutputTypeCountEarningsArgs
    deliveries?: boolean | CourierCountOutputTypeCountDeliveriesArgs
    Payout?: boolean | CourierCountOutputTypeCountPayoutArgs
    Transfer?: boolean | CourierCountOutputTypeCountTransferArgs
    locationNotes?: boolean | CourierCountOutputTypeCountLocationNotesArgs
    locationNoteReactions?: boolean | CourierCountOutputTypeCountLocationNoteReactionsArgs
  }

  // Custom InputTypes

  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierCountOutputType
     */
    select?: CourierCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountEarningsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EarningWhereInput
  }


  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }


  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountPayoutArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PayoutWhereInput
  }


  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountTransferArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }


  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountLocationNotesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LocationNoteWhereInput
  }


  /**
   * CourierCountOutputType without action
   */
  export type CourierCountOutputTypeCountLocationNoteReactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LocationNoteReactionWhereInput
  }



  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    locationNotes: number
    pickupDelivery: number
    dropoffDelivery: number
    pickupDeliveryQuotes: number
    dropoffDeliveryQuotes: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    locationNotes?: boolean | LocationCountOutputTypeCountLocationNotesArgs
    pickupDelivery?: boolean | LocationCountOutputTypeCountPickupDeliveryArgs
    dropoffDelivery?: boolean | LocationCountOutputTypeCountDropoffDeliveryArgs
    pickupDeliveryQuotes?: boolean | LocationCountOutputTypeCountPickupDeliveryQuotesArgs
    dropoffDeliveryQuotes?: boolean | LocationCountOutputTypeCountDropoffDeliveryQuotesArgs
  }

  // Custom InputTypes

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountLocationNotesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LocationNoteWhereInput
  }


  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountPickupDeliveryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }


  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountDropoffDeliveryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }


  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountPickupDeliveryQuotesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DeliveryQuoteWhereInput
  }


  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountDropoffDeliveryQuotesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DeliveryQuoteWhereInput
  }



  /**
   * Count Type PartnerCountOutputType
   */

  export type PartnerCountOutputType = {
    deliveries: number
    deliveryQuotes: number
  }

  export type PartnerCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    deliveries?: boolean | PartnerCountOutputTypeCountDeliveriesArgs
    deliveryQuotes?: boolean | PartnerCountOutputTypeCountDeliveryQuotesArgs
  }

  // Custom InputTypes

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCountOutputType
     */
    select?: PartnerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }


  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountDeliveryQuotesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DeliveryQuoteWhereInput
  }



  /**
   * Count Type DeliveryCountOutputType
   */

  export type DeliveryCountOutputType = {
    payment: number
    deliveryEvent: number
    locationNote: number
  }

  export type DeliveryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    payment?: boolean | DeliveryCountOutputTypeCountPaymentArgs
    deliveryEvent?: boolean | DeliveryCountOutputTypeCountDeliveryEventArgs
    locationNote?: boolean | DeliveryCountOutputTypeCountLocationNoteArgs
  }

  // Custom InputTypes

  /**
   * DeliveryCountOutputType without action
   */
  export type DeliveryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryCountOutputType
     */
    select?: DeliveryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DeliveryCountOutputType without action
   */
  export type DeliveryCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * DeliveryCountOutputType without action
   */
  export type DeliveryCountOutputTypeCountDeliveryEventArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DeliveryEventWhereInput
  }


  /**
   * DeliveryCountOutputType without action
   */
  export type DeliveryCountOutputTypeCountLocationNoteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LocationNoteWhereInput
  }



  /**
   * Count Type LocationNoteCountOutputType
   */

  export type LocationNoteCountOutputType = {
    noteReactions: number
  }

  export type LocationNoteCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    noteReactions?: boolean | LocationNoteCountOutputTypeCountNoteReactionsArgs
  }

  // Custom InputTypes

  /**
   * LocationNoteCountOutputType without action
   */
  export type LocationNoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNoteCountOutputType
     */
    select?: LocationNoteCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LocationNoteCountOutputType without action
   */
  export type LocationNoteCountOutputTypeCountNoteReactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LocationNoteReactionWhereInput
  }



  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    transfers: number
    refunds: number
    payouts: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    transfers?: boolean | PaymentCountOutputTypeCountTransfersArgs
    refunds?: boolean | PaymentCountOutputTypeCountRefundsArgs
    payouts?: boolean | PaymentCountOutputTypeCountPayoutsArgs
  }

  // Custom InputTypes

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountTransfersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }


  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountRefundsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput
  }


  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountPayoutsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PayoutWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    username: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    username?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationAndSearchRelevanceInput | UserOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    password: string | null
    role: $Enums.EnumUserRole[]
    username: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    username?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courier?: boolean | User$courierArgs<ExtArgs>
    partner?: boolean | User$partnerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    username?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    courier?: boolean | User$courierArgs<ExtArgs>
    partner?: boolean | User$partnerArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      courier: Prisma.$CourierPayload<ExtArgs> | null
      partner: Prisma.$PartnerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      email: string | null
      password: string | null
      role: $Enums.EnumUserRole[]
      username: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    courier<T extends User$courierArgs<ExtArgs> = {}>(args?: Subset<T, User$courierArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    partner<T extends User$partnerArgs<ExtArgs> = {}>(args?: Subset<T, User$partnerArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'EnumUserRole[]'>
    readonly username: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationAndSearchRelevanceInput | UserOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationAndSearchRelevanceInput | UserOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationAndSearchRelevanceInput | UserOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.courier
   */
  export type User$courierArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    where?: CourierWhereInput
  }


  /**
   * User.partner
   */
  export type User$partnerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    likes: number | null
  }

  export type CommentSumAggregateOutputType = {
    likes: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    text: string | null
    likes: number | null
    commentableId: string | null
    commentableType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    courierId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    text: string | null
    likes: number | null
    commentableId: string | null
    commentableType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    courierId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    text: number
    likes: number
    likers: number
    commentableId: number
    commentableType: number
    createdAt: number
    updatedAt: number
    courierId: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    likes?: true
  }

  export type CommentSumAggregateInputType = {
    likes?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    text?: true
    likes?: true
    commentableId?: true
    commentableType?: true
    createdAt?: true
    updatedAt?: true
    courierId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    text?: true
    likes?: true
    commentableId?: true
    commentableType?: true
    createdAt?: true
    updatedAt?: true
    courierId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    text?: true
    likes?: true
    likers?: true
    commentableId?: true
    commentableType?: true
    createdAt?: true
    updatedAt?: true
    courierId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationAndSearchRelevanceInput | CommentOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    text: string | null
    likes: number | null
    likers: string[]
    commentableId: string
    commentableType: string
    createdAt: Date
    updatedAt: Date
    courierId: string | null
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    likes?: boolean
    likers?: boolean
    commentableId?: boolean
    commentableType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courierId?: boolean
    couriers?: boolean | Comment$couriersArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    text?: boolean
    likes?: boolean
    likers?: boolean
    commentableId?: boolean
    commentableType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courierId?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    couriers?: boolean | Comment$couriersArgs<ExtArgs>
  }


  export type $CommentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      couriers: Prisma.$CourierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      text: string | null
      likes: number | null
      likers: string[]
      commentableId: string
      commentableType: string
      createdAt: Date
      updatedAt: Date
      courierId: string | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }


  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    couriers<T extends Comment$couriersArgs<ExtArgs> = {}>(args?: Subset<T, Comment$couriersArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly text: FieldRef<"Comment", 'String'>
    readonly likes: FieldRef<"Comment", 'Int'>
    readonly likers: FieldRef<"Comment", 'String[]'>
    readonly commentableId: FieldRef<"Comment", 'String'>
    readonly commentableType: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
    readonly courierId: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationAndSearchRelevanceInput | CommentOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationAndSearchRelevanceInput | CommentOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationAndSearchRelevanceInput | CommentOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment.couriers
   */
  export type Comment$couriersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    where?: CourierWhereInput
  }


  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
  }



  /**
   * Model Courier
   */

  export type AggregateCourier = {
    _count: CourierCountAggregateOutputType | null
    _min: CourierMinAggregateOutputType | null
    _max: CourierMaxAggregateOutputType | null
  }

  export type CourierMinAggregateOutputType = {
    id: string | null
    node_uri: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    status: $Enums.EnumCourierStatus | null
    deliverySetting: $Enums.EnumCourierDeliverySetting | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    stripeAccountId: string | null
    stripeAccountStatus: $Enums.EnumStripeAccountStatus | null
  }

  export type CourierMaxAggregateOutputType = {
    id: string | null
    node_uri: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    status: $Enums.EnumCourierStatus | null
    deliverySetting: $Enums.EnumCourierDeliverySetting | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    stripeAccountId: string | null
    stripeAccountStatus: $Enums.EnumStripeAccountStatus | null
  }

  export type CourierCountAggregateOutputType = {
    id: number
    node_uri: number
    firstName: number
    lastName: number
    phoneNumber: number
    status: number
    deliverySetting: number
    rejectedOffers: number
    createdAt: number
    updatedAt: number
    userId: number
    stripeAccountId: number
    stripeAccountStatus: number
    _all: number
  }


  export type CourierMinAggregateInputType = {
    id?: true
    node_uri?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    status?: true
    deliverySetting?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    stripeAccountId?: true
    stripeAccountStatus?: true
  }

  export type CourierMaxAggregateInputType = {
    id?: true
    node_uri?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    status?: true
    deliverySetting?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    stripeAccountId?: true
    stripeAccountStatus?: true
  }

  export type CourierCountAggregateInputType = {
    id?: true
    node_uri?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    status?: true
    deliverySetting?: true
    rejectedOffers?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    stripeAccountId?: true
    stripeAccountStatus?: true
    _all?: true
  }

  export type CourierAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courier to aggregate.
     */
    where?: CourierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CourierOrderByWithRelationAndSearchRelevanceInput | CourierOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Couriers
    **/
    _count?: true | CourierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourierMaxAggregateInputType
  }

  export type GetCourierAggregateType<T extends CourierAggregateArgs> = {
        [P in keyof T & keyof AggregateCourier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourier[P]>
      : GetScalarType<T[P], AggregateCourier[P]>
  }




  export type CourierGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CourierWhereInput
    orderBy?: CourierOrderByWithAggregationInput | CourierOrderByWithAggregationInput[]
    by: CourierScalarFieldEnum[] | CourierScalarFieldEnum
    having?: CourierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourierCountAggregateInputType | true
    _min?: CourierMinAggregateInputType
    _max?: CourierMaxAggregateInputType
  }

  export type CourierGroupByOutputType = {
    id: string
    node_uri: string | null
    firstName: string
    lastName: string
    phoneNumber: string | null
    status: $Enums.EnumCourierStatus
    deliverySetting: $Enums.EnumCourierDeliverySetting
    rejectedOffers: string[]
    createdAt: Date
    updatedAt: Date
    userId: string
    stripeAccountId: string | null
    stripeAccountStatus: $Enums.EnumStripeAccountStatus
    _count: CourierCountAggregateOutputType | null
    _min: CourierMinAggregateOutputType | null
    _max: CourierMaxAggregateOutputType | null
  }

  type GetCourierGroupByPayload<T extends CourierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourierGroupByOutputType[P]>
            : GetScalarType<T[P], CourierGroupByOutputType[P]>
        }
      >
    >


  export type CourierSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    node_uri?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    status?: boolean
    deliverySetting?: boolean
    rejectedOffers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    stripeAccountId?: boolean
    stripeAccountStatus?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Courier$commentsArgs<ExtArgs>
    earnings?: boolean | Courier$earningsArgs<ExtArgs>
    deliveries?: boolean | Courier$deliveriesArgs<ExtArgs>
    settings?: boolean | Courier$settingsArgs<ExtArgs>
    Payout?: boolean | Courier$PayoutArgs<ExtArgs>
    Transfer?: boolean | Courier$TransferArgs<ExtArgs>
    locationNotes?: boolean | Courier$locationNotesArgs<ExtArgs>
    locationNoteReactions?: boolean | Courier$locationNoteReactionsArgs<ExtArgs>
    _count?: boolean | CourierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courier"]>

  export type CourierSelectScalar = {
    id?: boolean
    node_uri?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    status?: boolean
    deliverySetting?: boolean
    rejectedOffers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    stripeAccountId?: boolean
    stripeAccountStatus?: boolean
  }

  export type CourierInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Courier$commentsArgs<ExtArgs>
    earnings?: boolean | Courier$earningsArgs<ExtArgs>
    deliveries?: boolean | Courier$deliveriesArgs<ExtArgs>
    settings?: boolean | Courier$settingsArgs<ExtArgs>
    Payout?: boolean | Courier$PayoutArgs<ExtArgs>
    Transfer?: boolean | Courier$TransferArgs<ExtArgs>
    locationNotes?: boolean | Courier$locationNotesArgs<ExtArgs>
    locationNoteReactions?: boolean | Courier$locationNoteReactionsArgs<ExtArgs>
    _count?: boolean | CourierCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CourierPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Courier"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
      earnings: Prisma.$EarningPayload<ExtArgs>[]
      deliveries: Prisma.$DeliveryPayload<ExtArgs>[]
      settings: Prisma.$CourierSettingPayload<ExtArgs> | null
      Payout: Prisma.$PayoutPayload<ExtArgs>[]
      Transfer: Prisma.$TransferPayload<ExtArgs>[]
      locationNotes: Prisma.$LocationNotePayload<ExtArgs>[]
      locationNoteReactions: Prisma.$LocationNoteReactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      node_uri: string | null
      firstName: string
      lastName: string
      phoneNumber: string | null
      status: $Enums.EnumCourierStatus
      deliverySetting: $Enums.EnumCourierDeliverySetting
      rejectedOffers: string[]
      createdAt: Date
      updatedAt: Date
      userId: string
      stripeAccountId: string | null
      stripeAccountStatus: $Enums.EnumStripeAccountStatus
    }, ExtArgs["result"]["courier"]>
    composites: {}
  }


  type CourierGetPayload<S extends boolean | null | undefined | CourierDefaultArgs> = $Result.GetResult<Prisma.$CourierPayload, S>

  type CourierCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CourierFindManyArgs, 'select' | 'include'> & {
      select?: CourierCountAggregateInputType | true
    }

  export interface CourierDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Courier'], meta: { name: 'Courier' } }
    /**
     * Find zero or one Courier that matches the filter.
     * @param {CourierFindUniqueArgs} args - Arguments to find a Courier
     * @example
     * // Get one Courier
     * const courier = await prisma.courier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CourierFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CourierFindUniqueArgs<ExtArgs>>
    ): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Courier that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CourierFindUniqueOrThrowArgs} args - Arguments to find a Courier
     * @example
     * // Get one Courier
     * const courier = await prisma.courier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CourierFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Courier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierFindFirstArgs} args - Arguments to find a Courier
     * @example
     * // Get one Courier
     * const courier = await prisma.courier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CourierFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CourierFindFirstArgs<ExtArgs>>
    ): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Courier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierFindFirstOrThrowArgs} args - Arguments to find a Courier
     * @example
     * // Get one Courier
     * const courier = await prisma.courier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CourierFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Couriers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Couriers
     * const couriers = await prisma.courier.findMany()
     * 
     * // Get first 10 Couriers
     * const couriers = await prisma.courier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courierWithIdOnly = await prisma.courier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CourierFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Courier.
     * @param {CourierCreateArgs} args - Arguments to create a Courier.
     * @example
     * // Create one Courier
     * const Courier = await prisma.courier.create({
     *   data: {
     *     // ... data to create a Courier
     *   }
     * })
     * 
    **/
    create<T extends CourierCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CourierCreateArgs<ExtArgs>>
    ): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Couriers.
     *     @param {CourierCreateManyArgs} args - Arguments to create many Couriers.
     *     @example
     *     // Create many Couriers
     *     const courier = await prisma.courier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CourierCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Courier.
     * @param {CourierDeleteArgs} args - Arguments to delete one Courier.
     * @example
     * // Delete one Courier
     * const Courier = await prisma.courier.delete({
     *   where: {
     *     // ... filter to delete one Courier
     *   }
     * })
     * 
    **/
    delete<T extends CourierDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CourierDeleteArgs<ExtArgs>>
    ): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Courier.
     * @param {CourierUpdateArgs} args - Arguments to update one Courier.
     * @example
     * // Update one Courier
     * const courier = await prisma.courier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CourierUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CourierUpdateArgs<ExtArgs>>
    ): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Couriers.
     * @param {CourierDeleteManyArgs} args - Arguments to filter Couriers to delete.
     * @example
     * // Delete a few Couriers
     * const { count } = await prisma.courier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CourierDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Couriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Couriers
     * const courier = await prisma.courier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CourierUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CourierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Courier.
     * @param {CourierUpsertArgs} args - Arguments to update or create a Courier.
     * @example
     * // Update or create a Courier
     * const courier = await prisma.courier.upsert({
     *   create: {
     *     // ... data to create a Courier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Courier we want to update
     *   }
     * })
    **/
    upsert<T extends CourierUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CourierUpsertArgs<ExtArgs>>
    ): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Couriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierCountArgs} args - Arguments to filter Couriers to count.
     * @example
     * // Count the number of Couriers
     * const count = await prisma.courier.count({
     *   where: {
     *     // ... the filter for the Couriers we want to count
     *   }
     * })
    **/
    count<T extends CourierCountArgs>(
      args?: Subset<T, CourierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Courier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourierAggregateArgs>(args: Subset<T, CourierAggregateArgs>): Prisma.PrismaPromise<GetCourierAggregateType<T>>

    /**
     * Group by Courier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourierGroupByArgs['orderBy'] }
        : { orderBy?: CourierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Courier model
   */
  readonly fields: CourierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Courier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourierClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    comments<T extends Courier$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Courier$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    earnings<T extends Courier$earningsArgs<ExtArgs> = {}>(args?: Subset<T, Courier$earningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EarningPayload<ExtArgs>, T, 'findMany'> | Null>;

    deliveries<T extends Courier$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Courier$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'findMany'> | Null>;

    settings<T extends Courier$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Courier$settingsArgs<ExtArgs>>): Prisma__CourierSettingClient<$Result.GetResult<Prisma.$CourierSettingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Payout<T extends Courier$PayoutArgs<ExtArgs> = {}>(args?: Subset<T, Courier$PayoutArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, 'findMany'> | Null>;

    Transfer<T extends Courier$TransferArgs<ExtArgs> = {}>(args?: Subset<T, Courier$TransferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, 'findMany'> | Null>;

    locationNotes<T extends Courier$locationNotesArgs<ExtArgs> = {}>(args?: Subset<T, Courier$locationNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNotePayload<ExtArgs>, T, 'findMany'> | Null>;

    locationNoteReactions<T extends Courier$locationNoteReactionsArgs<ExtArgs> = {}>(args?: Subset<T, Courier$locationNoteReactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNoteReactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Courier model
   */ 
  interface CourierFieldRefs {
    readonly id: FieldRef<"Courier", 'String'>
    readonly node_uri: FieldRef<"Courier", 'String'>
    readonly firstName: FieldRef<"Courier", 'String'>
    readonly lastName: FieldRef<"Courier", 'String'>
    readonly phoneNumber: FieldRef<"Courier", 'String'>
    readonly status: FieldRef<"Courier", 'EnumCourierStatus'>
    readonly deliverySetting: FieldRef<"Courier", 'EnumCourierDeliverySetting'>
    readonly rejectedOffers: FieldRef<"Courier", 'String[]'>
    readonly createdAt: FieldRef<"Courier", 'DateTime'>
    readonly updatedAt: FieldRef<"Courier", 'DateTime'>
    readonly userId: FieldRef<"Courier", 'String'>
    readonly stripeAccountId: FieldRef<"Courier", 'String'>
    readonly stripeAccountStatus: FieldRef<"Courier", 'EnumStripeAccountStatus'>
  }
    

  // Custom InputTypes

  /**
   * Courier findUnique
   */
  export type CourierFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * Filter, which Courier to fetch.
     */
    where: CourierWhereUniqueInput
  }


  /**
   * Courier findUniqueOrThrow
   */
  export type CourierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * Filter, which Courier to fetch.
     */
    where: CourierWhereUniqueInput
  }


  /**
   * Courier findFirst
   */
  export type CourierFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * Filter, which Courier to fetch.
     */
    where?: CourierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CourierOrderByWithRelationAndSearchRelevanceInput | CourierOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Couriers.
     */
    cursor?: CourierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Couriers.
     */
    distinct?: CourierScalarFieldEnum | CourierScalarFieldEnum[]
  }


  /**
   * Courier findFirstOrThrow
   */
  export type CourierFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * Filter, which Courier to fetch.
     */
    where?: CourierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CourierOrderByWithRelationAndSearchRelevanceInput | CourierOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Couriers.
     */
    cursor?: CourierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Couriers.
     */
    distinct?: CourierScalarFieldEnum | CourierScalarFieldEnum[]
  }


  /**
   * Courier findMany
   */
  export type CourierFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * Filter, which Couriers to fetch.
     */
    where?: CourierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CourierOrderByWithRelationAndSearchRelevanceInput | CourierOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Couriers.
     */
    cursor?: CourierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    distinct?: CourierScalarFieldEnum | CourierScalarFieldEnum[]
  }


  /**
   * Courier create
   */
  export type CourierCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * The data needed to create a Courier.
     */
    data: XOR<CourierCreateInput, CourierUncheckedCreateInput>
  }


  /**
   * Courier createMany
   */
  export type CourierCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Couriers.
     */
    data: CourierCreateManyInput | CourierCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Courier update
   */
  export type CourierUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * The data needed to update a Courier.
     */
    data: XOR<CourierUpdateInput, CourierUncheckedUpdateInput>
    /**
     * Choose, which Courier to update.
     */
    where: CourierWhereUniqueInput
  }


  /**
   * Courier updateMany
   */
  export type CourierUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Couriers.
     */
    data: XOR<CourierUpdateManyMutationInput, CourierUncheckedUpdateManyInput>
    /**
     * Filter which Couriers to update
     */
    where?: CourierWhereInput
  }


  /**
   * Courier upsert
   */
  export type CourierUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * The filter to search for the Courier to update in case it exists.
     */
    where: CourierWhereUniqueInput
    /**
     * In case the Courier found by the `where` argument doesn't exist, create a new Courier with this data.
     */
    create: XOR<CourierCreateInput, CourierUncheckedCreateInput>
    /**
     * In case the Courier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourierUpdateInput, CourierUncheckedUpdateInput>
  }


  /**
   * Courier delete
   */
  export type CourierDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    /**
     * Filter which Courier to delete.
     */
    where: CourierWhereUniqueInput
  }


  /**
   * Courier deleteMany
   */
  export type CourierDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Couriers to delete
     */
    where?: CourierWhereInput
  }


  /**
   * Courier.comments
   */
  export type Courier$commentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationAndSearchRelevanceInput | CommentOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Courier.earnings
   */
  export type Courier$earningsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Earning
     */
    select?: EarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EarningInclude<ExtArgs> | null
    where?: EarningWhereInput
    orderBy?: EarningOrderByWithRelationAndSearchRelevanceInput | EarningOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: EarningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EarningScalarFieldEnum | EarningScalarFieldEnum[]
  }


  /**
   * Courier.deliveries
   */
  export type Courier$deliveriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationAndSearchRelevanceInput | DeliveryOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }


  /**
   * Courier.settings
   */
  export type Courier$settingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierSetting
     */
    select?: CourierSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierSettingInclude<ExtArgs> | null
    where?: CourierSettingWhereInput
  }


  /**
   * Courier.Payout
   */
  export type Courier$PayoutArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayoutInclude<ExtArgs> | null
    where?: PayoutWhereInput
    orderBy?: PayoutOrderByWithRelationAndSearchRelevanceInput | PayoutOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: PayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }


  /**
   * Courier.Transfer
   */
  export type Courier$TransferArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationAndSearchRelevanceInput | TransferOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }


  /**
   * Courier.locationNotes
   */
  export type Courier$locationNotesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNote
     */
    select?: LocationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteInclude<ExtArgs> | null
    where?: LocationNoteWhereInput
    orderBy?: LocationNoteOrderByWithRelationAndSearchRelevanceInput | LocationNoteOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: LocationNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationNoteScalarFieldEnum | LocationNoteScalarFieldEnum[]
  }


  /**
   * Courier.locationNoteReactions
   */
  export type Courier$locationNoteReactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNoteReaction
     */
    select?: LocationNoteReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteReactionInclude<ExtArgs> | null
    where?: LocationNoteReactionWhereInput
    orderBy?: LocationNoteReactionOrderByWithRelationAndSearchRelevanceInput | LocationNoteReactionOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: LocationNoteReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationNoteReactionScalarFieldEnum | LocationNoteReactionScalarFieldEnum[]
  }


  /**
   * Courier without action
   */
  export type CourierDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
  }



  /**
   * Model Earning
   */

  export type AggregateEarning = {
    _count: EarningCountAggregateOutputType | null
    _avg: EarningAvgAggregateOutputType | null
    _sum: EarningSumAggregateOutputType | null
    _min: EarningMinAggregateOutputType | null
    _max: EarningMaxAggregateOutputType | null
  }

  export type EarningAvgAggregateOutputType = {
    total: number | null
    pending: number | null
    received: number | null
  }

  export type EarningSumAggregateOutputType = {
    total: number | null
    pending: number | null
    received: number | null
  }

  export type EarningMinAggregateOutputType = {
    id: string | null
    total: number | null
    pending: number | null
    received: number | null
    payoutMethod: string | null
    createdAt: Date | null
    updatedAt: Date | null
    courierId: string | null
  }

  export type EarningMaxAggregateOutputType = {
    id: string | null
    total: number | null
    pending: number | null
    received: number | null
    payoutMethod: string | null
    createdAt: Date | null
    updatedAt: Date | null
    courierId: string | null
  }

  export type EarningCountAggregateOutputType = {
    id: number
    total: number
    pending: number
    received: number
    payoutMethod: number
    createdAt: number
    updatedAt: number
    courierId: number
    _all: number
  }


  export type EarningAvgAggregateInputType = {
    total?: true
    pending?: true
    received?: true
  }

  export type EarningSumAggregateInputType = {
    total?: true
    pending?: true
    received?: true
  }

  export type EarningMinAggregateInputType = {
    id?: true
    total?: true
    pending?: true
    received?: true
    payoutMethod?: true
    createdAt?: true
    updatedAt?: true
    courierId?: true
  }

  export type EarningMaxAggregateInputType = {
    id?: true
    total?: true
    pending?: true
    received?: true
    payoutMethod?: true
    createdAt?: true
    updatedAt?: true
    courierId?: true
  }

  export type EarningCountAggregateInputType = {
    id?: true
    total?: true
    pending?: true
    received?: true
    payoutMethod?: true
    createdAt?: true
    updatedAt?: true
    courierId?: true
    _all?: true
  }

  export type EarningAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Earning to aggregate.
     */
    where?: EarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Earnings to fetch.
     */
    orderBy?: EarningOrderByWithRelationAndSearchRelevanceInput | EarningOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Earnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Earnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Earnings
    **/
    _count?: true | EarningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EarningAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EarningSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EarningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EarningMaxAggregateInputType
  }

  export type GetEarningAggregateType<T extends EarningAggregateArgs> = {
        [P in keyof T & keyof AggregateEarning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEarning[P]>
      : GetScalarType<T[P], AggregateEarning[P]>
  }




  export type EarningGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EarningWhereInput
    orderBy?: EarningOrderByWithAggregationInput | EarningOrderByWithAggregationInput[]
    by: EarningScalarFieldEnum[] | EarningScalarFieldEnum
    having?: EarningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EarningCountAggregateInputType | true
    _avg?: EarningAvgAggregateInputType
    _sum?: EarningSumAggregateInputType
    _min?: EarningMinAggregateInputType
    _max?: EarningMaxAggregateInputType
  }

  export type EarningGroupByOutputType = {
    id: string
    total: number
    pending: number
    received: number
    payoutMethod: string | null
    createdAt: Date
    updatedAt: Date
    courierId: string | null
    _count: EarningCountAggregateOutputType | null
    _avg: EarningAvgAggregateOutputType | null
    _sum: EarningSumAggregateOutputType | null
    _min: EarningMinAggregateOutputType | null
    _max: EarningMaxAggregateOutputType | null
  }

  type GetEarningGroupByPayload<T extends EarningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EarningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EarningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EarningGroupByOutputType[P]>
            : GetScalarType<T[P], EarningGroupByOutputType[P]>
        }
      >
    >


  export type EarningSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total?: boolean
    pending?: boolean
    received?: boolean
    payoutMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courierId?: boolean
    couriers?: boolean | Earning$couriersArgs<ExtArgs>
  }, ExtArgs["result"]["earning"]>

  export type EarningSelectScalar = {
    id?: boolean
    total?: boolean
    pending?: boolean
    received?: boolean
    payoutMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courierId?: boolean
  }

  export type EarningInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    couriers?: boolean | Earning$couriersArgs<ExtArgs>
  }


  export type $EarningPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Earning"
    objects: {
      couriers: Prisma.$CourierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      total: number
      pending: number
      received: number
      payoutMethod: string | null
      createdAt: Date
      updatedAt: Date
      courierId: string | null
    }, ExtArgs["result"]["earning"]>
    composites: {}
  }


  type EarningGetPayload<S extends boolean | null | undefined | EarningDefaultArgs> = $Result.GetResult<Prisma.$EarningPayload, S>

  type EarningCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EarningFindManyArgs, 'select' | 'include'> & {
      select?: EarningCountAggregateInputType | true
    }

  export interface EarningDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Earning'], meta: { name: 'Earning' } }
    /**
     * Find zero or one Earning that matches the filter.
     * @param {EarningFindUniqueArgs} args - Arguments to find a Earning
     * @example
     * // Get one Earning
     * const earning = await prisma.earning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EarningFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EarningFindUniqueArgs<ExtArgs>>
    ): Prisma__EarningClient<$Result.GetResult<Prisma.$EarningPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Earning that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EarningFindUniqueOrThrowArgs} args - Arguments to find a Earning
     * @example
     * // Get one Earning
     * const earning = await prisma.earning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EarningFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EarningFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EarningClient<$Result.GetResult<Prisma.$EarningPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Earning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EarningFindFirstArgs} args - Arguments to find a Earning
     * @example
     * // Get one Earning
     * const earning = await prisma.earning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EarningFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EarningFindFirstArgs<ExtArgs>>
    ): Prisma__EarningClient<$Result.GetResult<Prisma.$EarningPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Earning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EarningFindFirstOrThrowArgs} args - Arguments to find a Earning
     * @example
     * // Get one Earning
     * const earning = await prisma.earning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EarningFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EarningFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EarningClient<$Result.GetResult<Prisma.$EarningPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Earnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EarningFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Earnings
     * const earnings = await prisma.earning.findMany()
     * 
     * // Get first 10 Earnings
     * const earnings = await prisma.earning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const earningWithIdOnly = await prisma.earning.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EarningFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EarningFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EarningPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Earning.
     * @param {EarningCreateArgs} args - Arguments to create a Earning.
     * @example
     * // Create one Earning
     * const Earning = await prisma.earning.create({
     *   data: {
     *     // ... data to create a Earning
     *   }
     * })
     * 
    **/
    create<T extends EarningCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EarningCreateArgs<ExtArgs>>
    ): Prisma__EarningClient<$Result.GetResult<Prisma.$EarningPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Earnings.
     *     @param {EarningCreateManyArgs} args - Arguments to create many Earnings.
     *     @example
     *     // Create many Earnings
     *     const earning = await prisma.earning.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EarningCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EarningCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Earning.
     * @param {EarningDeleteArgs} args - Arguments to delete one Earning.
     * @example
     * // Delete one Earning
     * const Earning = await prisma.earning.delete({
     *   where: {
     *     // ... filter to delete one Earning
     *   }
     * })
     * 
    **/
    delete<T extends EarningDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EarningDeleteArgs<ExtArgs>>
    ): Prisma__EarningClient<$Result.GetResult<Prisma.$EarningPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Earning.
     * @param {EarningUpdateArgs} args - Arguments to update one Earning.
     * @example
     * // Update one Earning
     * const earning = await prisma.earning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EarningUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EarningUpdateArgs<ExtArgs>>
    ): Prisma__EarningClient<$Result.GetResult<Prisma.$EarningPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Earnings.
     * @param {EarningDeleteManyArgs} args - Arguments to filter Earnings to delete.
     * @example
     * // Delete a few Earnings
     * const { count } = await prisma.earning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EarningDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EarningDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Earnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EarningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Earnings
     * const earning = await prisma.earning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EarningUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EarningUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Earning.
     * @param {EarningUpsertArgs} args - Arguments to update or create a Earning.
     * @example
     * // Update or create a Earning
     * const earning = await prisma.earning.upsert({
     *   create: {
     *     // ... data to create a Earning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Earning we want to update
     *   }
     * })
    **/
    upsert<T extends EarningUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EarningUpsertArgs<ExtArgs>>
    ): Prisma__EarningClient<$Result.GetResult<Prisma.$EarningPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Earnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EarningCountArgs} args - Arguments to filter Earnings to count.
     * @example
     * // Count the number of Earnings
     * const count = await prisma.earning.count({
     *   where: {
     *     // ... the filter for the Earnings we want to count
     *   }
     * })
    **/
    count<T extends EarningCountArgs>(
      args?: Subset<T, EarningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EarningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Earning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EarningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EarningAggregateArgs>(args: Subset<T, EarningAggregateArgs>): Prisma.PrismaPromise<GetEarningAggregateType<T>>

    /**
     * Group by Earning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EarningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EarningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EarningGroupByArgs['orderBy'] }
        : { orderBy?: EarningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EarningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEarningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Earning model
   */
  readonly fields: EarningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Earning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EarningClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    couriers<T extends Earning$couriersArgs<ExtArgs> = {}>(args?: Subset<T, Earning$couriersArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Earning model
   */ 
  interface EarningFieldRefs {
    readonly id: FieldRef<"Earning", 'String'>
    readonly total: FieldRef<"Earning", 'Int'>
    readonly pending: FieldRef<"Earning", 'Int'>
    readonly received: FieldRef<"Earning", 'Int'>
    readonly payoutMethod: FieldRef<"Earning", 'String'>
    readonly createdAt: FieldRef<"Earning", 'DateTime'>
    readonly updatedAt: FieldRef<"Earning", 'DateTime'>
    readonly courierId: FieldRef<"Earning", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Earning findUnique
   */
  export type EarningFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Earning
     */
    select?: EarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EarningInclude<ExtArgs> | null
    /**
     * Filter, which Earning to fetch.
     */
    where: EarningWhereUniqueInput
  }


  /**
   * Earning findUniqueOrThrow
   */
  export type EarningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Earning
     */
    select?: EarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EarningInclude<ExtArgs> | null
    /**
     * Filter, which Earning to fetch.
     */
    where: EarningWhereUniqueInput
  }


  /**
   * Earning findFirst
   */
  export type EarningFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Earning
     */
    select?: EarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EarningInclude<ExtArgs> | null
    /**
     * Filter, which Earning to fetch.
     */
    where?: EarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Earnings to fetch.
     */
    orderBy?: EarningOrderByWithRelationAndSearchRelevanceInput | EarningOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Earnings.
     */
    cursor?: EarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Earnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Earnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Earnings.
     */
    distinct?: EarningScalarFieldEnum | EarningScalarFieldEnum[]
  }


  /**
   * Earning findFirstOrThrow
   */
  export type EarningFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Earning
     */
    select?: EarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EarningInclude<ExtArgs> | null
    /**
     * Filter, which Earning to fetch.
     */
    where?: EarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Earnings to fetch.
     */
    orderBy?: EarningOrderByWithRelationAndSearchRelevanceInput | EarningOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Earnings.
     */
    cursor?: EarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Earnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Earnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Earnings.
     */
    distinct?: EarningScalarFieldEnum | EarningScalarFieldEnum[]
  }


  /**
   * Earning findMany
   */
  export type EarningFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Earning
     */
    select?: EarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EarningInclude<ExtArgs> | null
    /**
     * Filter, which Earnings to fetch.
     */
    where?: EarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Earnings to fetch.
     */
    orderBy?: EarningOrderByWithRelationAndSearchRelevanceInput | EarningOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Earnings.
     */
    cursor?: EarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Earnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Earnings.
     */
    skip?: number
    distinct?: EarningScalarFieldEnum | EarningScalarFieldEnum[]
  }


  /**
   * Earning create
   */
  export type EarningCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Earning
     */
    select?: EarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EarningInclude<ExtArgs> | null
    /**
     * The data needed to create a Earning.
     */
    data: XOR<EarningCreateInput, EarningUncheckedCreateInput>
  }


  /**
   * Earning createMany
   */
  export type EarningCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Earnings.
     */
    data: EarningCreateManyInput | EarningCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Earning update
   */
  export type EarningUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Earning
     */
    select?: EarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EarningInclude<ExtArgs> | null
    /**
     * The data needed to update a Earning.
     */
    data: XOR<EarningUpdateInput, EarningUncheckedUpdateInput>
    /**
     * Choose, which Earning to update.
     */
    where: EarningWhereUniqueInput
  }


  /**
   * Earning updateMany
   */
  export type EarningUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Earnings.
     */
    data: XOR<EarningUpdateManyMutationInput, EarningUncheckedUpdateManyInput>
    /**
     * Filter which Earnings to update
     */
    where?: EarningWhereInput
  }


  /**
   * Earning upsert
   */
  export type EarningUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Earning
     */
    select?: EarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EarningInclude<ExtArgs> | null
    /**
     * The filter to search for the Earning to update in case it exists.
     */
    where: EarningWhereUniqueInput
    /**
     * In case the Earning found by the `where` argument doesn't exist, create a new Earning with this data.
     */
    create: XOR<EarningCreateInput, EarningUncheckedCreateInput>
    /**
     * In case the Earning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EarningUpdateInput, EarningUncheckedUpdateInput>
  }


  /**
   * Earning delete
   */
  export type EarningDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Earning
     */
    select?: EarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EarningInclude<ExtArgs> | null
    /**
     * Filter which Earning to delete.
     */
    where: EarningWhereUniqueInput
  }


  /**
   * Earning deleteMany
   */
  export type EarningDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Earnings to delete
     */
    where?: EarningWhereInput
  }


  /**
   * Earning.couriers
   */
  export type Earning$couriersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    where?: CourierWhereInput
  }


  /**
   * Earning without action
   */
  export type EarningDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Earning
     */
    select?: EarningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EarningInclude<ExtArgs> | null
  }



  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type LocationSumAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    street: string | null
    zipCode: string | null
    countryCode: $Enums.EnumCountryCode | null
    stateCode: string | null
    houseNumber: string | null
    longitude: number | null
    latitude: number | null
    formattedAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    street: string | null
    zipCode: string | null
    countryCode: $Enums.EnumCountryCode | null
    stateCode: string | null
    houseNumber: string | null
    longitude: number | null
    latitude: number | null
    formattedAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    street: number
    zipCode: number
    countryCode: number
    stateCode: number
    houseNumber: number
    longitude: number
    latitude: number
    formattedAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type LocationSumAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    street?: true
    zipCode?: true
    countryCode?: true
    stateCode?: true
    houseNumber?: true
    longitude?: true
    latitude?: true
    formattedAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    street?: true
    zipCode?: true
    countryCode?: true
    stateCode?: true
    houseNumber?: true
    longitude?: true
    latitude?: true
    formattedAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    street?: true
    zipCode?: true
    countryCode?: true
    stateCode?: true
    houseNumber?: true
    longitude?: true
    latitude?: true
    formattedAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationAndSearchRelevanceInput | LocationOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    street: string | null
    zipCode: string | null
    countryCode: $Enums.EnumCountryCode
    stateCode: string | null
    houseNumber: string | null
    longitude: number
    latitude: number
    formattedAddress: string | null
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    street?: boolean
    zipCode?: boolean
    countryCode?: boolean
    stateCode?: boolean
    houseNumber?: boolean
    longitude?: boolean
    latitude?: boolean
    formattedAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locationNotes?: boolean | Location$locationNotesArgs<ExtArgs>
    pickupDelivery?: boolean | Location$pickupDeliveryArgs<ExtArgs>
    dropoffDelivery?: boolean | Location$dropoffDeliveryArgs<ExtArgs>
    pickupDeliveryQuotes?: boolean | Location$pickupDeliveryQuotesArgs<ExtArgs>
    dropoffDeliveryQuotes?: boolean | Location$dropoffDeliveryQuotesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    street?: boolean
    zipCode?: boolean
    countryCode?: boolean
    stateCode?: boolean
    houseNumber?: boolean
    longitude?: boolean
    latitude?: boolean
    formattedAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    locationNotes?: boolean | Location$locationNotesArgs<ExtArgs>
    pickupDelivery?: boolean | Location$pickupDeliveryArgs<ExtArgs>
    dropoffDelivery?: boolean | Location$dropoffDeliveryArgs<ExtArgs>
    pickupDeliveryQuotes?: boolean | Location$pickupDeliveryQuotesArgs<ExtArgs>
    dropoffDeliveryQuotes?: boolean | Location$dropoffDeliveryQuotesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LocationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      locationNotes: Prisma.$LocationNotePayload<ExtArgs>[]
      pickupDelivery: Prisma.$DeliveryPayload<ExtArgs>[]
      dropoffDelivery: Prisma.$DeliveryPayload<ExtArgs>[]
      pickupDeliveryQuotes: Prisma.$DeliveryQuotePayload<ExtArgs>[]
      dropoffDeliveryQuotes: Prisma.$DeliveryQuotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      state: string | null
      street: string | null
      zipCode: string | null
      countryCode: $Enums.EnumCountryCode
      stateCode: string | null
      houseNumber: string | null
      longitude: number
      latitude: number
      formattedAddress: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }


  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LocationFindManyArgs, 'select' | 'include'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LocationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Location that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LocationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LocationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
    **/
    create<T extends LocationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LocationCreateArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Locations.
     *     @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     *     @example
     *     // Create many Locations
     *     const location = await prisma.location.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LocationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
    **/
    delete<T extends LocationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LocationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LocationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LocationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
    **/
    upsert<T extends LocationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>
    ): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    locationNotes<T extends Location$locationNotesArgs<ExtArgs> = {}>(args?: Subset<T, Location$locationNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNotePayload<ExtArgs>, T, 'findMany'> | Null>;

    pickupDelivery<T extends Location$pickupDeliveryArgs<ExtArgs> = {}>(args?: Subset<T, Location$pickupDeliveryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'findMany'> | Null>;

    dropoffDelivery<T extends Location$dropoffDeliveryArgs<ExtArgs> = {}>(args?: Subset<T, Location$dropoffDeliveryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'findMany'> | Null>;

    pickupDeliveryQuotes<T extends Location$pickupDeliveryQuotesArgs<ExtArgs> = {}>(args?: Subset<T, Location$pickupDeliveryQuotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryQuotePayload<ExtArgs>, T, 'findMany'> | Null>;

    dropoffDeliveryQuotes<T extends Location$dropoffDeliveryQuotesArgs<ExtArgs> = {}>(args?: Subset<T, Location$dropoffDeliveryQuotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryQuotePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly addressLine1: FieldRef<"Location", 'String'>
    readonly addressLine2: FieldRef<"Location", 'String'>
    readonly city: FieldRef<"Location", 'String'>
    readonly state: FieldRef<"Location", 'String'>
    readonly street: FieldRef<"Location", 'String'>
    readonly zipCode: FieldRef<"Location", 'String'>
    readonly countryCode: FieldRef<"Location", 'EnumCountryCode'>
    readonly stateCode: FieldRef<"Location", 'String'>
    readonly houseNumber: FieldRef<"Location", 'String'>
    readonly longitude: FieldRef<"Location", 'Float'>
    readonly latitude: FieldRef<"Location", 'Float'>
    readonly formattedAddress: FieldRef<"Location", 'String'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }


  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }


  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationAndSearchRelevanceInput | LocationOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }


  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationAndSearchRelevanceInput | LocationOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }


  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationAndSearchRelevanceInput | LocationOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }


  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }


  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }


  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }


  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }


  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }


  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
  }


  /**
   * Location.locationNotes
   */
  export type Location$locationNotesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNote
     */
    select?: LocationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteInclude<ExtArgs> | null
    where?: LocationNoteWhereInput
    orderBy?: LocationNoteOrderByWithRelationAndSearchRelevanceInput | LocationNoteOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: LocationNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationNoteScalarFieldEnum | LocationNoteScalarFieldEnum[]
  }


  /**
   * Location.pickupDelivery
   */
  export type Location$pickupDeliveryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationAndSearchRelevanceInput | DeliveryOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }


  /**
   * Location.dropoffDelivery
   */
  export type Location$dropoffDeliveryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationAndSearchRelevanceInput | DeliveryOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }


  /**
   * Location.pickupDeliveryQuotes
   */
  export type Location$pickupDeliveryQuotesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuote
     */
    select?: DeliveryQuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryQuoteInclude<ExtArgs> | null
    where?: DeliveryQuoteWhereInput
    orderBy?: DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput | DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: DeliveryQuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryQuoteScalarFieldEnum | DeliveryQuoteScalarFieldEnum[]
  }


  /**
   * Location.dropoffDeliveryQuotes
   */
  export type Location$dropoffDeliveryQuotesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuote
     */
    select?: DeliveryQuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryQuoteInclude<ExtArgs> | null
    where?: DeliveryQuoteWhereInput
    orderBy?: DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput | DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: DeliveryQuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryQuoteScalarFieldEnum | DeliveryQuoteScalarFieldEnum[]
  }


  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
  }



  /**
   * Model Partner
   */

  export type AggregatePartner = {
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  export type PartnerMinAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    phoneNumber: string | null
    webhookUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type PartnerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    phoneNumber: string | null
    webhookUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type PartnerCountAggregateOutputType = {
    id: number
    name: number
    logo: number
    phoneNumber: number
    webhookUrl: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type PartnerMinAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    phoneNumber?: true
    webhookUrl?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type PartnerMaxAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    phoneNumber?: true
    webhookUrl?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type PartnerCountAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    phoneNumber?: true
    webhookUrl?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type PartnerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partner to aggregate.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationAndSearchRelevanceInput | PartnerOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Partners
    **/
    _count?: true | PartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerMaxAggregateInputType
  }

  export type GetPartnerAggregateType<T extends PartnerAggregateArgs> = {
        [P in keyof T & keyof AggregatePartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartner[P]>
      : GetScalarType<T[P], AggregatePartner[P]>
  }




  export type PartnerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PartnerWhereInput
    orderBy?: PartnerOrderByWithAggregationInput | PartnerOrderByWithAggregationInput[]
    by: PartnerScalarFieldEnum[] | PartnerScalarFieldEnum
    having?: PartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerCountAggregateInputType | true
    _min?: PartnerMinAggregateInputType
    _max?: PartnerMaxAggregateInputType
  }

  export type PartnerGroupByOutputType = {
    id: string
    name: string
    logo: string | null
    phoneNumber: string | null
    webhookUrl: string | null
    createdAt: Date
    updatedAt: Date
    userId: string | null
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  type GetPartnerGroupByPayload<T extends PartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerGroupByOutputType[P]>
        }
      >
    >


  export type PartnerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    phoneNumber?: boolean
    webhookUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    deliveries?: boolean | Partner$deliveriesArgs<ExtArgs>
    deliveryQuotes?: boolean | Partner$deliveryQuotesArgs<ExtArgs>
    user?: boolean | Partner$userArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectScalar = {
    id?: boolean
    name?: boolean
    logo?: boolean
    phoneNumber?: boolean
    webhookUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type PartnerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    deliveries?: boolean | Partner$deliveriesArgs<ExtArgs>
    deliveryQuotes?: boolean | Partner$deliveryQuotesArgs<ExtArgs>
    user?: boolean | Partner$userArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PartnerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Partner"
    objects: {
      deliveries: Prisma.$DeliveryPayload<ExtArgs>[]
      deliveryQuotes: Prisma.$DeliveryQuotePayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      name: string
      logo: string | null
      phoneNumber: string | null
      webhookUrl: string | null
      createdAt: Date
      updatedAt: Date
      userId: string | null
    }, ExtArgs["result"]["partner"]>
    composites: {}
  }


  type PartnerGetPayload<S extends boolean | null | undefined | PartnerDefaultArgs> = $Result.GetResult<Prisma.$PartnerPayload, S>

  type PartnerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PartnerFindManyArgs, 'select' | 'include'> & {
      select?: PartnerCountAggregateInputType | true
    }

  export interface PartnerDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Partner'], meta: { name: 'Partner' } }
    /**
     * Find zero or one Partner that matches the filter.
     * @param {PartnerFindUniqueArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PartnerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PartnerFindUniqueArgs<ExtArgs>>
    ): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Partner that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PartnerFindUniqueOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PartnerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartnerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Partner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PartnerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PartnerFindFirstArgs<ExtArgs>>
    ): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Partner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PartnerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartnerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partners
     * const partners = await prisma.partner.findMany()
     * 
     * // Get first 10 Partners
     * const partners = await prisma.partner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerWithIdOnly = await prisma.partner.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PartnerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartnerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Partner.
     * @param {PartnerCreateArgs} args - Arguments to create a Partner.
     * @example
     * // Create one Partner
     * const Partner = await prisma.partner.create({
     *   data: {
     *     // ... data to create a Partner
     *   }
     * })
     * 
    **/
    create<T extends PartnerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PartnerCreateArgs<ExtArgs>>
    ): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Partners.
     *     @param {PartnerCreateManyArgs} args - Arguments to create many Partners.
     *     @example
     *     // Create many Partners
     *     const partner = await prisma.partner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PartnerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartnerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Partner.
     * @param {PartnerDeleteArgs} args - Arguments to delete one Partner.
     * @example
     * // Delete one Partner
     * const Partner = await prisma.partner.delete({
     *   where: {
     *     // ... filter to delete one Partner
     *   }
     * })
     * 
    **/
    delete<T extends PartnerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PartnerDeleteArgs<ExtArgs>>
    ): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Partner.
     * @param {PartnerUpdateArgs} args - Arguments to update one Partner.
     * @example
     * // Update one Partner
     * const partner = await prisma.partner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PartnerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PartnerUpdateArgs<ExtArgs>>
    ): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Partners.
     * @param {PartnerDeleteManyArgs} args - Arguments to filter Partners to delete.
     * @example
     * // Delete a few Partners
     * const { count } = await prisma.partner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PartnerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartnerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PartnerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PartnerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Partner.
     * @param {PartnerUpsertArgs} args - Arguments to update or create a Partner.
     * @example
     * // Update or create a Partner
     * const partner = await prisma.partner.upsert({
     *   create: {
     *     // ... data to create a Partner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partner we want to update
     *   }
     * })
    **/
    upsert<T extends PartnerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PartnerUpsertArgs<ExtArgs>>
    ): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCountArgs} args - Arguments to filter Partners to count.
     * @example
     * // Count the number of Partners
     * const count = await prisma.partner.count({
     *   where: {
     *     // ... the filter for the Partners we want to count
     *   }
     * })
    **/
    count<T extends PartnerCountArgs>(
      args?: Subset<T, PartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerAggregateArgs>(args: Subset<T, PartnerAggregateArgs>): Prisma.PrismaPromise<GetPartnerAggregateType<T>>

    /**
     * Group by Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerGroupByArgs['orderBy'] }
        : { orderBy?: PartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Partner model
   */
  readonly fields: PartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Partner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    deliveries<T extends Partner$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Partner$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'findMany'> | Null>;

    deliveryQuotes<T extends Partner$deliveryQuotesArgs<ExtArgs> = {}>(args?: Subset<T, Partner$deliveryQuotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryQuotePayload<ExtArgs>, T, 'findMany'> | Null>;

    user<T extends Partner$userArgs<ExtArgs> = {}>(args?: Subset<T, Partner$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Partner model
   */ 
  interface PartnerFieldRefs {
    readonly id: FieldRef<"Partner", 'String'>
    readonly name: FieldRef<"Partner", 'String'>
    readonly logo: FieldRef<"Partner", 'String'>
    readonly phoneNumber: FieldRef<"Partner", 'String'>
    readonly webhookUrl: FieldRef<"Partner", 'String'>
    readonly createdAt: FieldRef<"Partner", 'DateTime'>
    readonly updatedAt: FieldRef<"Partner", 'DateTime'>
    readonly userId: FieldRef<"Partner", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Partner findUnique
   */
  export type PartnerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }


  /**
   * Partner findUniqueOrThrow
   */
  export type PartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }


  /**
   * Partner findFirst
   */
  export type PartnerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationAndSearchRelevanceInput | PartnerOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }


  /**
   * Partner findFirstOrThrow
   */
  export type PartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationAndSearchRelevanceInput | PartnerOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }


  /**
   * Partner findMany
   */
  export type PartnerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationAndSearchRelevanceInput | PartnerOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }


  /**
   * Partner create
   */
  export type PartnerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Partner.
     */
    data: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
  }


  /**
   * Partner createMany
   */
  export type PartnerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Partner update
   */
  export type PartnerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Partner.
     */
    data: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
    /**
     * Choose, which Partner to update.
     */
    where: PartnerWhereUniqueInput
  }


  /**
   * Partner updateMany
   */
  export type PartnerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
  }


  /**
   * Partner upsert
   */
  export type PartnerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Partner to update in case it exists.
     */
    where: PartnerWhereUniqueInput
    /**
     * In case the Partner found by the `where` argument doesn't exist, create a new Partner with this data.
     */
    create: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
    /**
     * In case the Partner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
  }


  /**
   * Partner delete
   */
  export type PartnerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter which Partner to delete.
     */
    where: PartnerWhereUniqueInput
  }


  /**
   * Partner deleteMany
   */
  export type PartnerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partners to delete
     */
    where?: PartnerWhereInput
  }


  /**
   * Partner.deliveries
   */
  export type Partner$deliveriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationAndSearchRelevanceInput | DeliveryOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }


  /**
   * Partner.deliveryQuotes
   */
  export type Partner$deliveryQuotesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuote
     */
    select?: DeliveryQuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryQuoteInclude<ExtArgs> | null
    where?: DeliveryQuoteWhereInput
    orderBy?: DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput | DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: DeliveryQuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryQuoteScalarFieldEnum | DeliveryQuoteScalarFieldEnum[]
  }


  /**
   * Partner.user
   */
  export type Partner$userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Partner without action
   */
  export type PartnerDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartnerInclude<ExtArgs> | null
  }



  /**
   * Model DeliveryQuote
   */

  export type AggregateDeliveryQuote = {
    _count: DeliveryQuoteCountAggregateOutputType | null
    _avg: DeliveryQuoteAvgAggregateOutputType | null
    _sum: DeliveryQuoteSumAggregateOutputType | null
    _min: DeliveryQuoteMinAggregateOutputType | null
    _max: DeliveryQuoteMaxAggregateOutputType | null
  }

  export type DeliveryQuoteAvgAggregateOutputType = {
    quote: number | null
    quoteRangeFrom: number | null
    quoteRangeTo: number | null
    feePercentage: number | null
    duration: number | null
    distance: number | null
    orderTotalValue: number | null
  }

  export type DeliveryQuoteSumAggregateOutputType = {
    quote: number | null
    quoteRangeFrom: number | null
    quoteRangeTo: number | null
    feePercentage: number | null
    duration: number | null
    distance: number | null
    orderTotalValue: number | null
  }

  export type DeliveryQuoteMinAggregateOutputType = {
    id: string | null
    quote: number | null
    quoteRangeFrom: number | null
    quoteRangeTo: number | null
    feePercentage: number | null
    currency: string | null
    duration: number | null
    distance: number | null
    distanceUnit: $Enums.EnumDistanceUnit | null
    pickupPhoneNumber: string | null
    pickupName: string | null
    dropoffPhoneNumber: string | null
    dropoffName: string | null
    expiresAt: Date | null
    pickupReadyAt: Date | null
    pickupDeadlineAt: Date | null
    dropoffReadyAt: Date | null
    dropoffEta: Date | null
    dropoffDeadlineAt: Date | null
    orderTotalValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
    pickupLocationId: string | null
    dropoffLocationId: string | null
    partnerId: string | null
    deliveryId: string | null
  }

  export type DeliveryQuoteMaxAggregateOutputType = {
    id: string | null
    quote: number | null
    quoteRangeFrom: number | null
    quoteRangeTo: number | null
    feePercentage: number | null
    currency: string | null
    duration: number | null
    distance: number | null
    distanceUnit: $Enums.EnumDistanceUnit | null
    pickupPhoneNumber: string | null
    pickupName: string | null
    dropoffPhoneNumber: string | null
    dropoffName: string | null
    expiresAt: Date | null
    pickupReadyAt: Date | null
    pickupDeadlineAt: Date | null
    dropoffReadyAt: Date | null
    dropoffEta: Date | null
    dropoffDeadlineAt: Date | null
    orderTotalValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
    pickupLocationId: string | null
    dropoffLocationId: string | null
    partnerId: string | null
    deliveryId: string | null
  }

  export type DeliveryQuoteCountAggregateOutputType = {
    id: number
    quote: number
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage: number
    currency: number
    duration: number
    distance: number
    distanceUnit: number
    pickupPhoneNumber: number
    pickupName: number
    dropoffPhoneNumber: number
    dropoffName: number
    expiresAt: number
    pickupReadyAt: number
    pickupDeadlineAt: number
    dropoffReadyAt: number
    dropoffEta: number
    dropoffDeadlineAt: number
    orderTotalValue: number
    createdAt: number
    updatedAt: number
    pickupLocationId: number
    dropoffLocationId: number
    partnerId: number
    deliveryId: number
    _all: number
  }


  export type DeliveryQuoteAvgAggregateInputType = {
    quote?: true
    quoteRangeFrom?: true
    quoteRangeTo?: true
    feePercentage?: true
    duration?: true
    distance?: true
    orderTotalValue?: true
  }

  export type DeliveryQuoteSumAggregateInputType = {
    quote?: true
    quoteRangeFrom?: true
    quoteRangeTo?: true
    feePercentage?: true
    duration?: true
    distance?: true
    orderTotalValue?: true
  }

  export type DeliveryQuoteMinAggregateInputType = {
    id?: true
    quote?: true
    quoteRangeFrom?: true
    quoteRangeTo?: true
    feePercentage?: true
    currency?: true
    duration?: true
    distance?: true
    distanceUnit?: true
    pickupPhoneNumber?: true
    pickupName?: true
    dropoffPhoneNumber?: true
    dropoffName?: true
    expiresAt?: true
    pickupReadyAt?: true
    pickupDeadlineAt?: true
    dropoffReadyAt?: true
    dropoffEta?: true
    dropoffDeadlineAt?: true
    orderTotalValue?: true
    createdAt?: true
    updatedAt?: true
    pickupLocationId?: true
    dropoffLocationId?: true
    partnerId?: true
    deliveryId?: true
  }

  export type DeliveryQuoteMaxAggregateInputType = {
    id?: true
    quote?: true
    quoteRangeFrom?: true
    quoteRangeTo?: true
    feePercentage?: true
    currency?: true
    duration?: true
    distance?: true
    distanceUnit?: true
    pickupPhoneNumber?: true
    pickupName?: true
    dropoffPhoneNumber?: true
    dropoffName?: true
    expiresAt?: true
    pickupReadyAt?: true
    pickupDeadlineAt?: true
    dropoffReadyAt?: true
    dropoffEta?: true
    dropoffDeadlineAt?: true
    orderTotalValue?: true
    createdAt?: true
    updatedAt?: true
    pickupLocationId?: true
    dropoffLocationId?: true
    partnerId?: true
    deliveryId?: true
  }

  export type DeliveryQuoteCountAggregateInputType = {
    id?: true
    quote?: true
    quoteRangeFrom?: true
    quoteRangeTo?: true
    feePercentage?: true
    currency?: true
    duration?: true
    distance?: true
    distanceUnit?: true
    pickupPhoneNumber?: true
    pickupName?: true
    dropoffPhoneNumber?: true
    dropoffName?: true
    expiresAt?: true
    pickupReadyAt?: true
    pickupDeadlineAt?: true
    dropoffReadyAt?: true
    dropoffEta?: true
    dropoffDeadlineAt?: true
    orderTotalValue?: true
    createdAt?: true
    updatedAt?: true
    pickupLocationId?: true
    dropoffLocationId?: true
    partnerId?: true
    deliveryId?: true
    _all?: true
  }

  export type DeliveryQuoteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryQuote to aggregate.
     */
    where?: DeliveryQuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryQuotes to fetch.
     */
    orderBy?: DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput | DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryQuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryQuotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryQuotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryQuotes
    **/
    _count?: true | DeliveryQuoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryQuoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryQuoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryQuoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryQuoteMaxAggregateInputType
  }

  export type GetDeliveryQuoteAggregateType<T extends DeliveryQuoteAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryQuote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryQuote[P]>
      : GetScalarType<T[P], AggregateDeliveryQuote[P]>
  }




  export type DeliveryQuoteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DeliveryQuoteWhereInput
    orderBy?: DeliveryQuoteOrderByWithAggregationInput | DeliveryQuoteOrderByWithAggregationInput[]
    by: DeliveryQuoteScalarFieldEnum[] | DeliveryQuoteScalarFieldEnum
    having?: DeliveryQuoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryQuoteCountAggregateInputType | true
    _avg?: DeliveryQuoteAvgAggregateInputType
    _sum?: DeliveryQuoteSumAggregateInputType
    _min?: DeliveryQuoteMinAggregateInputType
    _max?: DeliveryQuoteMaxAggregateInputType
  }

  export type DeliveryQuoteGroupByOutputType = {
    id: string
    quote: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage: number
    currency: string
    duration: number
    distance: number
    distanceUnit: $Enums.EnumDistanceUnit
    pickupPhoneNumber: string | null
    pickupName: string | null
    dropoffPhoneNumber: string | null
    dropoffName: string | null
    expiresAt: Date | null
    pickupReadyAt: Date | null
    pickupDeadlineAt: Date | null
    dropoffReadyAt: Date | null
    dropoffEta: Date | null
    dropoffDeadlineAt: Date | null
    orderTotalValue: number
    createdAt: Date
    updatedAt: Date
    pickupLocationId: string
    dropoffLocationId: string
    partnerId: string | null
    deliveryId: string | null
    _count: DeliveryQuoteCountAggregateOutputType | null
    _avg: DeliveryQuoteAvgAggregateOutputType | null
    _sum: DeliveryQuoteSumAggregateOutputType | null
    _min: DeliveryQuoteMinAggregateOutputType | null
    _max: DeliveryQuoteMaxAggregateOutputType | null
  }

  type GetDeliveryQuoteGroupByPayload<T extends DeliveryQuoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryQuoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryQuoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryQuoteGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryQuoteGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryQuoteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quote?: boolean
    quoteRangeFrom?: boolean
    quoteRangeTo?: boolean
    feePercentage?: boolean
    currency?: boolean
    duration?: boolean
    distance?: boolean
    distanceUnit?: boolean
    pickupPhoneNumber?: boolean
    pickupName?: boolean
    dropoffPhoneNumber?: boolean
    dropoffName?: boolean
    expiresAt?: boolean
    pickupReadyAt?: boolean
    pickupDeadlineAt?: boolean
    dropoffReadyAt?: boolean
    dropoffEta?: boolean
    dropoffDeadlineAt?: boolean
    orderTotalValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pickupLocationId?: boolean
    dropoffLocationId?: boolean
    partnerId?: boolean
    deliveryId?: boolean
    pickupLocation?: boolean | LocationDefaultArgs<ExtArgs>
    dropoffLocation?: boolean | LocationDefaultArgs<ExtArgs>
    partners?: boolean | DeliveryQuote$partnersArgs<ExtArgs>
    Delivery?: boolean | DeliveryQuote$DeliveryArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryQuote"]>

  export type DeliveryQuoteSelectScalar = {
    id?: boolean
    quote?: boolean
    quoteRangeFrom?: boolean
    quoteRangeTo?: boolean
    feePercentage?: boolean
    currency?: boolean
    duration?: boolean
    distance?: boolean
    distanceUnit?: boolean
    pickupPhoneNumber?: boolean
    pickupName?: boolean
    dropoffPhoneNumber?: boolean
    dropoffName?: boolean
    expiresAt?: boolean
    pickupReadyAt?: boolean
    pickupDeadlineAt?: boolean
    dropoffReadyAt?: boolean
    dropoffEta?: boolean
    dropoffDeadlineAt?: boolean
    orderTotalValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pickupLocationId?: boolean
    dropoffLocationId?: boolean
    partnerId?: boolean
    deliveryId?: boolean
  }

  export type DeliveryQuoteInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pickupLocation?: boolean | LocationDefaultArgs<ExtArgs>
    dropoffLocation?: boolean | LocationDefaultArgs<ExtArgs>
    partners?: boolean | DeliveryQuote$partnersArgs<ExtArgs>
    Delivery?: boolean | DeliveryQuote$DeliveryArgs<ExtArgs>
  }


  export type $DeliveryQuotePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "DeliveryQuote"
    objects: {
      pickupLocation: Prisma.$LocationPayload<ExtArgs>
      dropoffLocation: Prisma.$LocationPayload<ExtArgs>
      partners: Prisma.$PartnerPayload<ExtArgs> | null
      Delivery: Prisma.$DeliveryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      quote: number | null
      quoteRangeFrom: number
      quoteRangeTo: number
      feePercentage: number
      currency: string
      duration: number
      distance: number
      distanceUnit: $Enums.EnumDistanceUnit
      pickupPhoneNumber: string | null
      pickupName: string | null
      dropoffPhoneNumber: string | null
      dropoffName: string | null
      expiresAt: Date | null
      pickupReadyAt: Date | null
      pickupDeadlineAt: Date | null
      dropoffReadyAt: Date | null
      dropoffEta: Date | null
      dropoffDeadlineAt: Date | null
      orderTotalValue: number
      createdAt: Date
      updatedAt: Date
      pickupLocationId: string
      dropoffLocationId: string
      partnerId: string | null
      deliveryId: string | null
    }, ExtArgs["result"]["deliveryQuote"]>
    composites: {}
  }


  type DeliveryQuoteGetPayload<S extends boolean | null | undefined | DeliveryQuoteDefaultArgs> = $Result.GetResult<Prisma.$DeliveryQuotePayload, S>

  type DeliveryQuoteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DeliveryQuoteFindManyArgs, 'select' | 'include'> & {
      select?: DeliveryQuoteCountAggregateInputType | true
    }

  export interface DeliveryQuoteDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryQuote'], meta: { name: 'DeliveryQuote' } }
    /**
     * Find zero or one DeliveryQuote that matches the filter.
     * @param {DeliveryQuoteFindUniqueArgs} args - Arguments to find a DeliveryQuote
     * @example
     * // Get one DeliveryQuote
     * const deliveryQuote = await prisma.deliveryQuote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeliveryQuoteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryQuoteFindUniqueArgs<ExtArgs>>
    ): Prisma__DeliveryQuoteClient<$Result.GetResult<Prisma.$DeliveryQuotePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DeliveryQuote that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DeliveryQuoteFindUniqueOrThrowArgs} args - Arguments to find a DeliveryQuote
     * @example
     * // Get one DeliveryQuote
     * const deliveryQuote = await prisma.deliveryQuote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeliveryQuoteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryQuoteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DeliveryQuoteClient<$Result.GetResult<Prisma.$DeliveryQuotePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DeliveryQuote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryQuoteFindFirstArgs} args - Arguments to find a DeliveryQuote
     * @example
     * // Get one DeliveryQuote
     * const deliveryQuote = await prisma.deliveryQuote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeliveryQuoteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryQuoteFindFirstArgs<ExtArgs>>
    ): Prisma__DeliveryQuoteClient<$Result.GetResult<Prisma.$DeliveryQuotePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DeliveryQuote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryQuoteFindFirstOrThrowArgs} args - Arguments to find a DeliveryQuote
     * @example
     * // Get one DeliveryQuote
     * const deliveryQuote = await prisma.deliveryQuote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeliveryQuoteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryQuoteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DeliveryQuoteClient<$Result.GetResult<Prisma.$DeliveryQuotePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DeliveryQuotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryQuoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryQuotes
     * const deliveryQuotes = await prisma.deliveryQuote.findMany()
     * 
     * // Get first 10 DeliveryQuotes
     * const deliveryQuotes = await prisma.deliveryQuote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryQuoteWithIdOnly = await prisma.deliveryQuote.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeliveryQuoteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryQuoteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryQuotePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DeliveryQuote.
     * @param {DeliveryQuoteCreateArgs} args - Arguments to create a DeliveryQuote.
     * @example
     * // Create one DeliveryQuote
     * const DeliveryQuote = await prisma.deliveryQuote.create({
     *   data: {
     *     // ... data to create a DeliveryQuote
     *   }
     * })
     * 
    **/
    create<T extends DeliveryQuoteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryQuoteCreateArgs<ExtArgs>>
    ): Prisma__DeliveryQuoteClient<$Result.GetResult<Prisma.$DeliveryQuotePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DeliveryQuotes.
     *     @param {DeliveryQuoteCreateManyArgs} args - Arguments to create many DeliveryQuotes.
     *     @example
     *     // Create many DeliveryQuotes
     *     const deliveryQuote = await prisma.deliveryQuote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeliveryQuoteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryQuoteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeliveryQuote.
     * @param {DeliveryQuoteDeleteArgs} args - Arguments to delete one DeliveryQuote.
     * @example
     * // Delete one DeliveryQuote
     * const DeliveryQuote = await prisma.deliveryQuote.delete({
     *   where: {
     *     // ... filter to delete one DeliveryQuote
     *   }
     * })
     * 
    **/
    delete<T extends DeliveryQuoteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryQuoteDeleteArgs<ExtArgs>>
    ): Prisma__DeliveryQuoteClient<$Result.GetResult<Prisma.$DeliveryQuotePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DeliveryQuote.
     * @param {DeliveryQuoteUpdateArgs} args - Arguments to update one DeliveryQuote.
     * @example
     * // Update one DeliveryQuote
     * const deliveryQuote = await prisma.deliveryQuote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeliveryQuoteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryQuoteUpdateArgs<ExtArgs>>
    ): Prisma__DeliveryQuoteClient<$Result.GetResult<Prisma.$DeliveryQuotePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DeliveryQuotes.
     * @param {DeliveryQuoteDeleteManyArgs} args - Arguments to filter DeliveryQuotes to delete.
     * @example
     * // Delete a few DeliveryQuotes
     * const { count } = await prisma.deliveryQuote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeliveryQuoteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryQuoteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryQuotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryQuoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryQuotes
     * const deliveryQuote = await prisma.deliveryQuote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeliveryQuoteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryQuoteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeliveryQuote.
     * @param {DeliveryQuoteUpsertArgs} args - Arguments to update or create a DeliveryQuote.
     * @example
     * // Update or create a DeliveryQuote
     * const deliveryQuote = await prisma.deliveryQuote.upsert({
     *   create: {
     *     // ... data to create a DeliveryQuote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryQuote we want to update
     *   }
     * })
    **/
    upsert<T extends DeliveryQuoteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryQuoteUpsertArgs<ExtArgs>>
    ): Prisma__DeliveryQuoteClient<$Result.GetResult<Prisma.$DeliveryQuotePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DeliveryQuotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryQuoteCountArgs} args - Arguments to filter DeliveryQuotes to count.
     * @example
     * // Count the number of DeliveryQuotes
     * const count = await prisma.deliveryQuote.count({
     *   where: {
     *     // ... the filter for the DeliveryQuotes we want to count
     *   }
     * })
    **/
    count<T extends DeliveryQuoteCountArgs>(
      args?: Subset<T, DeliveryQuoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryQuoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryQuote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryQuoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryQuoteAggregateArgs>(args: Subset<T, DeliveryQuoteAggregateArgs>): Prisma.PrismaPromise<GetDeliveryQuoteAggregateType<T>>

    /**
     * Group by DeliveryQuote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryQuoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryQuoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryQuoteGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryQuoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryQuoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryQuoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryQuote model
   */
  readonly fields: DeliveryQuoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryQuote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryQuoteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pickupLocation<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    dropoffLocation<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    partners<T extends DeliveryQuote$partnersArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryQuote$partnersArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Delivery<T extends DeliveryQuote$DeliveryArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryQuote$DeliveryArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DeliveryQuote model
   */ 
  interface DeliveryQuoteFieldRefs {
    readonly id: FieldRef<"DeliveryQuote", 'String'>
    readonly quote: FieldRef<"DeliveryQuote", 'Float'>
    readonly quoteRangeFrom: FieldRef<"DeliveryQuote", 'Float'>
    readonly quoteRangeTo: FieldRef<"DeliveryQuote", 'Float'>
    readonly feePercentage: FieldRef<"DeliveryQuote", 'Float'>
    readonly currency: FieldRef<"DeliveryQuote", 'String'>
    readonly duration: FieldRef<"DeliveryQuote", 'Int'>
    readonly distance: FieldRef<"DeliveryQuote", 'Float'>
    readonly distanceUnit: FieldRef<"DeliveryQuote", 'EnumDistanceUnit'>
    readonly pickupPhoneNumber: FieldRef<"DeliveryQuote", 'String'>
    readonly pickupName: FieldRef<"DeliveryQuote", 'String'>
    readonly dropoffPhoneNumber: FieldRef<"DeliveryQuote", 'String'>
    readonly dropoffName: FieldRef<"DeliveryQuote", 'String'>
    readonly expiresAt: FieldRef<"DeliveryQuote", 'DateTime'>
    readonly pickupReadyAt: FieldRef<"DeliveryQuote", 'DateTime'>
    readonly pickupDeadlineAt: FieldRef<"DeliveryQuote", 'DateTime'>
    readonly dropoffReadyAt: FieldRef<"DeliveryQuote", 'DateTime'>
    readonly dropoffEta: FieldRef<"DeliveryQuote", 'DateTime'>
    readonly dropoffDeadlineAt: FieldRef<"DeliveryQuote", 'DateTime'>
    readonly orderTotalValue: FieldRef<"DeliveryQuote", 'Float'>
    readonly createdAt: FieldRef<"DeliveryQuote", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliveryQuote", 'DateTime'>
    readonly pickupLocationId: FieldRef<"DeliveryQuote", 'String'>
    readonly dropoffLocationId: FieldRef<"DeliveryQuote", 'String'>
    readonly partnerId: FieldRef<"DeliveryQuote", 'String'>
    readonly deliveryId: FieldRef<"DeliveryQuote", 'String'>
  }
    

  // Custom InputTypes

  /**
   * DeliveryQuote findUnique
   */
  export type DeliveryQuoteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuote
     */
    select?: DeliveryQuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryQuoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryQuote to fetch.
     */
    where: DeliveryQuoteWhereUniqueInput
  }


  /**
   * DeliveryQuote findUniqueOrThrow
   */
  export type DeliveryQuoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuote
     */
    select?: DeliveryQuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryQuoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryQuote to fetch.
     */
    where: DeliveryQuoteWhereUniqueInput
  }


  /**
   * DeliveryQuote findFirst
   */
  export type DeliveryQuoteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuote
     */
    select?: DeliveryQuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryQuoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryQuote to fetch.
     */
    where?: DeliveryQuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryQuotes to fetch.
     */
    orderBy?: DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput | DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryQuotes.
     */
    cursor?: DeliveryQuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryQuotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryQuotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryQuotes.
     */
    distinct?: DeliveryQuoteScalarFieldEnum | DeliveryQuoteScalarFieldEnum[]
  }


  /**
   * DeliveryQuote findFirstOrThrow
   */
  export type DeliveryQuoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuote
     */
    select?: DeliveryQuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryQuoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryQuote to fetch.
     */
    where?: DeliveryQuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryQuotes to fetch.
     */
    orderBy?: DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput | DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryQuotes.
     */
    cursor?: DeliveryQuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryQuotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryQuotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryQuotes.
     */
    distinct?: DeliveryQuoteScalarFieldEnum | DeliveryQuoteScalarFieldEnum[]
  }


  /**
   * DeliveryQuote findMany
   */
  export type DeliveryQuoteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuote
     */
    select?: DeliveryQuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryQuoteInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryQuotes to fetch.
     */
    where?: DeliveryQuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryQuotes to fetch.
     */
    orderBy?: DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput | DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryQuotes.
     */
    cursor?: DeliveryQuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryQuotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryQuotes.
     */
    skip?: number
    distinct?: DeliveryQuoteScalarFieldEnum | DeliveryQuoteScalarFieldEnum[]
  }


  /**
   * DeliveryQuote create
   */
  export type DeliveryQuoteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuote
     */
    select?: DeliveryQuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryQuoteInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryQuote.
     */
    data: XOR<DeliveryQuoteCreateInput, DeliveryQuoteUncheckedCreateInput>
  }


  /**
   * DeliveryQuote createMany
   */
  export type DeliveryQuoteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryQuotes.
     */
    data: DeliveryQuoteCreateManyInput | DeliveryQuoteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DeliveryQuote update
   */
  export type DeliveryQuoteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuote
     */
    select?: DeliveryQuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryQuoteInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryQuote.
     */
    data: XOR<DeliveryQuoteUpdateInput, DeliveryQuoteUncheckedUpdateInput>
    /**
     * Choose, which DeliveryQuote to update.
     */
    where: DeliveryQuoteWhereUniqueInput
  }


  /**
   * DeliveryQuote updateMany
   */
  export type DeliveryQuoteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryQuotes.
     */
    data: XOR<DeliveryQuoteUpdateManyMutationInput, DeliveryQuoteUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryQuotes to update
     */
    where?: DeliveryQuoteWhereInput
  }


  /**
   * DeliveryQuote upsert
   */
  export type DeliveryQuoteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuote
     */
    select?: DeliveryQuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryQuoteInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryQuote to update in case it exists.
     */
    where: DeliveryQuoteWhereUniqueInput
    /**
     * In case the DeliveryQuote found by the `where` argument doesn't exist, create a new DeliveryQuote with this data.
     */
    create: XOR<DeliveryQuoteCreateInput, DeliveryQuoteUncheckedCreateInput>
    /**
     * In case the DeliveryQuote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryQuoteUpdateInput, DeliveryQuoteUncheckedUpdateInput>
  }


  /**
   * DeliveryQuote delete
   */
  export type DeliveryQuoteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuote
     */
    select?: DeliveryQuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryQuoteInclude<ExtArgs> | null
    /**
     * Filter which DeliveryQuote to delete.
     */
    where: DeliveryQuoteWhereUniqueInput
  }


  /**
   * DeliveryQuote deleteMany
   */
  export type DeliveryQuoteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryQuotes to delete
     */
    where?: DeliveryQuoteWhereInput
  }


  /**
   * DeliveryQuote.partners
   */
  export type DeliveryQuote$partnersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
  }


  /**
   * DeliveryQuote.Delivery
   */
  export type DeliveryQuote$DeliveryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
  }


  /**
   * DeliveryQuote without action
   */
  export type DeliveryQuoteDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuote
     */
    select?: DeliveryQuoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryQuoteInclude<ExtArgs> | null
  }



  /**
   * Model Delivery
   */

  export type AggregateDelivery = {
    _count: DeliveryCountAggregateOutputType | null
    _avg: DeliveryAvgAggregateOutputType | null
    _sum: DeliverySumAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  export type DeliveryAvgAggregateOutputType = {
    orderTotalValue: number | null
    totalCost: number | null
    fee: number | null
    feePercentage: number | null
    pay: number | null
    tips: number | null
    totalCompensation: number | null
  }

  export type DeliverySumAggregateOutputType = {
    orderTotalValue: number | null
    totalCost: number | null
    fee: number | null
    feePercentage: number | null
    pay: number | null
    tips: number | null
    totalCompensation: number | null
  }

  export type DeliveryMinAggregateOutputType = {
    id: string | null
    pickupName: string | null
    pickupPhoneNumber: string | null
    pickupBusinessName: string | null
    pickupNotes: string | null
    pickupLocationId: string | null
    pickupReadyAt: Date | null
    pickupDeadlineAt: Date | null
    dropoffName: string | null
    dropoffPhoneNumber: string | null
    dropoffBusinessName: string | null
    dropoffNotes: string | null
    dropoffSellerNotes: string | null
    dropoffReadyAt: Date | null
    dropoffEta: Date | null
    dropoffDeadlineAt: Date | null
    deliverableAction: $Enums.EnumDeliverableAction | null
    undeliverableAction: $Enums.EnumUndeliverableAction | null
    undeliverableReason: string | null
    dropoffLocationId: string | null
    requiresDropoffSignature: boolean | null
    requiresId: boolean | null
    orderReference: string | null
    orderTotalValue: number | null
    status: $Enums.EnumDeliveryStatus | null
    currencyCode: string | null
    imageType: string | null
    imageName: string | null
    imageData: Buffer | null
    idempotencyKey: string | null
    externalStoreId: string | null
    externalId: string | null
    courierId: string | null
    partnerId: string | null
    deliveryQuoteId: string | null
    totalCost: number | null
    fee: number | null
    feePercentage: number | null
    pay: number | null
    tips: number | null
    totalCompensation: number | null
    matchedCourierId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryMaxAggregateOutputType = {
    id: string | null
    pickupName: string | null
    pickupPhoneNumber: string | null
    pickupBusinessName: string | null
    pickupNotes: string | null
    pickupLocationId: string | null
    pickupReadyAt: Date | null
    pickupDeadlineAt: Date | null
    dropoffName: string | null
    dropoffPhoneNumber: string | null
    dropoffBusinessName: string | null
    dropoffNotes: string | null
    dropoffSellerNotes: string | null
    dropoffReadyAt: Date | null
    dropoffEta: Date | null
    dropoffDeadlineAt: Date | null
    deliverableAction: $Enums.EnumDeliverableAction | null
    undeliverableAction: $Enums.EnumUndeliverableAction | null
    undeliverableReason: string | null
    dropoffLocationId: string | null
    requiresDropoffSignature: boolean | null
    requiresId: boolean | null
    orderReference: string | null
    orderTotalValue: number | null
    status: $Enums.EnumDeliveryStatus | null
    currencyCode: string | null
    imageType: string | null
    imageName: string | null
    imageData: Buffer | null
    idempotencyKey: string | null
    externalStoreId: string | null
    externalId: string | null
    courierId: string | null
    partnerId: string | null
    deliveryQuoteId: string | null
    totalCost: number | null
    fee: number | null
    feePercentage: number | null
    pay: number | null
    tips: number | null
    totalCompensation: number | null
    matchedCourierId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryCountAggregateOutputType = {
    id: number
    pickupName: number
    pickupPhoneNumber: number
    pickupBusinessName: number
    pickupNotes: number
    pickupVerification: number
    pickupLocationId: number
    pickupReadyAt: number
    pickupDeadlineAt: number
    dropoffName: number
    dropoffPhoneNumber: number
    dropoffBusinessName: number
    dropoffNotes: number
    dropoffSellerNotes: number
    dropoffVerification: number
    dropoffReadyAt: number
    dropoffEta: number
    dropoffDeadlineAt: number
    deliverableAction: number
    undeliverableAction: number
    undeliverableReason: number
    dropoffLocationId: number
    deliveryTypes: number
    requiresDropoffSignature: number
    requiresId: number
    orderReference: number
    orderTotalValue: number
    orderItems: number
    status: number
    customerNotes: number
    currencyCode: number
    pickupTypes: number
    imageType: number
    imageName: number
    imageData: number
    idempotencyKey: number
    externalStoreId: number
    returnVerification: number
    externalUserInfo: number
    externalId: number
    courierId: number
    partnerId: number
    deliveryQuoteId: number
    totalCost: number
    fee: number
    feePercentage: number
    pay: number
    tips: number
    totalCompensation: number
    rejectedByCouriers: number
    matchedCourierId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliveryAvgAggregateInputType = {
    orderTotalValue?: true
    totalCost?: true
    fee?: true
    feePercentage?: true
    pay?: true
    tips?: true
    totalCompensation?: true
  }

  export type DeliverySumAggregateInputType = {
    orderTotalValue?: true
    totalCost?: true
    fee?: true
    feePercentage?: true
    pay?: true
    tips?: true
    totalCompensation?: true
  }

  export type DeliveryMinAggregateInputType = {
    id?: true
    pickupName?: true
    pickupPhoneNumber?: true
    pickupBusinessName?: true
    pickupNotes?: true
    pickupLocationId?: true
    pickupReadyAt?: true
    pickupDeadlineAt?: true
    dropoffName?: true
    dropoffPhoneNumber?: true
    dropoffBusinessName?: true
    dropoffNotes?: true
    dropoffSellerNotes?: true
    dropoffReadyAt?: true
    dropoffEta?: true
    dropoffDeadlineAt?: true
    deliverableAction?: true
    undeliverableAction?: true
    undeliverableReason?: true
    dropoffLocationId?: true
    requiresDropoffSignature?: true
    requiresId?: true
    orderReference?: true
    orderTotalValue?: true
    status?: true
    currencyCode?: true
    imageType?: true
    imageName?: true
    imageData?: true
    idempotencyKey?: true
    externalStoreId?: true
    externalId?: true
    courierId?: true
    partnerId?: true
    deliveryQuoteId?: true
    totalCost?: true
    fee?: true
    feePercentage?: true
    pay?: true
    tips?: true
    totalCompensation?: true
    matchedCourierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryMaxAggregateInputType = {
    id?: true
    pickupName?: true
    pickupPhoneNumber?: true
    pickupBusinessName?: true
    pickupNotes?: true
    pickupLocationId?: true
    pickupReadyAt?: true
    pickupDeadlineAt?: true
    dropoffName?: true
    dropoffPhoneNumber?: true
    dropoffBusinessName?: true
    dropoffNotes?: true
    dropoffSellerNotes?: true
    dropoffReadyAt?: true
    dropoffEta?: true
    dropoffDeadlineAt?: true
    deliverableAction?: true
    undeliverableAction?: true
    undeliverableReason?: true
    dropoffLocationId?: true
    requiresDropoffSignature?: true
    requiresId?: true
    orderReference?: true
    orderTotalValue?: true
    status?: true
    currencyCode?: true
    imageType?: true
    imageName?: true
    imageData?: true
    idempotencyKey?: true
    externalStoreId?: true
    externalId?: true
    courierId?: true
    partnerId?: true
    deliveryQuoteId?: true
    totalCost?: true
    fee?: true
    feePercentage?: true
    pay?: true
    tips?: true
    totalCompensation?: true
    matchedCourierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryCountAggregateInputType = {
    id?: true
    pickupName?: true
    pickupPhoneNumber?: true
    pickupBusinessName?: true
    pickupNotes?: true
    pickupVerification?: true
    pickupLocationId?: true
    pickupReadyAt?: true
    pickupDeadlineAt?: true
    dropoffName?: true
    dropoffPhoneNumber?: true
    dropoffBusinessName?: true
    dropoffNotes?: true
    dropoffSellerNotes?: true
    dropoffVerification?: true
    dropoffReadyAt?: true
    dropoffEta?: true
    dropoffDeadlineAt?: true
    deliverableAction?: true
    undeliverableAction?: true
    undeliverableReason?: true
    dropoffLocationId?: true
    deliveryTypes?: true
    requiresDropoffSignature?: true
    requiresId?: true
    orderReference?: true
    orderTotalValue?: true
    orderItems?: true
    status?: true
    customerNotes?: true
    currencyCode?: true
    pickupTypes?: true
    imageType?: true
    imageName?: true
    imageData?: true
    idempotencyKey?: true
    externalStoreId?: true
    returnVerification?: true
    externalUserInfo?: true
    externalId?: true
    courierId?: true
    partnerId?: true
    deliveryQuoteId?: true
    totalCost?: true
    fee?: true
    feePercentage?: true
    pay?: true
    tips?: true
    totalCompensation?: true
    rejectedByCouriers?: true
    matchedCourierId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliveryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delivery to aggregate.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationAndSearchRelevanceInput | DeliveryOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deliveries
    **/
    _count?: true | DeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryMaxAggregateInputType
  }

  export type GetDeliveryAggregateType<T extends DeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelivery[P]>
      : GetScalarType<T[P], AggregateDelivery[P]>
  }




  export type DeliveryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithAggregationInput | DeliveryOrderByWithAggregationInput[]
    by: DeliveryScalarFieldEnum[] | DeliveryScalarFieldEnum
    having?: DeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryCountAggregateInputType | true
    _avg?: DeliveryAvgAggregateInputType
    _sum?: DeliverySumAggregateInputType
    _min?: DeliveryMinAggregateInputType
    _max?: DeliveryMaxAggregateInputType
  }

  export type DeliveryGroupByOutputType = {
    id: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes: string | null
    pickupVerification: JsonValue | null
    pickupLocationId: string
    pickupReadyAt: Date | null
    pickupDeadlineAt: Date | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName: string | null
    dropoffNotes: string | null
    dropoffSellerNotes: string | null
    dropoffVerification: JsonValue | null
    dropoffReadyAt: Date | null
    dropoffEta: Date | null
    dropoffDeadlineAt: Date | null
    deliverableAction: $Enums.EnumDeliverableAction
    undeliverableAction: $Enums.EnumUndeliverableAction | null
    undeliverableReason: string | null
    dropoffLocationId: string
    deliveryTypes: string[]
    requiresDropoffSignature: boolean
    requiresId: boolean
    orderReference: string | null
    orderTotalValue: number | null
    orderItems: JsonValue | null
    status: $Enums.EnumDeliveryStatus
    customerNotes: string[]
    currencyCode: string
    pickupTypes: string[]
    imageType: string | null
    imageName: string | null
    imageData: Buffer | null
    idempotencyKey: string | null
    externalStoreId: string | null
    returnVerification: JsonValue | null
    externalUserInfo: JsonValue | null
    externalId: string | null
    courierId: string | null
    partnerId: string | null
    deliveryQuoteId: string
    totalCost: number | null
    fee: number | null
    feePercentage: number | null
    pay: number | null
    tips: number
    totalCompensation: number | null
    rejectedByCouriers: string[]
    matchedCourierId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DeliveryCountAggregateOutputType | null
    _avg: DeliveryAvgAggregateOutputType | null
    _sum: DeliverySumAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  type GetDeliveryGroupByPayload<T extends DeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
        }
      >
    >


  export type DeliverySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pickupName?: boolean
    pickupPhoneNumber?: boolean
    pickupBusinessName?: boolean
    pickupNotes?: boolean
    pickupVerification?: boolean
    pickupLocationId?: boolean
    pickupReadyAt?: boolean
    pickupDeadlineAt?: boolean
    dropoffName?: boolean
    dropoffPhoneNumber?: boolean
    dropoffBusinessName?: boolean
    dropoffNotes?: boolean
    dropoffSellerNotes?: boolean
    dropoffVerification?: boolean
    dropoffReadyAt?: boolean
    dropoffEta?: boolean
    dropoffDeadlineAt?: boolean
    deliverableAction?: boolean
    undeliverableAction?: boolean
    undeliverableReason?: boolean
    dropoffLocationId?: boolean
    deliveryTypes?: boolean
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: boolean
    orderTotalValue?: boolean
    orderItems?: boolean
    status?: boolean
    customerNotes?: boolean
    currencyCode?: boolean
    pickupTypes?: boolean
    imageType?: boolean
    imageName?: boolean
    imageData?: boolean
    idempotencyKey?: boolean
    externalStoreId?: boolean
    returnVerification?: boolean
    externalUserInfo?: boolean
    externalId?: boolean
    courierId?: boolean
    partnerId?: boolean
    deliveryQuoteId?: boolean
    totalCost?: boolean
    fee?: boolean
    feePercentage?: boolean
    pay?: boolean
    tips?: boolean
    totalCompensation?: boolean
    rejectedByCouriers?: boolean
    matchedCourierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pickupLocation?: boolean | Delivery$pickupLocationArgs<ExtArgs>
    dropoffLocation?: boolean | Delivery$dropoffLocationArgs<ExtArgs>
    courier?: boolean | Delivery$courierArgs<ExtArgs>
    partner?: boolean | Delivery$partnerArgs<ExtArgs>
    delivery?: boolean | DeliveryQuoteDefaultArgs<ExtArgs>
    payment?: boolean | Delivery$paymentArgs<ExtArgs>
    deliveryEvent?: boolean | Delivery$deliveryEventArgs<ExtArgs>
    locationNote?: boolean | Delivery$locationNoteArgs<ExtArgs>
    _count?: boolean | DeliveryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectScalar = {
    id?: boolean
    pickupName?: boolean
    pickupPhoneNumber?: boolean
    pickupBusinessName?: boolean
    pickupNotes?: boolean
    pickupVerification?: boolean
    pickupLocationId?: boolean
    pickupReadyAt?: boolean
    pickupDeadlineAt?: boolean
    dropoffName?: boolean
    dropoffPhoneNumber?: boolean
    dropoffBusinessName?: boolean
    dropoffNotes?: boolean
    dropoffSellerNotes?: boolean
    dropoffVerification?: boolean
    dropoffReadyAt?: boolean
    dropoffEta?: boolean
    dropoffDeadlineAt?: boolean
    deliverableAction?: boolean
    undeliverableAction?: boolean
    undeliverableReason?: boolean
    dropoffLocationId?: boolean
    deliveryTypes?: boolean
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: boolean
    orderTotalValue?: boolean
    orderItems?: boolean
    status?: boolean
    customerNotes?: boolean
    currencyCode?: boolean
    pickupTypes?: boolean
    imageType?: boolean
    imageName?: boolean
    imageData?: boolean
    idempotencyKey?: boolean
    externalStoreId?: boolean
    returnVerification?: boolean
    externalUserInfo?: boolean
    externalId?: boolean
    courierId?: boolean
    partnerId?: boolean
    deliveryQuoteId?: boolean
    totalCost?: boolean
    fee?: boolean
    feePercentage?: boolean
    pay?: boolean
    tips?: boolean
    totalCompensation?: boolean
    rejectedByCouriers?: boolean
    matchedCourierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliveryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pickupLocation?: boolean | Delivery$pickupLocationArgs<ExtArgs>
    dropoffLocation?: boolean | Delivery$dropoffLocationArgs<ExtArgs>
    courier?: boolean | Delivery$courierArgs<ExtArgs>
    partner?: boolean | Delivery$partnerArgs<ExtArgs>
    delivery?: boolean | DeliveryQuoteDefaultArgs<ExtArgs>
    payment?: boolean | Delivery$paymentArgs<ExtArgs>
    deliveryEvent?: boolean | Delivery$deliveryEventArgs<ExtArgs>
    locationNote?: boolean | Delivery$locationNoteArgs<ExtArgs>
    _count?: boolean | DeliveryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DeliveryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Delivery"
    objects: {
      pickupLocation: Prisma.$LocationPayload<ExtArgs> | null
      dropoffLocation: Prisma.$LocationPayload<ExtArgs> | null
      courier: Prisma.$CourierPayload<ExtArgs> | null
      partner: Prisma.$PartnerPayload<ExtArgs> | null
      delivery: Prisma.$DeliveryQuotePayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs>[]
      deliveryEvent: Prisma.$DeliveryEventPayload<ExtArgs>[]
      locationNote: Prisma.$LocationNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      pickupName: string
      pickupPhoneNumber: string
      pickupBusinessName: string
      pickupNotes: string | null
      pickupVerification: Prisma.JsonValue | null
      pickupLocationId: string
      pickupReadyAt: Date | null
      pickupDeadlineAt: Date | null
      dropoffName: string
      dropoffPhoneNumber: string
      dropoffBusinessName: string | null
      dropoffNotes: string | null
      dropoffSellerNotes: string | null
      dropoffVerification: Prisma.JsonValue | null
      dropoffReadyAt: Date | null
      dropoffEta: Date | null
      dropoffDeadlineAt: Date | null
      deliverableAction: $Enums.EnumDeliverableAction
      undeliverableAction: $Enums.EnumUndeliverableAction | null
      undeliverableReason: string | null
      dropoffLocationId: string
      deliveryTypes: string[]
      requiresDropoffSignature: boolean
      requiresId: boolean
      orderReference: string | null
      orderTotalValue: number | null
      orderItems: Prisma.JsonValue | null
      status: $Enums.EnumDeliveryStatus
      customerNotes: string[]
      currencyCode: string
      pickupTypes: string[]
      imageType: string | null
      imageName: string | null
      imageData: Buffer | null
      idempotencyKey: string | null
      externalStoreId: string | null
      returnVerification: Prisma.JsonValue | null
      externalUserInfo: Prisma.JsonValue | null
      externalId: string | null
      courierId: string | null
      partnerId: string | null
      deliveryQuoteId: string
      totalCost: number | null
      fee: number | null
      feePercentage: number | null
      pay: number | null
      tips: number
      totalCompensation: number | null
      rejectedByCouriers: string[]
      matchedCourierId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["delivery"]>
    composites: {}
  }


  type DeliveryGetPayload<S extends boolean | null | undefined | DeliveryDefaultArgs> = $Result.GetResult<Prisma.$DeliveryPayload, S>

  type DeliveryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DeliveryFindManyArgs, 'select' | 'include'> & {
      select?: DeliveryCountAggregateInputType | true
    }

  export interface DeliveryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Delivery'], meta: { name: 'Delivery' } }
    /**
     * Find zero or one Delivery that matches the filter.
     * @param {DeliveryFindUniqueArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeliveryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryFindUniqueArgs<ExtArgs>>
    ): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Delivery that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DeliveryFindUniqueOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeliveryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Delivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeliveryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryFindFirstArgs<ExtArgs>>
    ): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Delivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeliveryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Deliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deliveries
     * const deliveries = await prisma.delivery.findMany()
     * 
     * // Get first 10 Deliveries
     * const deliveries = await prisma.delivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryWithIdOnly = await prisma.delivery.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeliveryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Delivery.
     * @param {DeliveryCreateArgs} args - Arguments to create a Delivery.
     * @example
     * // Create one Delivery
     * const Delivery = await prisma.delivery.create({
     *   data: {
     *     // ... data to create a Delivery
     *   }
     * })
     * 
    **/
    create<T extends DeliveryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryCreateArgs<ExtArgs>>
    ): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Deliveries.
     *     @param {DeliveryCreateManyArgs} args - Arguments to create many Deliveries.
     *     @example
     *     // Create many Deliveries
     *     const delivery = await prisma.delivery.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeliveryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Delivery.
     * @param {DeliveryDeleteArgs} args - Arguments to delete one Delivery.
     * @example
     * // Delete one Delivery
     * const Delivery = await prisma.delivery.delete({
     *   where: {
     *     // ... filter to delete one Delivery
     *   }
     * })
     * 
    **/
    delete<T extends DeliveryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryDeleteArgs<ExtArgs>>
    ): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Delivery.
     * @param {DeliveryUpdateArgs} args - Arguments to update one Delivery.
     * @example
     * // Update one Delivery
     * const delivery = await prisma.delivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeliveryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryUpdateArgs<ExtArgs>>
    ): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Deliveries.
     * @param {DeliveryDeleteManyArgs} args - Arguments to filter Deliveries to delete.
     * @example
     * // Delete a few Deliveries
     * const { count } = await prisma.delivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeliveryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deliveries
     * const delivery = await prisma.delivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeliveryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Delivery.
     * @param {DeliveryUpsertArgs} args - Arguments to update or create a Delivery.
     * @example
     * // Update or create a Delivery
     * const delivery = await prisma.delivery.upsert({
     *   create: {
     *     // ... data to create a Delivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delivery we want to update
     *   }
     * })
    **/
    upsert<T extends DeliveryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryUpsertArgs<ExtArgs>>
    ): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryCountArgs} args - Arguments to filter Deliveries to count.
     * @example
     * // Count the number of Deliveries
     * const count = await prisma.delivery.count({
     *   where: {
     *     // ... the filter for the Deliveries we want to count
     *   }
     * })
    **/
    count<T extends DeliveryCountArgs>(
      args?: Subset<T, DeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryAggregateArgs>(args: Subset<T, DeliveryAggregateArgs>): Prisma.PrismaPromise<GetDeliveryAggregateType<T>>

    /**
     * Group by Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Delivery model
   */
  readonly fields: DeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Delivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pickupLocation<T extends Delivery$pickupLocationArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$pickupLocationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    dropoffLocation<T extends Delivery$dropoffLocationArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$dropoffLocationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    courier<T extends Delivery$courierArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$courierArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    partner<T extends Delivery$partnerArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$partnerArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    delivery<T extends DeliveryQuoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryQuoteDefaultArgs<ExtArgs>>): Prisma__DeliveryQuoteClient<$Result.GetResult<Prisma.$DeliveryQuotePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    payment<T extends Delivery$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    deliveryEvent<T extends Delivery$deliveryEventArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$deliveryEventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, 'findMany'> | Null>;

    locationNote<T extends Delivery$locationNoteArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$locationNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNotePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Delivery model
   */ 
  interface DeliveryFieldRefs {
    readonly id: FieldRef<"Delivery", 'String'>
    readonly pickupName: FieldRef<"Delivery", 'String'>
    readonly pickupPhoneNumber: FieldRef<"Delivery", 'String'>
    readonly pickupBusinessName: FieldRef<"Delivery", 'String'>
    readonly pickupNotes: FieldRef<"Delivery", 'String'>
    readonly pickupVerification: FieldRef<"Delivery", 'Json'>
    readonly pickupLocationId: FieldRef<"Delivery", 'String'>
    readonly pickupReadyAt: FieldRef<"Delivery", 'DateTime'>
    readonly pickupDeadlineAt: FieldRef<"Delivery", 'DateTime'>
    readonly dropoffName: FieldRef<"Delivery", 'String'>
    readonly dropoffPhoneNumber: FieldRef<"Delivery", 'String'>
    readonly dropoffBusinessName: FieldRef<"Delivery", 'String'>
    readonly dropoffNotes: FieldRef<"Delivery", 'String'>
    readonly dropoffSellerNotes: FieldRef<"Delivery", 'String'>
    readonly dropoffVerification: FieldRef<"Delivery", 'Json'>
    readonly dropoffReadyAt: FieldRef<"Delivery", 'DateTime'>
    readonly dropoffEta: FieldRef<"Delivery", 'DateTime'>
    readonly dropoffDeadlineAt: FieldRef<"Delivery", 'DateTime'>
    readonly deliverableAction: FieldRef<"Delivery", 'EnumDeliverableAction'>
    readonly undeliverableAction: FieldRef<"Delivery", 'EnumUndeliverableAction'>
    readonly undeliverableReason: FieldRef<"Delivery", 'String'>
    readonly dropoffLocationId: FieldRef<"Delivery", 'String'>
    readonly deliveryTypes: FieldRef<"Delivery", 'String[]'>
    readonly requiresDropoffSignature: FieldRef<"Delivery", 'Boolean'>
    readonly requiresId: FieldRef<"Delivery", 'Boolean'>
    readonly orderReference: FieldRef<"Delivery", 'String'>
    readonly orderTotalValue: FieldRef<"Delivery", 'Int'>
    readonly orderItems: FieldRef<"Delivery", 'Json'>
    readonly status: FieldRef<"Delivery", 'EnumDeliveryStatus'>
    readonly customerNotes: FieldRef<"Delivery", 'String[]'>
    readonly currencyCode: FieldRef<"Delivery", 'String'>
    readonly pickupTypes: FieldRef<"Delivery", 'String[]'>
    readonly imageType: FieldRef<"Delivery", 'String'>
    readonly imageName: FieldRef<"Delivery", 'String'>
    readonly imageData: FieldRef<"Delivery", 'Bytes'>
    readonly idempotencyKey: FieldRef<"Delivery", 'String'>
    readonly externalStoreId: FieldRef<"Delivery", 'String'>
    readonly returnVerification: FieldRef<"Delivery", 'Json'>
    readonly externalUserInfo: FieldRef<"Delivery", 'Json'>
    readonly externalId: FieldRef<"Delivery", 'String'>
    readonly courierId: FieldRef<"Delivery", 'String'>
    readonly partnerId: FieldRef<"Delivery", 'String'>
    readonly deliveryQuoteId: FieldRef<"Delivery", 'String'>
    readonly totalCost: FieldRef<"Delivery", 'Float'>
    readonly fee: FieldRef<"Delivery", 'Float'>
    readonly feePercentage: FieldRef<"Delivery", 'Float'>
    readonly pay: FieldRef<"Delivery", 'Float'>
    readonly tips: FieldRef<"Delivery", 'Float'>
    readonly totalCompensation: FieldRef<"Delivery", 'Float'>
    readonly rejectedByCouriers: FieldRef<"Delivery", 'String[]'>
    readonly matchedCourierId: FieldRef<"Delivery", 'String'>
    readonly createdAt: FieldRef<"Delivery", 'DateTime'>
    readonly updatedAt: FieldRef<"Delivery", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Delivery findUnique
   */
  export type DeliveryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }


  /**
   * Delivery findUniqueOrThrow
   */
  export type DeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }


  /**
   * Delivery findFirst
   */
  export type DeliveryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationAndSearchRelevanceInput | DeliveryOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }


  /**
   * Delivery findFirstOrThrow
   */
  export type DeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationAndSearchRelevanceInput | DeliveryOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }


  /**
   * Delivery findMany
   */
  export type DeliveryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Deliveries to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationAndSearchRelevanceInput | DeliveryOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }


  /**
   * Delivery create
   */
  export type DeliveryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a Delivery.
     */
    data: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
  }


  /**
   * Delivery createMany
   */
  export type DeliveryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deliveries.
     */
    data: DeliveryCreateManyInput | DeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Delivery update
   */
  export type DeliveryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a Delivery.
     */
    data: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
    /**
     * Choose, which Delivery to update.
     */
    where: DeliveryWhereUniqueInput
  }


  /**
   * Delivery updateMany
   */
  export type DeliveryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deliveries.
     */
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyInput>
    /**
     * Filter which Deliveries to update
     */
    where?: DeliveryWhereInput
  }


  /**
   * Delivery upsert
   */
  export type DeliveryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the Delivery to update in case it exists.
     */
    where: DeliveryWhereUniqueInput
    /**
     * In case the Delivery found by the `where` argument doesn't exist, create a new Delivery with this data.
     */
    create: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
    /**
     * In case the Delivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
  }


  /**
   * Delivery delete
   */
  export type DeliveryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter which Delivery to delete.
     */
    where: DeliveryWhereUniqueInput
  }


  /**
   * Delivery deleteMany
   */
  export type DeliveryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deliveries to delete
     */
    where?: DeliveryWhereInput
  }


  /**
   * Delivery.pickupLocation
   */
  export type Delivery$pickupLocationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }


  /**
   * Delivery.dropoffLocation
   */
  export type Delivery$dropoffLocationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }


  /**
   * Delivery.courier
   */
  export type Delivery$courierArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    where?: CourierWhereInput
  }


  /**
   * Delivery.partner
   */
  export type Delivery$partnerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
  }


  /**
   * Delivery.payment
   */
  export type Delivery$paymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationAndSearchRelevanceInput | PaymentOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Delivery.deliveryEvent
   */
  export type Delivery$deliveryEventArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    where?: DeliveryEventWhereInput
    orderBy?: DeliveryEventOrderByWithRelationAndSearchRelevanceInput | DeliveryEventOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: DeliveryEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryEventScalarFieldEnum | DeliveryEventScalarFieldEnum[]
  }


  /**
   * Delivery.locationNote
   */
  export type Delivery$locationNoteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNote
     */
    select?: LocationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteInclude<ExtArgs> | null
    where?: LocationNoteWhereInput
    orderBy?: LocationNoteOrderByWithRelationAndSearchRelevanceInput | LocationNoteOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: LocationNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationNoteScalarFieldEnum | LocationNoteScalarFieldEnum[]
  }


  /**
   * Delivery without action
   */
  export type DeliveryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
  }



  /**
   * Model DeliveryEvent
   */

  export type AggregateDeliveryEvent = {
    _count: DeliveryEventCountAggregateOutputType | null
    _min: DeliveryEventMinAggregateOutputType | null
    _max: DeliveryEventMaxAggregateOutputType | null
  }

  export type DeliveryEventMinAggregateOutputType = {
    id: string | null
    transitionSuccessful: boolean | null
    type: $Enums.EnumDeliveryEventType | null
    actor: $Enums.EnumEventActor | null
    eventSource: $Enums.EnumDeliveryEventSource | null
    oldStatus: $Enums.EnumDeliveryStatus | null
    newStatus: $Enums.EnumDeliveryStatus | null
    message: string | null
    deliveryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryEventMaxAggregateOutputType = {
    id: string | null
    transitionSuccessful: boolean | null
    type: $Enums.EnumDeliveryEventType | null
    actor: $Enums.EnumEventActor | null
    eventSource: $Enums.EnumDeliveryEventSource | null
    oldStatus: $Enums.EnumDeliveryStatus | null
    newStatus: $Enums.EnumDeliveryStatus | null
    message: string | null
    deliveryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryEventCountAggregateOutputType = {
    id: number
    transitionSuccessful: number
    type: number
    actor: number
    eventSource: number
    oldStatus: number
    newStatus: number
    message: number
    deliveryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliveryEventMinAggregateInputType = {
    id?: true
    transitionSuccessful?: true
    type?: true
    actor?: true
    eventSource?: true
    oldStatus?: true
    newStatus?: true
    message?: true
    deliveryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryEventMaxAggregateInputType = {
    id?: true
    transitionSuccessful?: true
    type?: true
    actor?: true
    eventSource?: true
    oldStatus?: true
    newStatus?: true
    message?: true
    deliveryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryEventCountAggregateInputType = {
    id?: true
    transitionSuccessful?: true
    type?: true
    actor?: true
    eventSource?: true
    oldStatus?: true
    newStatus?: true
    message?: true
    deliveryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliveryEventAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryEvent to aggregate.
     */
    where?: DeliveryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEvents to fetch.
     */
    orderBy?: DeliveryEventOrderByWithRelationAndSearchRelevanceInput | DeliveryEventOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryEvents
    **/
    _count?: true | DeliveryEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryEventMaxAggregateInputType
  }

  export type GetDeliveryEventAggregateType<T extends DeliveryEventAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryEvent[P]>
      : GetScalarType<T[P], AggregateDeliveryEvent[P]>
  }




  export type DeliveryEventGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DeliveryEventWhereInput
    orderBy?: DeliveryEventOrderByWithAggregationInput | DeliveryEventOrderByWithAggregationInput[]
    by: DeliveryEventScalarFieldEnum[] | DeliveryEventScalarFieldEnum
    having?: DeliveryEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryEventCountAggregateInputType | true
    _min?: DeliveryEventMinAggregateInputType
    _max?: DeliveryEventMaxAggregateInputType
  }

  export type DeliveryEventGroupByOutputType = {
    id: string
    transitionSuccessful: boolean
    type: $Enums.EnumDeliveryEventType
    actor: $Enums.EnumEventActor
    eventSource: $Enums.EnumDeliveryEventSource
    oldStatus: $Enums.EnumDeliveryStatus | null
    newStatus: $Enums.EnumDeliveryStatus | null
    message: string | null
    deliveryId: string
    createdAt: Date
    updatedAt: Date
    _count: DeliveryEventCountAggregateOutputType | null
    _min: DeliveryEventMinAggregateOutputType | null
    _max: DeliveryEventMaxAggregateOutputType | null
  }

  type GetDeliveryEventGroupByPayload<T extends DeliveryEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryEventGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryEventGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryEventSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transitionSuccessful?: boolean
    type?: boolean
    actor?: boolean
    eventSource?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    message?: boolean
    deliveryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryEvent"]>

  export type DeliveryEventSelectScalar = {
    id?: boolean
    transitionSuccessful?: boolean
    type?: boolean
    actor?: boolean
    eventSource?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    message?: boolean
    deliveryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliveryEventInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
  }


  export type $DeliveryEventPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "DeliveryEvent"
    objects: {
      delivery: Prisma.$DeliveryPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      transitionSuccessful: boolean
      type: $Enums.EnumDeliveryEventType
      actor: $Enums.EnumEventActor
      eventSource: $Enums.EnumDeliveryEventSource
      oldStatus: $Enums.EnumDeliveryStatus | null
      newStatus: $Enums.EnumDeliveryStatus | null
      message: string | null
      deliveryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deliveryEvent"]>
    composites: {}
  }


  type DeliveryEventGetPayload<S extends boolean | null | undefined | DeliveryEventDefaultArgs> = $Result.GetResult<Prisma.$DeliveryEventPayload, S>

  type DeliveryEventCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DeliveryEventFindManyArgs, 'select' | 'include'> & {
      select?: DeliveryEventCountAggregateInputType | true
    }

  export interface DeliveryEventDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryEvent'], meta: { name: 'DeliveryEvent' } }
    /**
     * Find zero or one DeliveryEvent that matches the filter.
     * @param {DeliveryEventFindUniqueArgs} args - Arguments to find a DeliveryEvent
     * @example
     * // Get one DeliveryEvent
     * const deliveryEvent = await prisma.deliveryEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeliveryEventFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryEventFindUniqueArgs<ExtArgs>>
    ): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DeliveryEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DeliveryEventFindUniqueOrThrowArgs} args - Arguments to find a DeliveryEvent
     * @example
     * // Get one DeliveryEvent
     * const deliveryEvent = await prisma.deliveryEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeliveryEventFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryEventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DeliveryEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEventFindFirstArgs} args - Arguments to find a DeliveryEvent
     * @example
     * // Get one DeliveryEvent
     * const deliveryEvent = await prisma.deliveryEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeliveryEventFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryEventFindFirstArgs<ExtArgs>>
    ): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DeliveryEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEventFindFirstOrThrowArgs} args - Arguments to find a DeliveryEvent
     * @example
     * // Get one DeliveryEvent
     * const deliveryEvent = await prisma.deliveryEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeliveryEventFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryEventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DeliveryEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryEvents
     * const deliveryEvents = await prisma.deliveryEvent.findMany()
     * 
     * // Get first 10 DeliveryEvents
     * const deliveryEvents = await prisma.deliveryEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryEventWithIdOnly = await prisma.deliveryEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeliveryEventFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryEventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DeliveryEvent.
     * @param {DeliveryEventCreateArgs} args - Arguments to create a DeliveryEvent.
     * @example
     * // Create one DeliveryEvent
     * const DeliveryEvent = await prisma.deliveryEvent.create({
     *   data: {
     *     // ... data to create a DeliveryEvent
     *   }
     * })
     * 
    **/
    create<T extends DeliveryEventCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryEventCreateArgs<ExtArgs>>
    ): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DeliveryEvents.
     *     @param {DeliveryEventCreateManyArgs} args - Arguments to create many DeliveryEvents.
     *     @example
     *     // Create many DeliveryEvents
     *     const deliveryEvent = await prisma.deliveryEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeliveryEventCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryEventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeliveryEvent.
     * @param {DeliveryEventDeleteArgs} args - Arguments to delete one DeliveryEvent.
     * @example
     * // Delete one DeliveryEvent
     * const DeliveryEvent = await prisma.deliveryEvent.delete({
     *   where: {
     *     // ... filter to delete one DeliveryEvent
     *   }
     * })
     * 
    **/
    delete<T extends DeliveryEventDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryEventDeleteArgs<ExtArgs>>
    ): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DeliveryEvent.
     * @param {DeliveryEventUpdateArgs} args - Arguments to update one DeliveryEvent.
     * @example
     * // Update one DeliveryEvent
     * const deliveryEvent = await prisma.deliveryEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeliveryEventUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryEventUpdateArgs<ExtArgs>>
    ): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DeliveryEvents.
     * @param {DeliveryEventDeleteManyArgs} args - Arguments to filter DeliveryEvents to delete.
     * @example
     * // Delete a few DeliveryEvents
     * const { count } = await prisma.deliveryEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeliveryEventDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeliveryEventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryEvents
     * const deliveryEvent = await prisma.deliveryEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeliveryEventUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryEventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeliveryEvent.
     * @param {DeliveryEventUpsertArgs} args - Arguments to update or create a DeliveryEvent.
     * @example
     * // Update or create a DeliveryEvent
     * const deliveryEvent = await prisma.deliveryEvent.upsert({
     *   create: {
     *     // ... data to create a DeliveryEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryEvent we want to update
     *   }
     * })
    **/
    upsert<T extends DeliveryEventUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DeliveryEventUpsertArgs<ExtArgs>>
    ): Prisma__DeliveryEventClient<$Result.GetResult<Prisma.$DeliveryEventPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DeliveryEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEventCountArgs} args - Arguments to filter DeliveryEvents to count.
     * @example
     * // Count the number of DeliveryEvents
     * const count = await prisma.deliveryEvent.count({
     *   where: {
     *     // ... the filter for the DeliveryEvents we want to count
     *   }
     * })
    **/
    count<T extends DeliveryEventCountArgs>(
      args?: Subset<T, DeliveryEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryEventAggregateArgs>(args: Subset<T, DeliveryEventAggregateArgs>): Prisma.PrismaPromise<GetDeliveryEventAggregateType<T>>

    /**
     * Group by DeliveryEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryEventGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryEvent model
   */
  readonly fields: DeliveryEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryEventClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    delivery<T extends DeliveryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryDefaultArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DeliveryEvent model
   */ 
  interface DeliveryEventFieldRefs {
    readonly id: FieldRef<"DeliveryEvent", 'String'>
    readonly transitionSuccessful: FieldRef<"DeliveryEvent", 'Boolean'>
    readonly type: FieldRef<"DeliveryEvent", 'EnumDeliveryEventType'>
    readonly actor: FieldRef<"DeliveryEvent", 'EnumEventActor'>
    readonly eventSource: FieldRef<"DeliveryEvent", 'EnumDeliveryEventSource'>
    readonly oldStatus: FieldRef<"DeliveryEvent", 'EnumDeliveryStatus'>
    readonly newStatus: FieldRef<"DeliveryEvent", 'EnumDeliveryStatus'>
    readonly message: FieldRef<"DeliveryEvent", 'String'>
    readonly deliveryId: FieldRef<"DeliveryEvent", 'String'>
    readonly createdAt: FieldRef<"DeliveryEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliveryEvent", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * DeliveryEvent findUnique
   */
  export type DeliveryEventFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEvent to fetch.
     */
    where: DeliveryEventWhereUniqueInput
  }


  /**
   * DeliveryEvent findUniqueOrThrow
   */
  export type DeliveryEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEvent to fetch.
     */
    where: DeliveryEventWhereUniqueInput
  }


  /**
   * DeliveryEvent findFirst
   */
  export type DeliveryEventFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEvent to fetch.
     */
    where?: DeliveryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEvents to fetch.
     */
    orderBy?: DeliveryEventOrderByWithRelationAndSearchRelevanceInput | DeliveryEventOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryEvents.
     */
    cursor?: DeliveryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryEvents.
     */
    distinct?: DeliveryEventScalarFieldEnum | DeliveryEventScalarFieldEnum[]
  }


  /**
   * DeliveryEvent findFirstOrThrow
   */
  export type DeliveryEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEvent to fetch.
     */
    where?: DeliveryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEvents to fetch.
     */
    orderBy?: DeliveryEventOrderByWithRelationAndSearchRelevanceInput | DeliveryEventOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryEvents.
     */
    cursor?: DeliveryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryEvents.
     */
    distinct?: DeliveryEventScalarFieldEnum | DeliveryEventScalarFieldEnum[]
  }


  /**
   * DeliveryEvent findMany
   */
  export type DeliveryEventFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEvents to fetch.
     */
    where?: DeliveryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEvents to fetch.
     */
    orderBy?: DeliveryEventOrderByWithRelationAndSearchRelevanceInput | DeliveryEventOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryEvents.
     */
    cursor?: DeliveryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEvents.
     */
    skip?: number
    distinct?: DeliveryEventScalarFieldEnum | DeliveryEventScalarFieldEnum[]
  }


  /**
   * DeliveryEvent create
   */
  export type DeliveryEventCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryEvent.
     */
    data: XOR<DeliveryEventCreateInput, DeliveryEventUncheckedCreateInput>
  }


  /**
   * DeliveryEvent createMany
   */
  export type DeliveryEventCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryEvents.
     */
    data: DeliveryEventCreateManyInput | DeliveryEventCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DeliveryEvent update
   */
  export type DeliveryEventUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryEvent.
     */
    data: XOR<DeliveryEventUpdateInput, DeliveryEventUncheckedUpdateInput>
    /**
     * Choose, which DeliveryEvent to update.
     */
    where: DeliveryEventWhereUniqueInput
  }


  /**
   * DeliveryEvent updateMany
   */
  export type DeliveryEventUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryEvents.
     */
    data: XOR<DeliveryEventUpdateManyMutationInput, DeliveryEventUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryEvents to update
     */
    where?: DeliveryEventWhereInput
  }


  /**
   * DeliveryEvent upsert
   */
  export type DeliveryEventUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryEvent to update in case it exists.
     */
    where: DeliveryEventWhereUniqueInput
    /**
     * In case the DeliveryEvent found by the `where` argument doesn't exist, create a new DeliveryEvent with this data.
     */
    create: XOR<DeliveryEventCreateInput, DeliveryEventUncheckedCreateInput>
    /**
     * In case the DeliveryEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryEventUpdateInput, DeliveryEventUncheckedUpdateInput>
  }


  /**
   * DeliveryEvent delete
   */
  export type DeliveryEventDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryEventInclude<ExtArgs> | null
    /**
     * Filter which DeliveryEvent to delete.
     */
    where: DeliveryEventWhereUniqueInput
  }


  /**
   * DeliveryEvent deleteMany
   */
  export type DeliveryEventDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryEvents to delete
     */
    where?: DeliveryEventWhereInput
  }


  /**
   * DeliveryEvent without action
   */
  export type DeliveryEventDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEvent
     */
    select?: DeliveryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryEventInclude<ExtArgs> | null
  }



  /**
   * Model LocationNote
   */

  export type AggregateLocationNote = {
    _count: LocationNoteCountAggregateOutputType | null
    _min: LocationNoteMinAggregateOutputType | null
    _max: LocationNoteMaxAggregateOutputType | null
  }

  export type LocationNoteMinAggregateOutputType = {
    id: string | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    actor: $Enums.EnumLocationNoteActor | null
    locationId: string | null
    deliveryId: string | null
    courierId: string | null
  }

  export type LocationNoteMaxAggregateOutputType = {
    id: string | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    actor: $Enums.EnumLocationNoteActor | null
    locationId: string | null
    deliveryId: string | null
    courierId: string | null
  }

  export type LocationNoteCountAggregateOutputType = {
    id: number
    note: number
    createdAt: number
    updatedAt: number
    actor: number
    locationId: number
    deliveryId: number
    courierId: number
    _all: number
  }


  export type LocationNoteMinAggregateInputType = {
    id?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    actor?: true
    locationId?: true
    deliveryId?: true
    courierId?: true
  }

  export type LocationNoteMaxAggregateInputType = {
    id?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    actor?: true
    locationId?: true
    deliveryId?: true
    courierId?: true
  }

  export type LocationNoteCountAggregateInputType = {
    id?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    actor?: true
    locationId?: true
    deliveryId?: true
    courierId?: true
    _all?: true
  }

  export type LocationNoteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationNote to aggregate.
     */
    where?: LocationNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNotes to fetch.
     */
    orderBy?: LocationNoteOrderByWithRelationAndSearchRelevanceInput | LocationNoteOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationNotes
    **/
    _count?: true | LocationNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationNoteMaxAggregateInputType
  }

  export type GetLocationNoteAggregateType<T extends LocationNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationNote[P]>
      : GetScalarType<T[P], AggregateLocationNote[P]>
  }




  export type LocationNoteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LocationNoteWhereInput
    orderBy?: LocationNoteOrderByWithAggregationInput | LocationNoteOrderByWithAggregationInput[]
    by: LocationNoteScalarFieldEnum[] | LocationNoteScalarFieldEnum
    having?: LocationNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationNoteCountAggregateInputType | true
    _min?: LocationNoteMinAggregateInputType
    _max?: LocationNoteMaxAggregateInputType
  }

  export type LocationNoteGroupByOutputType = {
    id: string
    note: string | null
    createdAt: Date
    updatedAt: Date
    actor: $Enums.EnumLocationNoteActor
    locationId: string | null
    deliveryId: string | null
    courierId: string | null
    _count: LocationNoteCountAggregateOutputType | null
    _min: LocationNoteMinAggregateOutputType | null
    _max: LocationNoteMaxAggregateOutputType | null
  }

  type GetLocationNoteGroupByPayload<T extends LocationNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationNoteGroupByOutputType[P]>
            : GetScalarType<T[P], LocationNoteGroupByOutputType[P]>
        }
      >
    >


  export type LocationNoteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    actor?: boolean
    locationId?: boolean
    deliveryId?: boolean
    courierId?: boolean
    locations?: boolean | LocationNote$locationsArgs<ExtArgs>
    delivery?: boolean | LocationNote$deliveryArgs<ExtArgs>
    couriers?: boolean | LocationNote$couriersArgs<ExtArgs>
    noteReactions?: boolean | LocationNote$noteReactionsArgs<ExtArgs>
    _count?: boolean | LocationNoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationNote"]>

  export type LocationNoteSelectScalar = {
    id?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    actor?: boolean
    locationId?: boolean
    deliveryId?: boolean
    courierId?: boolean
  }

  export type LocationNoteInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    locations?: boolean | LocationNote$locationsArgs<ExtArgs>
    delivery?: boolean | LocationNote$deliveryArgs<ExtArgs>
    couriers?: boolean | LocationNote$couriersArgs<ExtArgs>
    noteReactions?: boolean | LocationNote$noteReactionsArgs<ExtArgs>
    _count?: boolean | LocationNoteCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LocationNotePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "LocationNote"
    objects: {
      locations: Prisma.$LocationPayload<ExtArgs> | null
      delivery: Prisma.$DeliveryPayload<ExtArgs> | null
      couriers: Prisma.$CourierPayload<ExtArgs> | null
      noteReactions: Prisma.$LocationNoteReactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      note: string | null
      createdAt: Date
      updatedAt: Date
      actor: $Enums.EnumLocationNoteActor
      locationId: string | null
      deliveryId: string | null
      courierId: string | null
    }, ExtArgs["result"]["locationNote"]>
    composites: {}
  }


  type LocationNoteGetPayload<S extends boolean | null | undefined | LocationNoteDefaultArgs> = $Result.GetResult<Prisma.$LocationNotePayload, S>

  type LocationNoteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LocationNoteFindManyArgs, 'select' | 'include'> & {
      select?: LocationNoteCountAggregateInputType | true
    }

  export interface LocationNoteDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationNote'], meta: { name: 'LocationNote' } }
    /**
     * Find zero or one LocationNote that matches the filter.
     * @param {LocationNoteFindUniqueArgs} args - Arguments to find a LocationNote
     * @example
     * // Get one LocationNote
     * const locationNote = await prisma.locationNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LocationNoteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LocationNoteFindUniqueArgs<ExtArgs>>
    ): Prisma__LocationNoteClient<$Result.GetResult<Prisma.$LocationNotePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LocationNote that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LocationNoteFindUniqueOrThrowArgs} args - Arguments to find a LocationNote
     * @example
     * // Get one LocationNote
     * const locationNote = await prisma.locationNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LocationNoteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationNoteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LocationNoteClient<$Result.GetResult<Prisma.$LocationNotePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LocationNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNoteFindFirstArgs} args - Arguments to find a LocationNote
     * @example
     * // Get one LocationNote
     * const locationNote = await prisma.locationNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LocationNoteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationNoteFindFirstArgs<ExtArgs>>
    ): Prisma__LocationNoteClient<$Result.GetResult<Prisma.$LocationNotePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LocationNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNoteFindFirstOrThrowArgs} args - Arguments to find a LocationNote
     * @example
     * // Get one LocationNote
     * const locationNote = await prisma.locationNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LocationNoteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationNoteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LocationNoteClient<$Result.GetResult<Prisma.$LocationNotePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LocationNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationNotes
     * const locationNotes = await prisma.locationNote.findMany()
     * 
     * // Get first 10 LocationNotes
     * const locationNotes = await prisma.locationNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationNoteWithIdOnly = await prisma.locationNote.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LocationNoteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationNoteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNotePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LocationNote.
     * @param {LocationNoteCreateArgs} args - Arguments to create a LocationNote.
     * @example
     * // Create one LocationNote
     * const LocationNote = await prisma.locationNote.create({
     *   data: {
     *     // ... data to create a LocationNote
     *   }
     * })
     * 
    **/
    create<T extends LocationNoteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LocationNoteCreateArgs<ExtArgs>>
    ): Prisma__LocationNoteClient<$Result.GetResult<Prisma.$LocationNotePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LocationNotes.
     *     @param {LocationNoteCreateManyArgs} args - Arguments to create many LocationNotes.
     *     @example
     *     // Create many LocationNotes
     *     const locationNote = await prisma.locationNote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LocationNoteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationNoteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LocationNote.
     * @param {LocationNoteDeleteArgs} args - Arguments to delete one LocationNote.
     * @example
     * // Delete one LocationNote
     * const LocationNote = await prisma.locationNote.delete({
     *   where: {
     *     // ... filter to delete one LocationNote
     *   }
     * })
     * 
    **/
    delete<T extends LocationNoteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LocationNoteDeleteArgs<ExtArgs>>
    ): Prisma__LocationNoteClient<$Result.GetResult<Prisma.$LocationNotePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LocationNote.
     * @param {LocationNoteUpdateArgs} args - Arguments to update one LocationNote.
     * @example
     * // Update one LocationNote
     * const locationNote = await prisma.locationNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LocationNoteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LocationNoteUpdateArgs<ExtArgs>>
    ): Prisma__LocationNoteClient<$Result.GetResult<Prisma.$LocationNotePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LocationNotes.
     * @param {LocationNoteDeleteManyArgs} args - Arguments to filter LocationNotes to delete.
     * @example
     * // Delete a few LocationNotes
     * const { count } = await prisma.locationNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LocationNoteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationNoteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationNotes
     * const locationNote = await prisma.locationNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LocationNoteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LocationNoteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocationNote.
     * @param {LocationNoteUpsertArgs} args - Arguments to update or create a LocationNote.
     * @example
     * // Update or create a LocationNote
     * const locationNote = await prisma.locationNote.upsert({
     *   create: {
     *     // ... data to create a LocationNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationNote we want to update
     *   }
     * })
    **/
    upsert<T extends LocationNoteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LocationNoteUpsertArgs<ExtArgs>>
    ): Prisma__LocationNoteClient<$Result.GetResult<Prisma.$LocationNotePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LocationNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNoteCountArgs} args - Arguments to filter LocationNotes to count.
     * @example
     * // Count the number of LocationNotes
     * const count = await prisma.locationNote.count({
     *   where: {
     *     // ... the filter for the LocationNotes we want to count
     *   }
     * })
    **/
    count<T extends LocationNoteCountArgs>(
      args?: Subset<T, LocationNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationNoteAggregateArgs>(args: Subset<T, LocationNoteAggregateArgs>): Prisma.PrismaPromise<GetLocationNoteAggregateType<T>>

    /**
     * Group by LocationNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationNoteGroupByArgs['orderBy'] }
        : { orderBy?: LocationNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationNote model
   */
  readonly fields: LocationNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationNoteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    locations<T extends LocationNote$locationsArgs<ExtArgs> = {}>(args?: Subset<T, LocationNote$locationsArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    delivery<T extends LocationNote$deliveryArgs<ExtArgs> = {}>(args?: Subset<T, LocationNote$deliveryArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    couriers<T extends LocationNote$couriersArgs<ExtArgs> = {}>(args?: Subset<T, LocationNote$couriersArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    noteReactions<T extends LocationNote$noteReactionsArgs<ExtArgs> = {}>(args?: Subset<T, LocationNote$noteReactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNoteReactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LocationNote model
   */ 
  interface LocationNoteFieldRefs {
    readonly id: FieldRef<"LocationNote", 'String'>
    readonly note: FieldRef<"LocationNote", 'String'>
    readonly createdAt: FieldRef<"LocationNote", 'DateTime'>
    readonly updatedAt: FieldRef<"LocationNote", 'DateTime'>
    readonly actor: FieldRef<"LocationNote", 'EnumLocationNoteActor'>
    readonly locationId: FieldRef<"LocationNote", 'String'>
    readonly deliveryId: FieldRef<"LocationNote", 'String'>
    readonly courierId: FieldRef<"LocationNote", 'String'>
  }
    

  // Custom InputTypes

  /**
   * LocationNote findUnique
   */
  export type LocationNoteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNote
     */
    select?: LocationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteInclude<ExtArgs> | null
    /**
     * Filter, which LocationNote to fetch.
     */
    where: LocationNoteWhereUniqueInput
  }


  /**
   * LocationNote findUniqueOrThrow
   */
  export type LocationNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNote
     */
    select?: LocationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteInclude<ExtArgs> | null
    /**
     * Filter, which LocationNote to fetch.
     */
    where: LocationNoteWhereUniqueInput
  }


  /**
   * LocationNote findFirst
   */
  export type LocationNoteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNote
     */
    select?: LocationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteInclude<ExtArgs> | null
    /**
     * Filter, which LocationNote to fetch.
     */
    where?: LocationNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNotes to fetch.
     */
    orderBy?: LocationNoteOrderByWithRelationAndSearchRelevanceInput | LocationNoteOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationNotes.
     */
    cursor?: LocationNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationNotes.
     */
    distinct?: LocationNoteScalarFieldEnum | LocationNoteScalarFieldEnum[]
  }


  /**
   * LocationNote findFirstOrThrow
   */
  export type LocationNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNote
     */
    select?: LocationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteInclude<ExtArgs> | null
    /**
     * Filter, which LocationNote to fetch.
     */
    where?: LocationNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNotes to fetch.
     */
    orderBy?: LocationNoteOrderByWithRelationAndSearchRelevanceInput | LocationNoteOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationNotes.
     */
    cursor?: LocationNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationNotes.
     */
    distinct?: LocationNoteScalarFieldEnum | LocationNoteScalarFieldEnum[]
  }


  /**
   * LocationNote findMany
   */
  export type LocationNoteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNote
     */
    select?: LocationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteInclude<ExtArgs> | null
    /**
     * Filter, which LocationNotes to fetch.
     */
    where?: LocationNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNotes to fetch.
     */
    orderBy?: LocationNoteOrderByWithRelationAndSearchRelevanceInput | LocationNoteOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationNotes.
     */
    cursor?: LocationNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNotes.
     */
    skip?: number
    distinct?: LocationNoteScalarFieldEnum | LocationNoteScalarFieldEnum[]
  }


  /**
   * LocationNote create
   */
  export type LocationNoteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNote
     */
    select?: LocationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a LocationNote.
     */
    data: XOR<LocationNoteCreateInput, LocationNoteUncheckedCreateInput>
  }


  /**
   * LocationNote createMany
   */
  export type LocationNoteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationNotes.
     */
    data: LocationNoteCreateManyInput | LocationNoteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LocationNote update
   */
  export type LocationNoteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNote
     */
    select?: LocationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a LocationNote.
     */
    data: XOR<LocationNoteUpdateInput, LocationNoteUncheckedUpdateInput>
    /**
     * Choose, which LocationNote to update.
     */
    where: LocationNoteWhereUniqueInput
  }


  /**
   * LocationNote updateMany
   */
  export type LocationNoteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationNotes.
     */
    data: XOR<LocationNoteUpdateManyMutationInput, LocationNoteUncheckedUpdateManyInput>
    /**
     * Filter which LocationNotes to update
     */
    where?: LocationNoteWhereInput
  }


  /**
   * LocationNote upsert
   */
  export type LocationNoteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNote
     */
    select?: LocationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the LocationNote to update in case it exists.
     */
    where: LocationNoteWhereUniqueInput
    /**
     * In case the LocationNote found by the `where` argument doesn't exist, create a new LocationNote with this data.
     */
    create: XOR<LocationNoteCreateInput, LocationNoteUncheckedCreateInput>
    /**
     * In case the LocationNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationNoteUpdateInput, LocationNoteUncheckedUpdateInput>
  }


  /**
   * LocationNote delete
   */
  export type LocationNoteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNote
     */
    select?: LocationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteInclude<ExtArgs> | null
    /**
     * Filter which LocationNote to delete.
     */
    where: LocationNoteWhereUniqueInput
  }


  /**
   * LocationNote deleteMany
   */
  export type LocationNoteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationNotes to delete
     */
    where?: LocationNoteWhereInput
  }


  /**
   * LocationNote.locations
   */
  export type LocationNote$locationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }


  /**
   * LocationNote.delivery
   */
  export type LocationNote$deliveryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
  }


  /**
   * LocationNote.couriers
   */
  export type LocationNote$couriersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    where?: CourierWhereInput
  }


  /**
   * LocationNote.noteReactions
   */
  export type LocationNote$noteReactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNoteReaction
     */
    select?: LocationNoteReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteReactionInclude<ExtArgs> | null
    where?: LocationNoteReactionWhereInput
    orderBy?: LocationNoteReactionOrderByWithRelationAndSearchRelevanceInput | LocationNoteReactionOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: LocationNoteReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationNoteReactionScalarFieldEnum | LocationNoteReactionScalarFieldEnum[]
  }


  /**
   * LocationNote without action
   */
  export type LocationNoteDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNote
     */
    select?: LocationNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteInclude<ExtArgs> | null
  }



  /**
   * Model LocationNoteReaction
   */

  export type AggregateLocationNoteReaction = {
    _count: LocationNoteReactionCountAggregateOutputType | null
    _min: LocationNoteReactionMinAggregateOutputType | null
    _max: LocationNoteReactionMaxAggregateOutputType | null
  }

  export type LocationNoteReactionMinAggregateOutputType = {
    id: string | null
    reaction: $Enums.EnumLocationNoteReactionType | null
    createdAt: Date | null
    updatedAt: Date | null
    locationNoteId: string | null
    courierId: string | null
  }

  export type LocationNoteReactionMaxAggregateOutputType = {
    id: string | null
    reaction: $Enums.EnumLocationNoteReactionType | null
    createdAt: Date | null
    updatedAt: Date | null
    locationNoteId: string | null
    courierId: string | null
  }

  export type LocationNoteReactionCountAggregateOutputType = {
    id: number
    reaction: number
    createdAt: number
    updatedAt: number
    locationNoteId: number
    courierId: number
    _all: number
  }


  export type LocationNoteReactionMinAggregateInputType = {
    id?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
    locationNoteId?: true
    courierId?: true
  }

  export type LocationNoteReactionMaxAggregateInputType = {
    id?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
    locationNoteId?: true
    courierId?: true
  }

  export type LocationNoteReactionCountAggregateInputType = {
    id?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
    locationNoteId?: true
    courierId?: true
    _all?: true
  }

  export type LocationNoteReactionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationNoteReaction to aggregate.
     */
    where?: LocationNoteReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNoteReactions to fetch.
     */
    orderBy?: LocationNoteReactionOrderByWithRelationAndSearchRelevanceInput | LocationNoteReactionOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationNoteReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNoteReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNoteReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationNoteReactions
    **/
    _count?: true | LocationNoteReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationNoteReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationNoteReactionMaxAggregateInputType
  }

  export type GetLocationNoteReactionAggregateType<T extends LocationNoteReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationNoteReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationNoteReaction[P]>
      : GetScalarType<T[P], AggregateLocationNoteReaction[P]>
  }




  export type LocationNoteReactionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LocationNoteReactionWhereInput
    orderBy?: LocationNoteReactionOrderByWithAggregationInput | LocationNoteReactionOrderByWithAggregationInput[]
    by: LocationNoteReactionScalarFieldEnum[] | LocationNoteReactionScalarFieldEnum
    having?: LocationNoteReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationNoteReactionCountAggregateInputType | true
    _min?: LocationNoteReactionMinAggregateInputType
    _max?: LocationNoteReactionMaxAggregateInputType
  }

  export type LocationNoteReactionGroupByOutputType = {
    id: string
    reaction: $Enums.EnumLocationNoteReactionType
    createdAt: Date
    updatedAt: Date
    locationNoteId: string
    courierId: string
    _count: LocationNoteReactionCountAggregateOutputType | null
    _min: LocationNoteReactionMinAggregateOutputType | null
    _max: LocationNoteReactionMaxAggregateOutputType | null
  }

  type GetLocationNoteReactionGroupByPayload<T extends LocationNoteReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationNoteReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationNoteReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationNoteReactionGroupByOutputType[P]>
            : GetScalarType<T[P], LocationNoteReactionGroupByOutputType[P]>
        }
      >
    >


  export type LocationNoteReactionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locationNoteId?: boolean
    courierId?: boolean
    locationNote?: boolean | LocationNoteDefaultArgs<ExtArgs>
    couriers?: boolean | CourierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationNoteReaction"]>

  export type LocationNoteReactionSelectScalar = {
    id?: boolean
    reaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locationNoteId?: boolean
    courierId?: boolean
  }

  export type LocationNoteReactionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    locationNote?: boolean | LocationNoteDefaultArgs<ExtArgs>
    couriers?: boolean | CourierDefaultArgs<ExtArgs>
  }


  export type $LocationNoteReactionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "LocationNoteReaction"
    objects: {
      locationNote: Prisma.$LocationNotePayload<ExtArgs>
      couriers: Prisma.$CourierPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      reaction: $Enums.EnumLocationNoteReactionType
      createdAt: Date
      updatedAt: Date
      locationNoteId: string
      courierId: string
    }, ExtArgs["result"]["locationNoteReaction"]>
    composites: {}
  }


  type LocationNoteReactionGetPayload<S extends boolean | null | undefined | LocationNoteReactionDefaultArgs> = $Result.GetResult<Prisma.$LocationNoteReactionPayload, S>

  type LocationNoteReactionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LocationNoteReactionFindManyArgs, 'select' | 'include'> & {
      select?: LocationNoteReactionCountAggregateInputType | true
    }

  export interface LocationNoteReactionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationNoteReaction'], meta: { name: 'LocationNoteReaction' } }
    /**
     * Find zero or one LocationNoteReaction that matches the filter.
     * @param {LocationNoteReactionFindUniqueArgs} args - Arguments to find a LocationNoteReaction
     * @example
     * // Get one LocationNoteReaction
     * const locationNoteReaction = await prisma.locationNoteReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LocationNoteReactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LocationNoteReactionFindUniqueArgs<ExtArgs>>
    ): Prisma__LocationNoteReactionClient<$Result.GetResult<Prisma.$LocationNoteReactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LocationNoteReaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LocationNoteReactionFindUniqueOrThrowArgs} args - Arguments to find a LocationNoteReaction
     * @example
     * // Get one LocationNoteReaction
     * const locationNoteReaction = await prisma.locationNoteReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LocationNoteReactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationNoteReactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LocationNoteReactionClient<$Result.GetResult<Prisma.$LocationNoteReactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LocationNoteReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNoteReactionFindFirstArgs} args - Arguments to find a LocationNoteReaction
     * @example
     * // Get one LocationNoteReaction
     * const locationNoteReaction = await prisma.locationNoteReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LocationNoteReactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationNoteReactionFindFirstArgs<ExtArgs>>
    ): Prisma__LocationNoteReactionClient<$Result.GetResult<Prisma.$LocationNoteReactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LocationNoteReaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNoteReactionFindFirstOrThrowArgs} args - Arguments to find a LocationNoteReaction
     * @example
     * // Get one LocationNoteReaction
     * const locationNoteReaction = await prisma.locationNoteReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LocationNoteReactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationNoteReactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LocationNoteReactionClient<$Result.GetResult<Prisma.$LocationNoteReactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LocationNoteReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNoteReactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationNoteReactions
     * const locationNoteReactions = await prisma.locationNoteReaction.findMany()
     * 
     * // Get first 10 LocationNoteReactions
     * const locationNoteReactions = await prisma.locationNoteReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationNoteReactionWithIdOnly = await prisma.locationNoteReaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LocationNoteReactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationNoteReactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNoteReactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LocationNoteReaction.
     * @param {LocationNoteReactionCreateArgs} args - Arguments to create a LocationNoteReaction.
     * @example
     * // Create one LocationNoteReaction
     * const LocationNoteReaction = await prisma.locationNoteReaction.create({
     *   data: {
     *     // ... data to create a LocationNoteReaction
     *   }
     * })
     * 
    **/
    create<T extends LocationNoteReactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LocationNoteReactionCreateArgs<ExtArgs>>
    ): Prisma__LocationNoteReactionClient<$Result.GetResult<Prisma.$LocationNoteReactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LocationNoteReactions.
     *     @param {LocationNoteReactionCreateManyArgs} args - Arguments to create many LocationNoteReactions.
     *     @example
     *     // Create many LocationNoteReactions
     *     const locationNoteReaction = await prisma.locationNoteReaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LocationNoteReactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationNoteReactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LocationNoteReaction.
     * @param {LocationNoteReactionDeleteArgs} args - Arguments to delete one LocationNoteReaction.
     * @example
     * // Delete one LocationNoteReaction
     * const LocationNoteReaction = await prisma.locationNoteReaction.delete({
     *   where: {
     *     // ... filter to delete one LocationNoteReaction
     *   }
     * })
     * 
    **/
    delete<T extends LocationNoteReactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LocationNoteReactionDeleteArgs<ExtArgs>>
    ): Prisma__LocationNoteReactionClient<$Result.GetResult<Prisma.$LocationNoteReactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LocationNoteReaction.
     * @param {LocationNoteReactionUpdateArgs} args - Arguments to update one LocationNoteReaction.
     * @example
     * // Update one LocationNoteReaction
     * const locationNoteReaction = await prisma.locationNoteReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LocationNoteReactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LocationNoteReactionUpdateArgs<ExtArgs>>
    ): Prisma__LocationNoteReactionClient<$Result.GetResult<Prisma.$LocationNoteReactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LocationNoteReactions.
     * @param {LocationNoteReactionDeleteManyArgs} args - Arguments to filter LocationNoteReactions to delete.
     * @example
     * // Delete a few LocationNoteReactions
     * const { count } = await prisma.locationNoteReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LocationNoteReactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LocationNoteReactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationNoteReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNoteReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationNoteReactions
     * const locationNoteReaction = await prisma.locationNoteReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LocationNoteReactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LocationNoteReactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocationNoteReaction.
     * @param {LocationNoteReactionUpsertArgs} args - Arguments to update or create a LocationNoteReaction.
     * @example
     * // Update or create a LocationNoteReaction
     * const locationNoteReaction = await prisma.locationNoteReaction.upsert({
     *   create: {
     *     // ... data to create a LocationNoteReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationNoteReaction we want to update
     *   }
     * })
    **/
    upsert<T extends LocationNoteReactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LocationNoteReactionUpsertArgs<ExtArgs>>
    ): Prisma__LocationNoteReactionClient<$Result.GetResult<Prisma.$LocationNoteReactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LocationNoteReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNoteReactionCountArgs} args - Arguments to filter LocationNoteReactions to count.
     * @example
     * // Count the number of LocationNoteReactions
     * const count = await prisma.locationNoteReaction.count({
     *   where: {
     *     // ... the filter for the LocationNoteReactions we want to count
     *   }
     * })
    **/
    count<T extends LocationNoteReactionCountArgs>(
      args?: Subset<T, LocationNoteReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationNoteReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationNoteReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNoteReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationNoteReactionAggregateArgs>(args: Subset<T, LocationNoteReactionAggregateArgs>): Prisma.PrismaPromise<GetLocationNoteReactionAggregateType<T>>

    /**
     * Group by LocationNoteReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNoteReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationNoteReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationNoteReactionGroupByArgs['orderBy'] }
        : { orderBy?: LocationNoteReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationNoteReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationNoteReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationNoteReaction model
   */
  readonly fields: LocationNoteReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationNoteReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationNoteReactionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    locationNote<T extends LocationNoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationNoteDefaultArgs<ExtArgs>>): Prisma__LocationNoteClient<$Result.GetResult<Prisma.$LocationNotePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    couriers<T extends CourierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourierDefaultArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LocationNoteReaction model
   */ 
  interface LocationNoteReactionFieldRefs {
    readonly id: FieldRef<"LocationNoteReaction", 'String'>
    readonly reaction: FieldRef<"LocationNoteReaction", 'EnumLocationNoteReactionType'>
    readonly createdAt: FieldRef<"LocationNoteReaction", 'DateTime'>
    readonly updatedAt: FieldRef<"LocationNoteReaction", 'DateTime'>
    readonly locationNoteId: FieldRef<"LocationNoteReaction", 'String'>
    readonly courierId: FieldRef<"LocationNoteReaction", 'String'>
  }
    

  // Custom InputTypes

  /**
   * LocationNoteReaction findUnique
   */
  export type LocationNoteReactionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNoteReaction
     */
    select?: LocationNoteReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteReactionInclude<ExtArgs> | null
    /**
     * Filter, which LocationNoteReaction to fetch.
     */
    where: LocationNoteReactionWhereUniqueInput
  }


  /**
   * LocationNoteReaction findUniqueOrThrow
   */
  export type LocationNoteReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNoteReaction
     */
    select?: LocationNoteReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteReactionInclude<ExtArgs> | null
    /**
     * Filter, which LocationNoteReaction to fetch.
     */
    where: LocationNoteReactionWhereUniqueInput
  }


  /**
   * LocationNoteReaction findFirst
   */
  export type LocationNoteReactionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNoteReaction
     */
    select?: LocationNoteReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteReactionInclude<ExtArgs> | null
    /**
     * Filter, which LocationNoteReaction to fetch.
     */
    where?: LocationNoteReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNoteReactions to fetch.
     */
    orderBy?: LocationNoteReactionOrderByWithRelationAndSearchRelevanceInput | LocationNoteReactionOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationNoteReactions.
     */
    cursor?: LocationNoteReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNoteReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNoteReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationNoteReactions.
     */
    distinct?: LocationNoteReactionScalarFieldEnum | LocationNoteReactionScalarFieldEnum[]
  }


  /**
   * LocationNoteReaction findFirstOrThrow
   */
  export type LocationNoteReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNoteReaction
     */
    select?: LocationNoteReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteReactionInclude<ExtArgs> | null
    /**
     * Filter, which LocationNoteReaction to fetch.
     */
    where?: LocationNoteReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNoteReactions to fetch.
     */
    orderBy?: LocationNoteReactionOrderByWithRelationAndSearchRelevanceInput | LocationNoteReactionOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationNoteReactions.
     */
    cursor?: LocationNoteReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNoteReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNoteReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationNoteReactions.
     */
    distinct?: LocationNoteReactionScalarFieldEnum | LocationNoteReactionScalarFieldEnum[]
  }


  /**
   * LocationNoteReaction findMany
   */
  export type LocationNoteReactionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNoteReaction
     */
    select?: LocationNoteReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteReactionInclude<ExtArgs> | null
    /**
     * Filter, which LocationNoteReactions to fetch.
     */
    where?: LocationNoteReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNoteReactions to fetch.
     */
    orderBy?: LocationNoteReactionOrderByWithRelationAndSearchRelevanceInput | LocationNoteReactionOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationNoteReactions.
     */
    cursor?: LocationNoteReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNoteReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNoteReactions.
     */
    skip?: number
    distinct?: LocationNoteReactionScalarFieldEnum | LocationNoteReactionScalarFieldEnum[]
  }


  /**
   * LocationNoteReaction create
   */
  export type LocationNoteReactionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNoteReaction
     */
    select?: LocationNoteReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a LocationNoteReaction.
     */
    data: XOR<LocationNoteReactionCreateInput, LocationNoteReactionUncheckedCreateInput>
  }


  /**
   * LocationNoteReaction createMany
   */
  export type LocationNoteReactionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationNoteReactions.
     */
    data: LocationNoteReactionCreateManyInput | LocationNoteReactionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LocationNoteReaction update
   */
  export type LocationNoteReactionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNoteReaction
     */
    select?: LocationNoteReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a LocationNoteReaction.
     */
    data: XOR<LocationNoteReactionUpdateInput, LocationNoteReactionUncheckedUpdateInput>
    /**
     * Choose, which LocationNoteReaction to update.
     */
    where: LocationNoteReactionWhereUniqueInput
  }


  /**
   * LocationNoteReaction updateMany
   */
  export type LocationNoteReactionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationNoteReactions.
     */
    data: XOR<LocationNoteReactionUpdateManyMutationInput, LocationNoteReactionUncheckedUpdateManyInput>
    /**
     * Filter which LocationNoteReactions to update
     */
    where?: LocationNoteReactionWhereInput
  }


  /**
   * LocationNoteReaction upsert
   */
  export type LocationNoteReactionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNoteReaction
     */
    select?: LocationNoteReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the LocationNoteReaction to update in case it exists.
     */
    where: LocationNoteReactionWhereUniqueInput
    /**
     * In case the LocationNoteReaction found by the `where` argument doesn't exist, create a new LocationNoteReaction with this data.
     */
    create: XOR<LocationNoteReactionCreateInput, LocationNoteReactionUncheckedCreateInput>
    /**
     * In case the LocationNoteReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationNoteReactionUpdateInput, LocationNoteReactionUncheckedUpdateInput>
  }


  /**
   * LocationNoteReaction delete
   */
  export type LocationNoteReactionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNoteReaction
     */
    select?: LocationNoteReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteReactionInclude<ExtArgs> | null
    /**
     * Filter which LocationNoteReaction to delete.
     */
    where: LocationNoteReactionWhereUniqueInput
  }


  /**
   * LocationNoteReaction deleteMany
   */
  export type LocationNoteReactionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationNoteReactions to delete
     */
    where?: LocationNoteReactionWhereInput
  }


  /**
   * LocationNoteReaction without action
   */
  export type LocationNoteReactionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNoteReaction
     */
    select?: LocationNoteReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LocationNoteReactionInclude<ExtArgs> | null
  }



  /**
   * Model CourierSetting
   */

  export type AggregateCourierSetting = {
    _count: CourierSettingCountAggregateOutputType | null
    _min: CourierSettingMinAggregateOutputType | null
    _max: CourierSettingMaxAggregateOutputType | null
  }

  export type CourierSettingMinAggregateOutputType = {
    id: string | null
    vehicleType: $Enums.EnumSettingVehicleType | null
    deliverySpeed: $Enums.EnumSettingDeliverySpeed | null
    createdAt: Date | null
    updatedAt: Date | null
    courierId: string | null
  }

  export type CourierSettingMaxAggregateOutputType = {
    id: string | null
    vehicleType: $Enums.EnumSettingVehicleType | null
    deliverySpeed: $Enums.EnumSettingDeliverySpeed | null
    createdAt: Date | null
    updatedAt: Date | null
    courierId: string | null
  }

  export type CourierSettingCountAggregateOutputType = {
    id: number
    vehicleType: number
    preferredAreas: number
    shiftAvailability: number
    deliveryPreferences: number
    foodPreferences: number
    earningGoals: number
    deliverySpeed: number
    restaurantTypes: number
    cuisineTypes: number
    preferredRestaurantPartners: number
    dietaryRestrictions: number
    payRate: number
    createdAt: number
    updatedAt: number
    courierId: number
    _all: number
  }


  export type CourierSettingMinAggregateInputType = {
    id?: true
    vehicleType?: true
    deliverySpeed?: true
    createdAt?: true
    updatedAt?: true
    courierId?: true
  }

  export type CourierSettingMaxAggregateInputType = {
    id?: true
    vehicleType?: true
    deliverySpeed?: true
    createdAt?: true
    updatedAt?: true
    courierId?: true
  }

  export type CourierSettingCountAggregateInputType = {
    id?: true
    vehicleType?: true
    preferredAreas?: true
    shiftAvailability?: true
    deliveryPreferences?: true
    foodPreferences?: true
    earningGoals?: true
    deliverySpeed?: true
    restaurantTypes?: true
    cuisineTypes?: true
    preferredRestaurantPartners?: true
    dietaryRestrictions?: true
    payRate?: true
    createdAt?: true
    updatedAt?: true
    courierId?: true
    _all?: true
  }

  export type CourierSettingAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourierSetting to aggregate.
     */
    where?: CourierSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourierSettings to fetch.
     */
    orderBy?: CourierSettingOrderByWithRelationAndSearchRelevanceInput | CourierSettingOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourierSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourierSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourierSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourierSettings
    **/
    _count?: true | CourierSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourierSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourierSettingMaxAggregateInputType
  }

  export type GetCourierSettingAggregateType<T extends CourierSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateCourierSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourierSetting[P]>
      : GetScalarType<T[P], AggregateCourierSetting[P]>
  }




  export type CourierSettingGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CourierSettingWhereInput
    orderBy?: CourierSettingOrderByWithAggregationInput | CourierSettingOrderByWithAggregationInput[]
    by: CourierSettingScalarFieldEnum[] | CourierSettingScalarFieldEnum
    having?: CourierSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourierSettingCountAggregateInputType | true
    _min?: CourierSettingMinAggregateInputType
    _max?: CourierSettingMaxAggregateInputType
  }

  export type CourierSettingGroupByOutputType = {
    id: string
    vehicleType: $Enums.EnumSettingVehicleType | null
    preferredAreas: string[]
    shiftAvailability: JsonValue | null
    deliveryPreferences: string[]
    foodPreferences: string[]
    earningGoals: JsonValue | null
    deliverySpeed: $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes: string[]
    cuisineTypes: string[]
    preferredRestaurantPartners: string[]
    dietaryRestrictions: string[]
    payRate: JsonValue | null
    createdAt: Date
    updatedAt: Date
    courierId: string | null
    _count: CourierSettingCountAggregateOutputType | null
    _min: CourierSettingMinAggregateOutputType | null
    _max: CourierSettingMaxAggregateOutputType | null
  }

  type GetCourierSettingGroupByPayload<T extends CourierSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourierSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourierSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourierSettingGroupByOutputType[P]>
            : GetScalarType<T[P], CourierSettingGroupByOutputType[P]>
        }
      >
    >


  export type CourierSettingSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicleType?: boolean
    preferredAreas?: boolean
    shiftAvailability?: boolean
    deliveryPreferences?: boolean
    foodPreferences?: boolean
    earningGoals?: boolean
    deliverySpeed?: boolean
    restaurantTypes?: boolean
    cuisineTypes?: boolean
    preferredRestaurantPartners?: boolean
    dietaryRestrictions?: boolean
    payRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courierId?: boolean
    couriers?: boolean | CourierSetting$couriersArgs<ExtArgs>
  }, ExtArgs["result"]["courierSetting"]>

  export type CourierSettingSelectScalar = {
    id?: boolean
    vehicleType?: boolean
    preferredAreas?: boolean
    shiftAvailability?: boolean
    deliveryPreferences?: boolean
    foodPreferences?: boolean
    earningGoals?: boolean
    deliverySpeed?: boolean
    restaurantTypes?: boolean
    cuisineTypes?: boolean
    preferredRestaurantPartners?: boolean
    dietaryRestrictions?: boolean
    payRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courierId?: boolean
  }

  export type CourierSettingInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    couriers?: boolean | CourierSetting$couriersArgs<ExtArgs>
  }


  export type $CourierSettingPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "CourierSetting"
    objects: {
      couriers: Prisma.$CourierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      vehicleType: $Enums.EnumSettingVehicleType | null
      preferredAreas: string[]
      shiftAvailability: Prisma.JsonValue | null
      deliveryPreferences: string[]
      foodPreferences: string[]
      earningGoals: Prisma.JsonValue | null
      deliverySpeed: $Enums.EnumSettingDeliverySpeed | null
      restaurantTypes: string[]
      cuisineTypes: string[]
      preferredRestaurantPartners: string[]
      dietaryRestrictions: string[]
      payRate: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      courierId: string | null
    }, ExtArgs["result"]["courierSetting"]>
    composites: {}
  }


  type CourierSettingGetPayload<S extends boolean | null | undefined | CourierSettingDefaultArgs> = $Result.GetResult<Prisma.$CourierSettingPayload, S>

  type CourierSettingCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CourierSettingFindManyArgs, 'select' | 'include'> & {
      select?: CourierSettingCountAggregateInputType | true
    }

  export interface CourierSettingDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourierSetting'], meta: { name: 'CourierSetting' } }
    /**
     * Find zero or one CourierSetting that matches the filter.
     * @param {CourierSettingFindUniqueArgs} args - Arguments to find a CourierSetting
     * @example
     * // Get one CourierSetting
     * const courierSetting = await prisma.courierSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CourierSettingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CourierSettingFindUniqueArgs<ExtArgs>>
    ): Prisma__CourierSettingClient<$Result.GetResult<Prisma.$CourierSettingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CourierSetting that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CourierSettingFindUniqueOrThrowArgs} args - Arguments to find a CourierSetting
     * @example
     * // Get one CourierSetting
     * const courierSetting = await prisma.courierSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CourierSettingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourierSettingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CourierSettingClient<$Result.GetResult<Prisma.$CourierSettingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CourierSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierSettingFindFirstArgs} args - Arguments to find a CourierSetting
     * @example
     * // Get one CourierSetting
     * const courierSetting = await prisma.courierSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CourierSettingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CourierSettingFindFirstArgs<ExtArgs>>
    ): Prisma__CourierSettingClient<$Result.GetResult<Prisma.$CourierSettingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CourierSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierSettingFindFirstOrThrowArgs} args - Arguments to find a CourierSetting
     * @example
     * // Get one CourierSetting
     * const courierSetting = await prisma.courierSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CourierSettingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourierSettingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CourierSettingClient<$Result.GetResult<Prisma.$CourierSettingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CourierSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierSettingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourierSettings
     * const courierSettings = await prisma.courierSetting.findMany()
     * 
     * // Get first 10 CourierSettings
     * const courierSettings = await prisma.courierSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courierSettingWithIdOnly = await prisma.courierSetting.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CourierSettingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourierSettingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierSettingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CourierSetting.
     * @param {CourierSettingCreateArgs} args - Arguments to create a CourierSetting.
     * @example
     * // Create one CourierSetting
     * const CourierSetting = await prisma.courierSetting.create({
     *   data: {
     *     // ... data to create a CourierSetting
     *   }
     * })
     * 
    **/
    create<T extends CourierSettingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CourierSettingCreateArgs<ExtArgs>>
    ): Prisma__CourierSettingClient<$Result.GetResult<Prisma.$CourierSettingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CourierSettings.
     *     @param {CourierSettingCreateManyArgs} args - Arguments to create many CourierSettings.
     *     @example
     *     // Create many CourierSettings
     *     const courierSetting = await prisma.courierSetting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CourierSettingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourierSettingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CourierSetting.
     * @param {CourierSettingDeleteArgs} args - Arguments to delete one CourierSetting.
     * @example
     * // Delete one CourierSetting
     * const CourierSetting = await prisma.courierSetting.delete({
     *   where: {
     *     // ... filter to delete one CourierSetting
     *   }
     * })
     * 
    **/
    delete<T extends CourierSettingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CourierSettingDeleteArgs<ExtArgs>>
    ): Prisma__CourierSettingClient<$Result.GetResult<Prisma.$CourierSettingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CourierSetting.
     * @param {CourierSettingUpdateArgs} args - Arguments to update one CourierSetting.
     * @example
     * // Update one CourierSetting
     * const courierSetting = await prisma.courierSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CourierSettingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CourierSettingUpdateArgs<ExtArgs>>
    ): Prisma__CourierSettingClient<$Result.GetResult<Prisma.$CourierSettingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CourierSettings.
     * @param {CourierSettingDeleteManyArgs} args - Arguments to filter CourierSettings to delete.
     * @example
     * // Delete a few CourierSettings
     * const { count } = await prisma.courierSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CourierSettingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourierSettingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourierSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourierSettings
     * const courierSetting = await prisma.courierSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CourierSettingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CourierSettingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourierSetting.
     * @param {CourierSettingUpsertArgs} args - Arguments to update or create a CourierSetting.
     * @example
     * // Update or create a CourierSetting
     * const courierSetting = await prisma.courierSetting.upsert({
     *   create: {
     *     // ... data to create a CourierSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourierSetting we want to update
     *   }
     * })
    **/
    upsert<T extends CourierSettingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CourierSettingUpsertArgs<ExtArgs>>
    ): Prisma__CourierSettingClient<$Result.GetResult<Prisma.$CourierSettingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CourierSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierSettingCountArgs} args - Arguments to filter CourierSettings to count.
     * @example
     * // Count the number of CourierSettings
     * const count = await prisma.courierSetting.count({
     *   where: {
     *     // ... the filter for the CourierSettings we want to count
     *   }
     * })
    **/
    count<T extends CourierSettingCountArgs>(
      args?: Subset<T, CourierSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourierSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourierSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourierSettingAggregateArgs>(args: Subset<T, CourierSettingAggregateArgs>): Prisma.PrismaPromise<GetCourierSettingAggregateType<T>>

    /**
     * Group by CourierSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourierSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourierSettingGroupByArgs['orderBy'] }
        : { orderBy?: CourierSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourierSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourierSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourierSetting model
   */
  readonly fields: CourierSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourierSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourierSettingClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    couriers<T extends CourierSetting$couriersArgs<ExtArgs> = {}>(args?: Subset<T, CourierSetting$couriersArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CourierSetting model
   */ 
  interface CourierSettingFieldRefs {
    readonly id: FieldRef<"CourierSetting", 'String'>
    readonly vehicleType: FieldRef<"CourierSetting", 'EnumSettingVehicleType'>
    readonly preferredAreas: FieldRef<"CourierSetting", 'String[]'>
    readonly shiftAvailability: FieldRef<"CourierSetting", 'Json'>
    readonly deliveryPreferences: FieldRef<"CourierSetting", 'String[]'>
    readonly foodPreferences: FieldRef<"CourierSetting", 'String[]'>
    readonly earningGoals: FieldRef<"CourierSetting", 'Json'>
    readonly deliverySpeed: FieldRef<"CourierSetting", 'EnumSettingDeliverySpeed'>
    readonly restaurantTypes: FieldRef<"CourierSetting", 'String[]'>
    readonly cuisineTypes: FieldRef<"CourierSetting", 'String[]'>
    readonly preferredRestaurantPartners: FieldRef<"CourierSetting", 'String[]'>
    readonly dietaryRestrictions: FieldRef<"CourierSetting", 'String[]'>
    readonly payRate: FieldRef<"CourierSetting", 'Json'>
    readonly createdAt: FieldRef<"CourierSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"CourierSetting", 'DateTime'>
    readonly courierId: FieldRef<"CourierSetting", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CourierSetting findUnique
   */
  export type CourierSettingFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierSetting
     */
    select?: CourierSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierSettingInclude<ExtArgs> | null
    /**
     * Filter, which CourierSetting to fetch.
     */
    where: CourierSettingWhereUniqueInput
  }


  /**
   * CourierSetting findUniqueOrThrow
   */
  export type CourierSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierSetting
     */
    select?: CourierSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierSettingInclude<ExtArgs> | null
    /**
     * Filter, which CourierSetting to fetch.
     */
    where: CourierSettingWhereUniqueInput
  }


  /**
   * CourierSetting findFirst
   */
  export type CourierSettingFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierSetting
     */
    select?: CourierSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierSettingInclude<ExtArgs> | null
    /**
     * Filter, which CourierSetting to fetch.
     */
    where?: CourierSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourierSettings to fetch.
     */
    orderBy?: CourierSettingOrderByWithRelationAndSearchRelevanceInput | CourierSettingOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourierSettings.
     */
    cursor?: CourierSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourierSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourierSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourierSettings.
     */
    distinct?: CourierSettingScalarFieldEnum | CourierSettingScalarFieldEnum[]
  }


  /**
   * CourierSetting findFirstOrThrow
   */
  export type CourierSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierSetting
     */
    select?: CourierSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierSettingInclude<ExtArgs> | null
    /**
     * Filter, which CourierSetting to fetch.
     */
    where?: CourierSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourierSettings to fetch.
     */
    orderBy?: CourierSettingOrderByWithRelationAndSearchRelevanceInput | CourierSettingOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourierSettings.
     */
    cursor?: CourierSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourierSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourierSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourierSettings.
     */
    distinct?: CourierSettingScalarFieldEnum | CourierSettingScalarFieldEnum[]
  }


  /**
   * CourierSetting findMany
   */
  export type CourierSettingFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierSetting
     */
    select?: CourierSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierSettingInclude<ExtArgs> | null
    /**
     * Filter, which CourierSettings to fetch.
     */
    where?: CourierSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourierSettings to fetch.
     */
    orderBy?: CourierSettingOrderByWithRelationAndSearchRelevanceInput | CourierSettingOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourierSettings.
     */
    cursor?: CourierSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourierSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourierSettings.
     */
    skip?: number
    distinct?: CourierSettingScalarFieldEnum | CourierSettingScalarFieldEnum[]
  }


  /**
   * CourierSetting create
   */
  export type CourierSettingCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierSetting
     */
    select?: CourierSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a CourierSetting.
     */
    data: XOR<CourierSettingCreateInput, CourierSettingUncheckedCreateInput>
  }


  /**
   * CourierSetting createMany
   */
  export type CourierSettingCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourierSettings.
     */
    data: CourierSettingCreateManyInput | CourierSettingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CourierSetting update
   */
  export type CourierSettingUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierSetting
     */
    select?: CourierSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a CourierSetting.
     */
    data: XOR<CourierSettingUpdateInput, CourierSettingUncheckedUpdateInput>
    /**
     * Choose, which CourierSetting to update.
     */
    where: CourierSettingWhereUniqueInput
  }


  /**
   * CourierSetting updateMany
   */
  export type CourierSettingUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourierSettings.
     */
    data: XOR<CourierSettingUpdateManyMutationInput, CourierSettingUncheckedUpdateManyInput>
    /**
     * Filter which CourierSettings to update
     */
    where?: CourierSettingWhereInput
  }


  /**
   * CourierSetting upsert
   */
  export type CourierSettingUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierSetting
     */
    select?: CourierSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the CourierSetting to update in case it exists.
     */
    where: CourierSettingWhereUniqueInput
    /**
     * In case the CourierSetting found by the `where` argument doesn't exist, create a new CourierSetting with this data.
     */
    create: XOR<CourierSettingCreateInput, CourierSettingUncheckedCreateInput>
    /**
     * In case the CourierSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourierSettingUpdateInput, CourierSettingUncheckedUpdateInput>
  }


  /**
   * CourierSetting delete
   */
  export type CourierSettingDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierSetting
     */
    select?: CourierSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierSettingInclude<ExtArgs> | null
    /**
     * Filter which CourierSetting to delete.
     */
    where: CourierSettingWhereUniqueInput
  }


  /**
   * CourierSetting deleteMany
   */
  export type CourierSettingDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourierSettings to delete
     */
    where?: CourierSettingWhereInput
  }


  /**
   * CourierSetting.couriers
   */
  export type CourierSetting$couriersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    where?: CourierWhereInput
  }


  /**
   * CourierSetting without action
   */
  export type CourierSettingDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierSetting
     */
    select?: CourierSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierSettingInclude<ExtArgs> | null
  }



  /**
   * Model Payout
   */

  export type AggregatePayout = {
    _count: PayoutCountAggregateOutputType | null
    _avg: PayoutAvgAggregateOutputType | null
    _sum: PayoutSumAggregateOutputType | null
    _min: PayoutMinAggregateOutputType | null
    _max: PayoutMaxAggregateOutputType | null
  }

  export type PayoutAvgAggregateOutputType = {
    amount: number | null
  }

  export type PayoutSumAggregateOutputType = {
    amount: number | null
  }

  export type PayoutMinAggregateOutputType = {
    id: string | null
    amount: number | null
    arrivalDate: Date | null
    description: string | null
    statementDescriptor: string | null
    status: $Enums.EnumPayoutStatus | null
    paymentId: string | null
    courierId: string | null
  }

  export type PayoutMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    arrivalDate: Date | null
    description: string | null
    statementDescriptor: string | null
    status: $Enums.EnumPayoutStatus | null
    paymentId: string | null
    courierId: string | null
  }

  export type PayoutCountAggregateOutputType = {
    id: number
    amount: number
    arrivalDate: number
    description: number
    statementDescriptor: number
    status: number
    paymentId: number
    courierId: number
    _all: number
  }


  export type PayoutAvgAggregateInputType = {
    amount?: true
  }

  export type PayoutSumAggregateInputType = {
    amount?: true
  }

  export type PayoutMinAggregateInputType = {
    id?: true
    amount?: true
    arrivalDate?: true
    description?: true
    statementDescriptor?: true
    status?: true
    paymentId?: true
    courierId?: true
  }

  export type PayoutMaxAggregateInputType = {
    id?: true
    amount?: true
    arrivalDate?: true
    description?: true
    statementDescriptor?: true
    status?: true
    paymentId?: true
    courierId?: true
  }

  export type PayoutCountAggregateInputType = {
    id?: true
    amount?: true
    arrivalDate?: true
    description?: true
    statementDescriptor?: true
    status?: true
    paymentId?: true
    courierId?: true
    _all?: true
  }

  export type PayoutAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payout to aggregate.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationAndSearchRelevanceInput | PayoutOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payouts
    **/
    _count?: true | PayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayoutMaxAggregateInputType
  }

  export type GetPayoutAggregateType<T extends PayoutAggregateArgs> = {
        [P in keyof T & keyof AggregatePayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayout[P]>
      : GetScalarType<T[P], AggregatePayout[P]>
  }




  export type PayoutGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PayoutWhereInput
    orderBy?: PayoutOrderByWithAggregationInput | PayoutOrderByWithAggregationInput[]
    by: PayoutScalarFieldEnum[] | PayoutScalarFieldEnum
    having?: PayoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayoutCountAggregateInputType | true
    _avg?: PayoutAvgAggregateInputType
    _sum?: PayoutSumAggregateInputType
    _min?: PayoutMinAggregateInputType
    _max?: PayoutMaxAggregateInputType
  }

  export type PayoutGroupByOutputType = {
    id: string
    amount: number
    arrivalDate: Date
    description: string | null
    statementDescriptor: string | null
    status: $Enums.EnumPayoutStatus
    paymentId: string
    courierId: string | null
    _count: PayoutCountAggregateOutputType | null
    _avg: PayoutAvgAggregateOutputType | null
    _sum: PayoutSumAggregateOutputType | null
    _min: PayoutMinAggregateOutputType | null
    _max: PayoutMaxAggregateOutputType | null
  }

  type GetPayoutGroupByPayload<T extends PayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayoutGroupByOutputType[P]>
            : GetScalarType<T[P], PayoutGroupByOutputType[P]>
        }
      >
    >


  export type PayoutSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    arrivalDate?: boolean
    description?: boolean
    statementDescriptor?: boolean
    status?: boolean
    paymentId?: boolean
    courierId?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    courier?: boolean | Payout$courierArgs<ExtArgs>
  }, ExtArgs["result"]["payout"]>

  export type PayoutSelectScalar = {
    id?: boolean
    amount?: boolean
    arrivalDate?: boolean
    description?: boolean
    statementDescriptor?: boolean
    status?: boolean
    paymentId?: boolean
    courierId?: boolean
  }

  export type PayoutInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    courier?: boolean | Payout$courierArgs<ExtArgs>
  }


  export type $PayoutPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Payout"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
      courier: Prisma.$CourierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      amount: number
      arrivalDate: Date
      description: string | null
      statementDescriptor: string | null
      status: $Enums.EnumPayoutStatus
      paymentId: string
      courierId: string | null
    }, ExtArgs["result"]["payout"]>
    composites: {}
  }


  type PayoutGetPayload<S extends boolean | null | undefined | PayoutDefaultArgs> = $Result.GetResult<Prisma.$PayoutPayload, S>

  type PayoutCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PayoutFindManyArgs, 'select' | 'include'> & {
      select?: PayoutCountAggregateInputType | true
    }

  export interface PayoutDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payout'], meta: { name: 'Payout' } }
    /**
     * Find zero or one Payout that matches the filter.
     * @param {PayoutFindUniqueArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PayoutFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PayoutFindUniqueArgs<ExtArgs>>
    ): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Payout that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PayoutFindUniqueOrThrowArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PayoutFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PayoutFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Payout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindFirstArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PayoutFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PayoutFindFirstArgs<ExtArgs>>
    ): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Payout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindFirstOrThrowArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PayoutFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PayoutFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Payouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payouts
     * const payouts = await prisma.payout.findMany()
     * 
     * // Get first 10 Payouts
     * const payouts = await prisma.payout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payoutWithIdOnly = await prisma.payout.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PayoutFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PayoutFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Payout.
     * @param {PayoutCreateArgs} args - Arguments to create a Payout.
     * @example
     * // Create one Payout
     * const Payout = await prisma.payout.create({
     *   data: {
     *     // ... data to create a Payout
     *   }
     * })
     * 
    **/
    create<T extends PayoutCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PayoutCreateArgs<ExtArgs>>
    ): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Payouts.
     *     @param {PayoutCreateManyArgs} args - Arguments to create many Payouts.
     *     @example
     *     // Create many Payouts
     *     const payout = await prisma.payout.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PayoutCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PayoutCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payout.
     * @param {PayoutDeleteArgs} args - Arguments to delete one Payout.
     * @example
     * // Delete one Payout
     * const Payout = await prisma.payout.delete({
     *   where: {
     *     // ... filter to delete one Payout
     *   }
     * })
     * 
    **/
    delete<T extends PayoutDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PayoutDeleteArgs<ExtArgs>>
    ): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Payout.
     * @param {PayoutUpdateArgs} args - Arguments to update one Payout.
     * @example
     * // Update one Payout
     * const payout = await prisma.payout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PayoutUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PayoutUpdateArgs<ExtArgs>>
    ): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Payouts.
     * @param {PayoutDeleteManyArgs} args - Arguments to filter Payouts to delete.
     * @example
     * // Delete a few Payouts
     * const { count } = await prisma.payout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PayoutDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PayoutDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payouts
     * const payout = await prisma.payout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PayoutUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PayoutUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payout.
     * @param {PayoutUpsertArgs} args - Arguments to update or create a Payout.
     * @example
     * // Update or create a Payout
     * const payout = await prisma.payout.upsert({
     *   create: {
     *     // ... data to create a Payout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payout we want to update
     *   }
     * })
    **/
    upsert<T extends PayoutUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PayoutUpsertArgs<ExtArgs>>
    ): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutCountArgs} args - Arguments to filter Payouts to count.
     * @example
     * // Count the number of Payouts
     * const count = await prisma.payout.count({
     *   where: {
     *     // ... the filter for the Payouts we want to count
     *   }
     * })
    **/
    count<T extends PayoutCountArgs>(
      args?: Subset<T, PayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayoutAggregateArgs>(args: Subset<T, PayoutAggregateArgs>): Prisma.PrismaPromise<GetPayoutAggregateType<T>>

    /**
     * Group by Payout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayoutGroupByArgs['orderBy'] }
        : { orderBy?: PayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payout model
   */
  readonly fields: PayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayoutClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    courier<T extends Payout$courierArgs<ExtArgs> = {}>(args?: Subset<T, Payout$courierArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Payout model
   */ 
  interface PayoutFieldRefs {
    readonly id: FieldRef<"Payout", 'String'>
    readonly amount: FieldRef<"Payout", 'Int'>
    readonly arrivalDate: FieldRef<"Payout", 'DateTime'>
    readonly description: FieldRef<"Payout", 'String'>
    readonly statementDescriptor: FieldRef<"Payout", 'String'>
    readonly status: FieldRef<"Payout", 'EnumPayoutStatus'>
    readonly paymentId: FieldRef<"Payout", 'String'>
    readonly courierId: FieldRef<"Payout", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Payout findUnique
   */
  export type PayoutFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where: PayoutWhereUniqueInput
  }


  /**
   * Payout findUniqueOrThrow
   */
  export type PayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where: PayoutWhereUniqueInput
  }


  /**
   * Payout findFirst
   */
  export type PayoutFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationAndSearchRelevanceInput | PayoutOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payouts.
     */
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }


  /**
   * Payout findFirstOrThrow
   */
  export type PayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationAndSearchRelevanceInput | PayoutOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payouts.
     */
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }


  /**
   * Payout findMany
   */
  export type PayoutFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payouts to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationAndSearchRelevanceInput | PayoutOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }


  /**
   * Payout create
   */
  export type PayoutCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * The data needed to create a Payout.
     */
    data: XOR<PayoutCreateInput, PayoutUncheckedCreateInput>
  }


  /**
   * Payout createMany
   */
  export type PayoutCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payouts.
     */
    data: PayoutCreateManyInput | PayoutCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Payout update
   */
  export type PayoutUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * The data needed to update a Payout.
     */
    data: XOR<PayoutUpdateInput, PayoutUncheckedUpdateInput>
    /**
     * Choose, which Payout to update.
     */
    where: PayoutWhereUniqueInput
  }


  /**
   * Payout updateMany
   */
  export type PayoutUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payouts.
     */
    data: XOR<PayoutUpdateManyMutationInput, PayoutUncheckedUpdateManyInput>
    /**
     * Filter which Payouts to update
     */
    where?: PayoutWhereInput
  }


  /**
   * Payout upsert
   */
  export type PayoutUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * The filter to search for the Payout to update in case it exists.
     */
    where: PayoutWhereUniqueInput
    /**
     * In case the Payout found by the `where` argument doesn't exist, create a new Payout with this data.
     */
    create: XOR<PayoutCreateInput, PayoutUncheckedCreateInput>
    /**
     * In case the Payout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayoutUpdateInput, PayoutUncheckedUpdateInput>
  }


  /**
   * Payout delete
   */
  export type PayoutDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter which Payout to delete.
     */
    where: PayoutWhereUniqueInput
  }


  /**
   * Payout deleteMany
   */
  export type PayoutDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payouts to delete
     */
    where?: PayoutWhereInput
  }


  /**
   * Payout.courier
   */
  export type Payout$courierArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    where?: CourierWhereInput
  }


  /**
   * Payout without action
   */
  export type PayoutDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayoutInclude<ExtArgs> | null
  }



  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    capturedAt: Date | null
    canceledAt: Date | null
    amount: Decimal | null
    status: $Enums.EnumPaymentStatus | null
    deliveryId: string | null
    provider: $Enums.EnumPaymentProvider | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    capturedAt: Date | null
    canceledAt: Date | null
    amount: Decimal | null
    status: $Enums.EnumPaymentStatus | null
    deliveryId: string | null
    provider: $Enums.EnumPaymentProvider | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    capturedAt: number
    canceledAt: number
    amount: number
    status: number
    deliveryId: number
    provider: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    capturedAt?: true
    canceledAt?: true
    amount?: true
    status?: true
    deliveryId?: true
    provider?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    capturedAt?: true
    canceledAt?: true
    amount?: true
    status?: true
    deliveryId?: true
    provider?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    capturedAt?: true
    canceledAt?: true
    amount?: true
    status?: true
    deliveryId?: true
    provider?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationAndSearchRelevanceInput | PaymentOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    capturedAt: Date | null
    canceledAt: Date | null
    amount: Decimal
    status: $Enums.EnumPaymentStatus
    deliveryId: string
    provider: $Enums.EnumPaymentProvider
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    capturedAt?: boolean
    canceledAt?: boolean
    amount?: boolean
    status?: boolean
    deliveryId?: boolean
    provider?: boolean
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    transfers?: boolean | Payment$transfersArgs<ExtArgs>
    refunds?: boolean | Payment$refundsArgs<ExtArgs>
    payouts?: boolean | Payment$payoutsArgs<ExtArgs>
    stripeData?: boolean | Payment$stripeDataArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    capturedAt?: boolean
    canceledAt?: boolean
    amount?: boolean
    status?: boolean
    deliveryId?: boolean
    provider?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    transfers?: boolean | Payment$transfersArgs<ExtArgs>
    refunds?: boolean | Payment$refundsArgs<ExtArgs>
    payouts?: boolean | Payment$payoutsArgs<ExtArgs>
    stripeData?: boolean | Payment$stripeDataArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PaymentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      delivery: Prisma.$DeliveryPayload<ExtArgs>
      transfers: Prisma.$TransferPayload<ExtArgs>[]
      refunds: Prisma.$RefundPayload<ExtArgs>[]
      payouts: Prisma.$PayoutPayload<ExtArgs>[]
      stripeData: Prisma.$StripePaymentDataPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      capturedAt: Date | null
      canceledAt: Date | null
      amount: Prisma.Decimal
      status: $Enums.EnumPaymentStatus
      deliveryId: string
      provider: $Enums.EnumPaymentProvider
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }


  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends PaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Payments.
     *     @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends PaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    delivery<T extends DeliveryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryDefaultArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    transfers<T extends Payment$transfersArgs<ExtArgs> = {}>(args?: Subset<T, Payment$transfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, 'findMany'> | Null>;

    refunds<T extends Payment$refundsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$refundsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, 'findMany'> | Null>;

    payouts<T extends Payment$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$payoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, 'findMany'> | Null>;

    stripeData<T extends Payment$stripeDataArgs<ExtArgs> = {}>(args?: Subset<T, Payment$stripeDataArgs<ExtArgs>>): Prisma__StripePaymentDataClient<$Result.GetResult<Prisma.$StripePaymentDataPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly capturedAt: FieldRef<"Payment", 'DateTime'>
    readonly canceledAt: FieldRef<"Payment", 'DateTime'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly status: FieldRef<"Payment", 'EnumPaymentStatus'>
    readonly deliveryId: FieldRef<"Payment", 'String'>
    readonly provider: FieldRef<"Payment", 'EnumPaymentProvider'>
  }
    

  // Custom InputTypes

  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationAndSearchRelevanceInput | PaymentOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationAndSearchRelevanceInput | PaymentOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationAndSearchRelevanceInput | PaymentOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }


  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }


  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment.transfers
   */
  export type Payment$transfersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationAndSearchRelevanceInput | TransferOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }


  /**
   * Payment.refunds
   */
  export type Payment$refundsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefundInclude<ExtArgs> | null
    where?: RefundWhereInput
    orderBy?: RefundOrderByWithRelationAndSearchRelevanceInput | RefundOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: RefundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }


  /**
   * Payment.payouts
   */
  export type Payment$payoutsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayoutInclude<ExtArgs> | null
    where?: PayoutWhereInput
    orderBy?: PayoutOrderByWithRelationAndSearchRelevanceInput | PayoutOrderByWithRelationAndSearchRelevanceInput[]
    cursor?: PayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }


  /**
   * Payment.stripeData
   */
  export type Payment$stripeDataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripePaymentData
     */
    select?: StripePaymentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StripePaymentDataInclude<ExtArgs> | null
    where?: StripePaymentDataWhereInput
  }


  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
  }



  /**
   * Model StripePaymentData
   */

  export type AggregateStripePaymentData = {
    _count: StripePaymentDataCountAggregateOutputType | null
    _min: StripePaymentDataMinAggregateOutputType | null
    _max: StripePaymentDataMaxAggregateOutputType | null
  }

  export type StripePaymentDataMinAggregateOutputType = {
    id: string | null
    paymentIntentId: string | null
    paymentMethodId: string | null
    latestChargeId: string | null
    paymentId: string | null
  }

  export type StripePaymentDataMaxAggregateOutputType = {
    id: string | null
    paymentIntentId: string | null
    paymentMethodId: string | null
    latestChargeId: string | null
    paymentId: string | null
  }

  export type StripePaymentDataCountAggregateOutputType = {
    id: number
    paymentIntentId: number
    paymentMethodId: number
    latestChargeId: number
    paymentId: number
    _all: number
  }


  export type StripePaymentDataMinAggregateInputType = {
    id?: true
    paymentIntentId?: true
    paymentMethodId?: true
    latestChargeId?: true
    paymentId?: true
  }

  export type StripePaymentDataMaxAggregateInputType = {
    id?: true
    paymentIntentId?: true
    paymentMethodId?: true
    latestChargeId?: true
    paymentId?: true
  }

  export type StripePaymentDataCountAggregateInputType = {
    id?: true
    paymentIntentId?: true
    paymentMethodId?: true
    latestChargeId?: true
    paymentId?: true
    _all?: true
  }

  export type StripePaymentDataAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripePaymentData to aggregate.
     */
    where?: StripePaymentDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripePaymentData to fetch.
     */
    orderBy?: StripePaymentDataOrderByWithRelationAndSearchRelevanceInput | StripePaymentDataOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StripePaymentDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripePaymentData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripePaymentData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StripePaymentData
    **/
    _count?: true | StripePaymentDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StripePaymentDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StripePaymentDataMaxAggregateInputType
  }

  export type GetStripePaymentDataAggregateType<T extends StripePaymentDataAggregateArgs> = {
        [P in keyof T & keyof AggregateStripePaymentData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStripePaymentData[P]>
      : GetScalarType<T[P], AggregateStripePaymentData[P]>
  }




  export type StripePaymentDataGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StripePaymentDataWhereInput
    orderBy?: StripePaymentDataOrderByWithAggregationInput | StripePaymentDataOrderByWithAggregationInput[]
    by: StripePaymentDataScalarFieldEnum[] | StripePaymentDataScalarFieldEnum
    having?: StripePaymentDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StripePaymentDataCountAggregateInputType | true
    _min?: StripePaymentDataMinAggregateInputType
    _max?: StripePaymentDataMaxAggregateInputType
  }

  export type StripePaymentDataGroupByOutputType = {
    id: string
    paymentIntentId: string
    paymentMethodId: string
    latestChargeId: string | null
    paymentId: string | null
    _count: StripePaymentDataCountAggregateOutputType | null
    _min: StripePaymentDataMinAggregateOutputType | null
    _max: StripePaymentDataMaxAggregateOutputType | null
  }

  type GetStripePaymentDataGroupByPayload<T extends StripePaymentDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StripePaymentDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StripePaymentDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StripePaymentDataGroupByOutputType[P]>
            : GetScalarType<T[P], StripePaymentDataGroupByOutputType[P]>
        }
      >
    >


  export type StripePaymentDataSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentIntentId?: boolean
    paymentMethodId?: boolean
    latestChargeId?: boolean
    paymentId?: boolean
    payment?: boolean | StripePaymentData$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["stripePaymentData"]>

  export type StripePaymentDataSelectScalar = {
    id?: boolean
    paymentIntentId?: boolean
    paymentMethodId?: boolean
    latestChargeId?: boolean
    paymentId?: boolean
  }

  export type StripePaymentDataInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    payment?: boolean | StripePaymentData$paymentArgs<ExtArgs>
  }


  export type $StripePaymentDataPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "StripePaymentData"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      paymentIntentId: string
      paymentMethodId: string
      latestChargeId: string | null
      paymentId: string | null
    }, ExtArgs["result"]["stripePaymentData"]>
    composites: {}
  }


  type StripePaymentDataGetPayload<S extends boolean | null | undefined | StripePaymentDataDefaultArgs> = $Result.GetResult<Prisma.$StripePaymentDataPayload, S>

  type StripePaymentDataCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StripePaymentDataFindManyArgs, 'select' | 'include'> & {
      select?: StripePaymentDataCountAggregateInputType | true
    }

  export interface StripePaymentDataDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StripePaymentData'], meta: { name: 'StripePaymentData' } }
    /**
     * Find zero or one StripePaymentData that matches the filter.
     * @param {StripePaymentDataFindUniqueArgs} args - Arguments to find a StripePaymentData
     * @example
     * // Get one StripePaymentData
     * const stripePaymentData = await prisma.stripePaymentData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StripePaymentDataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StripePaymentDataFindUniqueArgs<ExtArgs>>
    ): Prisma__StripePaymentDataClient<$Result.GetResult<Prisma.$StripePaymentDataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StripePaymentData that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StripePaymentDataFindUniqueOrThrowArgs} args - Arguments to find a StripePaymentData
     * @example
     * // Get one StripePaymentData
     * const stripePaymentData = await prisma.stripePaymentData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StripePaymentDataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StripePaymentDataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StripePaymentDataClient<$Result.GetResult<Prisma.$StripePaymentDataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StripePaymentData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripePaymentDataFindFirstArgs} args - Arguments to find a StripePaymentData
     * @example
     * // Get one StripePaymentData
     * const stripePaymentData = await prisma.stripePaymentData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StripePaymentDataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StripePaymentDataFindFirstArgs<ExtArgs>>
    ): Prisma__StripePaymentDataClient<$Result.GetResult<Prisma.$StripePaymentDataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StripePaymentData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripePaymentDataFindFirstOrThrowArgs} args - Arguments to find a StripePaymentData
     * @example
     * // Get one StripePaymentData
     * const stripePaymentData = await prisma.stripePaymentData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StripePaymentDataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StripePaymentDataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StripePaymentDataClient<$Result.GetResult<Prisma.$StripePaymentDataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StripePaymentData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripePaymentDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StripePaymentData
     * const stripePaymentData = await prisma.stripePaymentData.findMany()
     * 
     * // Get first 10 StripePaymentData
     * const stripePaymentData = await prisma.stripePaymentData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stripePaymentDataWithIdOnly = await prisma.stripePaymentData.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StripePaymentDataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripePaymentDataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripePaymentDataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StripePaymentData.
     * @param {StripePaymentDataCreateArgs} args - Arguments to create a StripePaymentData.
     * @example
     * // Create one StripePaymentData
     * const StripePaymentData = await prisma.stripePaymentData.create({
     *   data: {
     *     // ... data to create a StripePaymentData
     *   }
     * })
     * 
    **/
    create<T extends StripePaymentDataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StripePaymentDataCreateArgs<ExtArgs>>
    ): Prisma__StripePaymentDataClient<$Result.GetResult<Prisma.$StripePaymentDataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StripePaymentData.
     *     @param {StripePaymentDataCreateManyArgs} args - Arguments to create many StripePaymentData.
     *     @example
     *     // Create many StripePaymentData
     *     const stripePaymentData = await prisma.stripePaymentData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StripePaymentDataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripePaymentDataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StripePaymentData.
     * @param {StripePaymentDataDeleteArgs} args - Arguments to delete one StripePaymentData.
     * @example
     * // Delete one StripePaymentData
     * const StripePaymentData = await prisma.stripePaymentData.delete({
     *   where: {
     *     // ... filter to delete one StripePaymentData
     *   }
     * })
     * 
    **/
    delete<T extends StripePaymentDataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StripePaymentDataDeleteArgs<ExtArgs>>
    ): Prisma__StripePaymentDataClient<$Result.GetResult<Prisma.$StripePaymentDataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StripePaymentData.
     * @param {StripePaymentDataUpdateArgs} args - Arguments to update one StripePaymentData.
     * @example
     * // Update one StripePaymentData
     * const stripePaymentData = await prisma.stripePaymentData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StripePaymentDataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StripePaymentDataUpdateArgs<ExtArgs>>
    ): Prisma__StripePaymentDataClient<$Result.GetResult<Prisma.$StripePaymentDataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StripePaymentData.
     * @param {StripePaymentDataDeleteManyArgs} args - Arguments to filter StripePaymentData to delete.
     * @example
     * // Delete a few StripePaymentData
     * const { count } = await prisma.stripePaymentData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StripePaymentDataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StripePaymentDataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StripePaymentData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripePaymentDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StripePaymentData
     * const stripePaymentData = await prisma.stripePaymentData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StripePaymentDataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StripePaymentDataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StripePaymentData.
     * @param {StripePaymentDataUpsertArgs} args - Arguments to update or create a StripePaymentData.
     * @example
     * // Update or create a StripePaymentData
     * const stripePaymentData = await prisma.stripePaymentData.upsert({
     *   create: {
     *     // ... data to create a StripePaymentData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StripePaymentData we want to update
     *   }
     * })
    **/
    upsert<T extends StripePaymentDataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StripePaymentDataUpsertArgs<ExtArgs>>
    ): Prisma__StripePaymentDataClient<$Result.GetResult<Prisma.$StripePaymentDataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StripePaymentData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripePaymentDataCountArgs} args - Arguments to filter StripePaymentData to count.
     * @example
     * // Count the number of StripePaymentData
     * const count = await prisma.stripePaymentData.count({
     *   where: {
     *     // ... the filter for the StripePaymentData we want to count
     *   }
     * })
    **/
    count<T extends StripePaymentDataCountArgs>(
      args?: Subset<T, StripePaymentDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StripePaymentDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StripePaymentData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripePaymentDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StripePaymentDataAggregateArgs>(args: Subset<T, StripePaymentDataAggregateArgs>): Prisma.PrismaPromise<GetStripePaymentDataAggregateType<T>>

    /**
     * Group by StripePaymentData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripePaymentDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StripePaymentDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StripePaymentDataGroupByArgs['orderBy'] }
        : { orderBy?: StripePaymentDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StripePaymentDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStripePaymentDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StripePaymentData model
   */
  readonly fields: StripePaymentDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StripePaymentData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StripePaymentDataClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    payment<T extends StripePaymentData$paymentArgs<ExtArgs> = {}>(args?: Subset<T, StripePaymentData$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StripePaymentData model
   */ 
  interface StripePaymentDataFieldRefs {
    readonly id: FieldRef<"StripePaymentData", 'String'>
    readonly paymentIntentId: FieldRef<"StripePaymentData", 'String'>
    readonly paymentMethodId: FieldRef<"StripePaymentData", 'String'>
    readonly latestChargeId: FieldRef<"StripePaymentData", 'String'>
    readonly paymentId: FieldRef<"StripePaymentData", 'String'>
  }
    

  // Custom InputTypes

  /**
   * StripePaymentData findUnique
   */
  export type StripePaymentDataFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripePaymentData
     */
    select?: StripePaymentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StripePaymentDataInclude<ExtArgs> | null
    /**
     * Filter, which StripePaymentData to fetch.
     */
    where: StripePaymentDataWhereUniqueInput
  }


  /**
   * StripePaymentData findUniqueOrThrow
   */
  export type StripePaymentDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripePaymentData
     */
    select?: StripePaymentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StripePaymentDataInclude<ExtArgs> | null
    /**
     * Filter, which StripePaymentData to fetch.
     */
    where: StripePaymentDataWhereUniqueInput
  }


  /**
   * StripePaymentData findFirst
   */
  export type StripePaymentDataFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripePaymentData
     */
    select?: StripePaymentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StripePaymentDataInclude<ExtArgs> | null
    /**
     * Filter, which StripePaymentData to fetch.
     */
    where?: StripePaymentDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripePaymentData to fetch.
     */
    orderBy?: StripePaymentDataOrderByWithRelationAndSearchRelevanceInput | StripePaymentDataOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripePaymentData.
     */
    cursor?: StripePaymentDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripePaymentData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripePaymentData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripePaymentData.
     */
    distinct?: StripePaymentDataScalarFieldEnum | StripePaymentDataScalarFieldEnum[]
  }


  /**
   * StripePaymentData findFirstOrThrow
   */
  export type StripePaymentDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripePaymentData
     */
    select?: StripePaymentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StripePaymentDataInclude<ExtArgs> | null
    /**
     * Filter, which StripePaymentData to fetch.
     */
    where?: StripePaymentDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripePaymentData to fetch.
     */
    orderBy?: StripePaymentDataOrderByWithRelationAndSearchRelevanceInput | StripePaymentDataOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripePaymentData.
     */
    cursor?: StripePaymentDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripePaymentData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripePaymentData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripePaymentData.
     */
    distinct?: StripePaymentDataScalarFieldEnum | StripePaymentDataScalarFieldEnum[]
  }


  /**
   * StripePaymentData findMany
   */
  export type StripePaymentDataFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripePaymentData
     */
    select?: StripePaymentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StripePaymentDataInclude<ExtArgs> | null
    /**
     * Filter, which StripePaymentData to fetch.
     */
    where?: StripePaymentDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripePaymentData to fetch.
     */
    orderBy?: StripePaymentDataOrderByWithRelationAndSearchRelevanceInput | StripePaymentDataOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StripePaymentData.
     */
    cursor?: StripePaymentDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripePaymentData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripePaymentData.
     */
    skip?: number
    distinct?: StripePaymentDataScalarFieldEnum | StripePaymentDataScalarFieldEnum[]
  }


  /**
   * StripePaymentData create
   */
  export type StripePaymentDataCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripePaymentData
     */
    select?: StripePaymentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StripePaymentDataInclude<ExtArgs> | null
    /**
     * The data needed to create a StripePaymentData.
     */
    data: XOR<StripePaymentDataCreateInput, StripePaymentDataUncheckedCreateInput>
  }


  /**
   * StripePaymentData createMany
   */
  export type StripePaymentDataCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StripePaymentData.
     */
    data: StripePaymentDataCreateManyInput | StripePaymentDataCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StripePaymentData update
   */
  export type StripePaymentDataUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripePaymentData
     */
    select?: StripePaymentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StripePaymentDataInclude<ExtArgs> | null
    /**
     * The data needed to update a StripePaymentData.
     */
    data: XOR<StripePaymentDataUpdateInput, StripePaymentDataUncheckedUpdateInput>
    /**
     * Choose, which StripePaymentData to update.
     */
    where: StripePaymentDataWhereUniqueInput
  }


  /**
   * StripePaymentData updateMany
   */
  export type StripePaymentDataUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StripePaymentData.
     */
    data: XOR<StripePaymentDataUpdateManyMutationInput, StripePaymentDataUncheckedUpdateManyInput>
    /**
     * Filter which StripePaymentData to update
     */
    where?: StripePaymentDataWhereInput
  }


  /**
   * StripePaymentData upsert
   */
  export type StripePaymentDataUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripePaymentData
     */
    select?: StripePaymentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StripePaymentDataInclude<ExtArgs> | null
    /**
     * The filter to search for the StripePaymentData to update in case it exists.
     */
    where: StripePaymentDataWhereUniqueInput
    /**
     * In case the StripePaymentData found by the `where` argument doesn't exist, create a new StripePaymentData with this data.
     */
    create: XOR<StripePaymentDataCreateInput, StripePaymentDataUncheckedCreateInput>
    /**
     * In case the StripePaymentData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StripePaymentDataUpdateInput, StripePaymentDataUncheckedUpdateInput>
  }


  /**
   * StripePaymentData delete
   */
  export type StripePaymentDataDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripePaymentData
     */
    select?: StripePaymentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StripePaymentDataInclude<ExtArgs> | null
    /**
     * Filter which StripePaymentData to delete.
     */
    where: StripePaymentDataWhereUniqueInput
  }


  /**
   * StripePaymentData deleteMany
   */
  export type StripePaymentDataDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripePaymentData to delete
     */
    where?: StripePaymentDataWhereInput
  }


  /**
   * StripePaymentData.payment
   */
  export type StripePaymentData$paymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }


  /**
   * StripePaymentData without action
   */
  export type StripePaymentDataDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripePaymentData
     */
    select?: StripePaymentDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StripePaymentDataInclude<ExtArgs> | null
  }



  /**
   * Model Transfer
   */

  export type AggregateTransfer = {
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  export type TransferAvgAggregateOutputType = {
    amount: number | null
    amountReversed: number | null
  }

  export type TransferSumAggregateOutputType = {
    amount: number | null
    amountReversed: number | null
  }

  export type TransferMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    transferId: string | null
    amount: number | null
    amountReversed: number | null
    destination: string | null
    destinationPayment: string | null
    reversed: boolean | null
    paymentId: string | null
    courierId: string | null
  }

  export type TransferMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    transferId: string | null
    amount: number | null
    amountReversed: number | null
    destination: string | null
    destinationPayment: string | null
    reversed: boolean | null
    paymentId: string | null
    courierId: string | null
  }

  export type TransferCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    transferId: number
    amount: number
    amountReversed: number
    destination: number
    destinationPayment: number
    reversed: number
    paymentId: number
    courierId: number
    _all: number
  }


  export type TransferAvgAggregateInputType = {
    amount?: true
    amountReversed?: true
  }

  export type TransferSumAggregateInputType = {
    amount?: true
    amountReversed?: true
  }

  export type TransferMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    transferId?: true
    amount?: true
    amountReversed?: true
    destination?: true
    destinationPayment?: true
    reversed?: true
    paymentId?: true
    courierId?: true
  }

  export type TransferMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    transferId?: true
    amount?: true
    amountReversed?: true
    destination?: true
    destinationPayment?: true
    reversed?: true
    paymentId?: true
    courierId?: true
  }

  export type TransferCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    transferId?: true
    amount?: true
    amountReversed?: true
    destination?: true
    destinationPayment?: true
    reversed?: true
    paymentId?: true
    courierId?: true
    _all?: true
  }

  export type TransferAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfer to aggregate.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationAndSearchRelevanceInput | TransferOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transfers
    **/
    _count?: true | TransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferMaxAggregateInputType
  }

  export type GetTransferAggregateType<T extends TransferAggregateArgs> = {
        [P in keyof T & keyof AggregateTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransfer[P]>
      : GetScalarType<T[P], AggregateTransfer[P]>
  }




  export type TransferGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithAggregationInput | TransferOrderByWithAggregationInput[]
    by: TransferScalarFieldEnum[] | TransferScalarFieldEnum
    having?: TransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferCountAggregateInputType | true
    _avg?: TransferAvgAggregateInputType
    _sum?: TransferSumAggregateInputType
    _min?: TransferMinAggregateInputType
    _max?: TransferMaxAggregateInputType
  }

  export type TransferGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    transferId: string
    amount: number
    amountReversed: number
    destination: string
    destinationPayment: string | null
    reversed: boolean
    paymentId: string | null
    courierId: string | null
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  type GetTransferGroupByPayload<T extends TransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferGroupByOutputType[P]>
            : GetScalarType<T[P], TransferGroupByOutputType[P]>
        }
      >
    >


  export type TransferSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transferId?: boolean
    amount?: boolean
    amountReversed?: boolean
    destination?: boolean
    destinationPayment?: boolean
    reversed?: boolean
    paymentId?: boolean
    courierId?: boolean
    payment?: boolean | Transfer$paymentArgs<ExtArgs>
    courier?: boolean | Transfer$courierArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transferId?: boolean
    amount?: boolean
    amountReversed?: boolean
    destination?: boolean
    destinationPayment?: boolean
    reversed?: boolean
    paymentId?: boolean
    courierId?: boolean
  }

  export type TransferInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    payment?: boolean | Transfer$paymentArgs<ExtArgs>
    courier?: boolean | Transfer$courierArgs<ExtArgs>
  }


  export type $TransferPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Transfer"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs> | null
      courier: Prisma.$CourierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      transferId: string
      amount: number
      amountReversed: number
      destination: string
      destinationPayment: string | null
      reversed: boolean
      paymentId: string | null
      courierId: string | null
    }, ExtArgs["result"]["transfer"]>
    composites: {}
  }


  type TransferGetPayload<S extends boolean | null | undefined | TransferDefaultArgs> = $Result.GetResult<Prisma.$TransferPayload, S>

  type TransferCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TransferFindManyArgs, 'select' | 'include'> & {
      select?: TransferCountAggregateInputType | true
    }

  export interface TransferDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transfer'], meta: { name: 'Transfer' } }
    /**
     * Find zero or one Transfer that matches the filter.
     * @param {TransferFindUniqueArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransferFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TransferFindUniqueArgs<ExtArgs>>
    ): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Transfer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TransferFindUniqueOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TransferFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransferFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferFindFirstArgs<ExtArgs>>
    ): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Transfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TransferFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transfers
     * const transfers = await prisma.transfer.findMany()
     * 
     * // Get first 10 Transfers
     * const transfers = await prisma.transfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferWithIdOnly = await prisma.transfer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TransferFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Transfer.
     * @param {TransferCreateArgs} args - Arguments to create a Transfer.
     * @example
     * // Create one Transfer
     * const Transfer = await prisma.transfer.create({
     *   data: {
     *     // ... data to create a Transfer
     *   }
     * })
     * 
    **/
    create<T extends TransferCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TransferCreateArgs<ExtArgs>>
    ): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Transfers.
     *     @param {TransferCreateManyArgs} args - Arguments to create many Transfers.
     *     @example
     *     // Create many Transfers
     *     const transfer = await prisma.transfer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TransferCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transfer.
     * @param {TransferDeleteArgs} args - Arguments to delete one Transfer.
     * @example
     * // Delete one Transfer
     * const Transfer = await prisma.transfer.delete({
     *   where: {
     *     // ... filter to delete one Transfer
     *   }
     * })
     * 
    **/
    delete<T extends TransferDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TransferDeleteArgs<ExtArgs>>
    ): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Transfer.
     * @param {TransferUpdateArgs} args - Arguments to update one Transfer.
     * @example
     * // Update one Transfer
     * const transfer = await prisma.transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TransferUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TransferUpdateArgs<ExtArgs>>
    ): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Transfers.
     * @param {TransferDeleteManyArgs} args - Arguments to filter Transfers to delete.
     * @example
     * // Delete a few Transfers
     * const { count } = await prisma.transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TransferDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransferDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TransferUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TransferUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transfer.
     * @param {TransferUpsertArgs} args - Arguments to update or create a Transfer.
     * @example
     * // Update or create a Transfer
     * const transfer = await prisma.transfer.upsert({
     *   create: {
     *     // ... data to create a Transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transfer we want to update
     *   }
     * })
    **/
    upsert<T extends TransferUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TransferUpsertArgs<ExtArgs>>
    ): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferCountArgs} args - Arguments to filter Transfers to count.
     * @example
     * // Count the number of Transfers
     * const count = await prisma.transfer.count({
     *   where: {
     *     // ... the filter for the Transfers we want to count
     *   }
     * })
    **/
    count<T extends TransferCountArgs>(
      args?: Subset<T, TransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferAggregateArgs>(args: Subset<T, TransferAggregateArgs>): Prisma.PrismaPromise<GetTransferAggregateType<T>>

    /**
     * Group by Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferGroupByArgs['orderBy'] }
        : { orderBy?: TransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transfer model
   */
  readonly fields: TransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    payment<T extends Transfer$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    courier<T extends Transfer$courierArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$courierArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Transfer model
   */ 
  interface TransferFieldRefs {
    readonly id: FieldRef<"Transfer", 'String'>
    readonly createdAt: FieldRef<"Transfer", 'DateTime'>
    readonly updatedAt: FieldRef<"Transfer", 'DateTime'>
    readonly transferId: FieldRef<"Transfer", 'String'>
    readonly amount: FieldRef<"Transfer", 'Int'>
    readonly amountReversed: FieldRef<"Transfer", 'Int'>
    readonly destination: FieldRef<"Transfer", 'String'>
    readonly destinationPayment: FieldRef<"Transfer", 'String'>
    readonly reversed: FieldRef<"Transfer", 'Boolean'>
    readonly paymentId: FieldRef<"Transfer", 'String'>
    readonly courierId: FieldRef<"Transfer", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Transfer findUnique
   */
  export type TransferFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }


  /**
   * Transfer findUniqueOrThrow
   */
  export type TransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }


  /**
   * Transfer findFirst
   */
  export type TransferFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationAndSearchRelevanceInput | TransferOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }


  /**
   * Transfer findFirstOrThrow
   */
  export type TransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationAndSearchRelevanceInput | TransferOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }


  /**
   * Transfer findMany
   */
  export type TransferFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfers to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationAndSearchRelevanceInput | TransferOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }


  /**
   * Transfer create
   */
  export type TransferCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to create a Transfer.
     */
    data: XOR<TransferCreateInput, TransferUncheckedCreateInput>
  }


  /**
   * Transfer createMany
   */
  export type TransferCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Transfer update
   */
  export type TransferUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to update a Transfer.
     */
    data: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
    /**
     * Choose, which Transfer to update.
     */
    where: TransferWhereUniqueInput
  }


  /**
   * Transfer updateMany
   */
  export type TransferUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
  }


  /**
   * Transfer upsert
   */
  export type TransferUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The filter to search for the Transfer to update in case it exists.
     */
    where: TransferWhereUniqueInput
    /**
     * In case the Transfer found by the `where` argument doesn't exist, create a new Transfer with this data.
     */
    create: XOR<TransferCreateInput, TransferUncheckedCreateInput>
    /**
     * In case the Transfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
  }


  /**
   * Transfer delete
   */
  export type TransferDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter which Transfer to delete.
     */
    where: TransferWhereUniqueInput
  }


  /**
   * Transfer deleteMany
   */
  export type TransferDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfers to delete
     */
    where?: TransferWhereInput
  }


  /**
   * Transfer.payment
   */
  export type Transfer$paymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }


  /**
   * Transfer.courier
   */
  export type Transfer$courierArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourierInclude<ExtArgs> | null
    where?: CourierWhereInput
  }


  /**
   * Transfer without action
   */
  export type TransferDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransferInclude<ExtArgs> | null
  }



  /**
   * Model Refund
   */

  export type AggregateRefund = {
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  export type RefundAvgAggregateOutputType = {
    amount: number | null
  }

  export type RefundSumAggregateOutputType = {
    amount: number | null
  }

  export type RefundMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    refundId: string | null
    amount: number | null
    description: string | null
    reason: $Enums.EnumRefundReason | null
    status: $Enums.EnumRefundStatus | null
    paymentId: string | null
  }

  export type RefundMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    refundId: string | null
    amount: number | null
    description: string | null
    reason: $Enums.EnumRefundReason | null
    status: $Enums.EnumRefundStatus | null
    paymentId: string | null
  }

  export type RefundCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    refundId: number
    amount: number
    description: number
    reason: number
    status: number
    paymentId: number
    _all: number
  }


  export type RefundAvgAggregateInputType = {
    amount?: true
  }

  export type RefundSumAggregateInputType = {
    amount?: true
  }

  export type RefundMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    refundId?: true
    amount?: true
    description?: true
    reason?: true
    status?: true
    paymentId?: true
  }

  export type RefundMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    refundId?: true
    amount?: true
    description?: true
    reason?: true
    status?: true
    paymentId?: true
  }

  export type RefundCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    refundId?: true
    amount?: true
    description?: true
    reason?: true
    status?: true
    paymentId?: true
    _all?: true
  }

  export type RefundAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refund to aggregate.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationAndSearchRelevanceInput | RefundOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Refunds
    **/
    _count?: true | RefundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefundMaxAggregateInputType
  }

  export type GetRefundAggregateType<T extends RefundAggregateArgs> = {
        [P in keyof T & keyof AggregateRefund]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefund[P]>
      : GetScalarType<T[P], AggregateRefund[P]>
  }




  export type RefundGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput
    orderBy?: RefundOrderByWithAggregationInput | RefundOrderByWithAggregationInput[]
    by: RefundScalarFieldEnum[] | RefundScalarFieldEnum
    having?: RefundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefundCountAggregateInputType | true
    _avg?: RefundAvgAggregateInputType
    _sum?: RefundSumAggregateInputType
    _min?: RefundMinAggregateInputType
    _max?: RefundMaxAggregateInputType
  }

  export type RefundGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    refundId: string | null
    amount: number
    description: string | null
    reason: $Enums.EnumRefundReason | null
    status: $Enums.EnumRefundStatus | null
    paymentId: string
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  type GetRefundGroupByPayload<T extends RefundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefundGroupByOutputType[P]>
            : GetScalarType<T[P], RefundGroupByOutputType[P]>
        }
      >
    >


  export type RefundSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refundId?: boolean
    amount?: boolean
    description?: boolean
    reason?: boolean
    status?: boolean
    paymentId?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refundId?: boolean
    amount?: boolean
    description?: boolean
    reason?: boolean
    status?: boolean
    paymentId?: boolean
  }

  export type RefundInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }


  export type $RefundPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Refund"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      refundId: string | null
      amount: number
      description: string | null
      reason: $Enums.EnumRefundReason | null
      status: $Enums.EnumRefundStatus | null
      paymentId: string
    }, ExtArgs["result"]["refund"]>
    composites: {}
  }


  type RefundGetPayload<S extends boolean | null | undefined | RefundDefaultArgs> = $Result.GetResult<Prisma.$RefundPayload, S>

  type RefundCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<RefundFindManyArgs, 'select' | 'include'> & {
      select?: RefundCountAggregateInputType | true
    }

  export interface RefundDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Refund'], meta: { name: 'Refund' } }
    /**
     * Find zero or one Refund that matches the filter.
     * @param {RefundFindUniqueArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RefundFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RefundFindUniqueArgs<ExtArgs>>
    ): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Refund that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RefundFindUniqueOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RefundFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RefundFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Refund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RefundFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RefundFindFirstArgs<ExtArgs>>
    ): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Refund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RefundFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RefundFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Refunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refunds
     * const refunds = await prisma.refund.findMany()
     * 
     * // Get first 10 Refunds
     * const refunds = await prisma.refund.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refundWithIdOnly = await prisma.refund.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RefundFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RefundFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Refund.
     * @param {RefundCreateArgs} args - Arguments to create a Refund.
     * @example
     * // Create one Refund
     * const Refund = await prisma.refund.create({
     *   data: {
     *     // ... data to create a Refund
     *   }
     * })
     * 
    **/
    create<T extends RefundCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RefundCreateArgs<ExtArgs>>
    ): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Refunds.
     *     @param {RefundCreateManyArgs} args - Arguments to create many Refunds.
     *     @example
     *     // Create many Refunds
     *     const refund = await prisma.refund.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RefundCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RefundCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Refund.
     * @param {RefundDeleteArgs} args - Arguments to delete one Refund.
     * @example
     * // Delete one Refund
     * const Refund = await prisma.refund.delete({
     *   where: {
     *     // ... filter to delete one Refund
     *   }
     * })
     * 
    **/
    delete<T extends RefundDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RefundDeleteArgs<ExtArgs>>
    ): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Refund.
     * @param {RefundUpdateArgs} args - Arguments to update one Refund.
     * @example
     * // Update one Refund
     * const refund = await prisma.refund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RefundUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RefundUpdateArgs<ExtArgs>>
    ): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Refunds.
     * @param {RefundDeleteManyArgs} args - Arguments to filter Refunds to delete.
     * @example
     * // Delete a few Refunds
     * const { count } = await prisma.refund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RefundDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RefundDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refunds
     * const refund = await prisma.refund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RefundUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RefundUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Refund.
     * @param {RefundUpsertArgs} args - Arguments to update or create a Refund.
     * @example
     * // Update or create a Refund
     * const refund = await prisma.refund.upsert({
     *   create: {
     *     // ... data to create a Refund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refund we want to update
     *   }
     * })
    **/
    upsert<T extends RefundUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RefundUpsertArgs<ExtArgs>>
    ): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundCountArgs} args - Arguments to filter Refunds to count.
     * @example
     * // Count the number of Refunds
     * const count = await prisma.refund.count({
     *   where: {
     *     // ... the filter for the Refunds we want to count
     *   }
     * })
    **/
    count<T extends RefundCountArgs>(
      args?: Subset<T, RefundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefundAggregateArgs>(args: Subset<T, RefundAggregateArgs>): Prisma.PrismaPromise<GetRefundAggregateType<T>>

    /**
     * Group by Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefundGroupByArgs['orderBy'] }
        : { orderBy?: RefundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Refund model
   */
  readonly fields: RefundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Refund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefundClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Refund model
   */ 
  interface RefundFieldRefs {
    readonly id: FieldRef<"Refund", 'String'>
    readonly createdAt: FieldRef<"Refund", 'DateTime'>
    readonly updatedAt: FieldRef<"Refund", 'DateTime'>
    readonly refundId: FieldRef<"Refund", 'String'>
    readonly amount: FieldRef<"Refund", 'Int'>
    readonly description: FieldRef<"Refund", 'String'>
    readonly reason: FieldRef<"Refund", 'EnumRefundReason'>
    readonly status: FieldRef<"Refund", 'EnumRefundStatus'>
    readonly paymentId: FieldRef<"Refund", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Refund findUnique
   */
  export type RefundFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput
  }


  /**
   * Refund findUniqueOrThrow
   */
  export type RefundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput
  }


  /**
   * Refund findFirst
   */
  export type RefundFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationAndSearchRelevanceInput | RefundOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }


  /**
   * Refund findFirstOrThrow
   */
  export type RefundFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationAndSearchRelevanceInput | RefundOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }


  /**
   * Refund findMany
   */
  export type RefundFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refunds to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationAndSearchRelevanceInput | RefundOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }


  /**
   * Refund create
   */
  export type RefundCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The data needed to create a Refund.
     */
    data: XOR<RefundCreateInput, RefundUncheckedCreateInput>
  }


  /**
   * Refund createMany
   */
  export type RefundCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Refund update
   */
  export type RefundUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The data needed to update a Refund.
     */
    data: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>
    /**
     * Choose, which Refund to update.
     */
    where: RefundWhereUniqueInput
  }


  /**
   * Refund updateMany
   */
  export type RefundUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Refunds.
     */
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyInput>
    /**
     * Filter which Refunds to update
     */
    where?: RefundWhereInput
  }


  /**
   * Refund upsert
   */
  export type RefundUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The filter to search for the Refund to update in case it exists.
     */
    where: RefundWhereUniqueInput
    /**
     * In case the Refund found by the `where` argument doesn't exist, create a new Refund with this data.
     */
    create: XOR<RefundCreateInput, RefundUncheckedCreateInput>
    /**
     * In case the Refund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>
  }


  /**
   * Refund delete
   */
  export type RefundDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter which Refund to delete.
     */
    where: RefundWhereUniqueInput
  }


  /**
   * Refund deleteMany
   */
  export type RefundDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refunds to delete
     */
    where?: RefundWhereInput
  }


  /**
   * Refund without action
   */
  export type RefundDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefundInclude<ExtArgs> | null
  }



  /**
   * Model Config
   */

  export type AggregateConfig = {
    _count: ConfigCountAggregateOutputType | null
    _min: ConfigMinAggregateOutputType | null
    _max: ConfigMaxAggregateOutputType | null
  }

  export type ConfigMinAggregateOutputType = {
    key: string | null
    type: string | null
    value: string | null
  }

  export type ConfigMaxAggregateOutputType = {
    key: string | null
    type: string | null
    value: string | null
  }

  export type ConfigCountAggregateOutputType = {
    key: number
    type: number
    value: number
    _all: number
  }


  export type ConfigMinAggregateInputType = {
    key?: true
    type?: true
    value?: true
  }

  export type ConfigMaxAggregateInputType = {
    key?: true
    type?: true
    value?: true
  }

  export type ConfigCountAggregateInputType = {
    key?: true
    type?: true
    value?: true
    _all?: true
  }

  export type ConfigAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Config to aggregate.
     */
    where?: ConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configs to fetch.
     */
    orderBy?: ConfigOrderByWithRelationAndSearchRelevanceInput | ConfigOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Configs
    **/
    _count?: true | ConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigMaxAggregateInputType
  }

  export type GetConfigAggregateType<T extends ConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfig[P]>
      : GetScalarType<T[P], AggregateConfig[P]>
  }




  export type ConfigGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConfigWhereInput
    orderBy?: ConfigOrderByWithAggregationInput | ConfigOrderByWithAggregationInput[]
    by: ConfigScalarFieldEnum[] | ConfigScalarFieldEnum
    having?: ConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigCountAggregateInputType | true
    _min?: ConfigMinAggregateInputType
    _max?: ConfigMaxAggregateInputType
  }

  export type ConfigGroupByOutputType = {
    key: string
    type: string
    value: string
    _count: ConfigCountAggregateOutputType | null
    _min: ConfigMinAggregateOutputType | null
    _max: ConfigMaxAggregateOutputType | null
  }

  type GetConfigGroupByPayload<T extends ConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigGroupByOutputType[P]>
        }
      >
    >


  export type ConfigSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    type?: boolean
    value?: boolean
  }, ExtArgs["result"]["config"]>

  export type ConfigSelectScalar = {
    key?: boolean
    type?: boolean
    value?: boolean
  }


  export type $ConfigPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Config"
    objects: {}
    scalars: $Extensions.GetResult<{
      key: string
      type: string
      value: string
    }, ExtArgs["result"]["config"]>
    composites: {}
  }


  type ConfigGetPayload<S extends boolean | null | undefined | ConfigDefaultArgs> = $Result.GetResult<Prisma.$ConfigPayload, S>

  type ConfigCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ConfigFindManyArgs, 'select' | 'include'> & {
      select?: ConfigCountAggregateInputType | true
    }

  export interface ConfigDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Config'], meta: { name: 'Config' } }
    /**
     * Find zero or one Config that matches the filter.
     * @param {ConfigFindUniqueArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConfigFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConfigFindUniqueArgs<ExtArgs>>
    ): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Config that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConfigFindUniqueOrThrowArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConfigFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfigFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigFindFirstArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConfigFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfigFindFirstArgs<ExtArgs>>
    ): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigFindFirstOrThrowArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConfigFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfigFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configs
     * const configs = await prisma.config.findMany()
     * 
     * // Get first 10 Configs
     * const configs = await prisma.config.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const configWithKeyOnly = await prisma.config.findMany({ select: { key: true } })
     * 
    **/
    findMany<T extends ConfigFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfigFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Config.
     * @param {ConfigCreateArgs} args - Arguments to create a Config.
     * @example
     * // Create one Config
     * const Config = await prisma.config.create({
     *   data: {
     *     // ... data to create a Config
     *   }
     * })
     * 
    **/
    create<T extends ConfigCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConfigCreateArgs<ExtArgs>>
    ): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Configs.
     *     @param {ConfigCreateManyArgs} args - Arguments to create many Configs.
     *     @example
     *     // Create many Configs
     *     const config = await prisma.config.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConfigCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfigCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Config.
     * @param {ConfigDeleteArgs} args - Arguments to delete one Config.
     * @example
     * // Delete one Config
     * const Config = await prisma.config.delete({
     *   where: {
     *     // ... filter to delete one Config
     *   }
     * })
     * 
    **/
    delete<T extends ConfigDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConfigDeleteArgs<ExtArgs>>
    ): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Config.
     * @param {ConfigUpdateArgs} args - Arguments to update one Config.
     * @example
     * // Update one Config
     * const config = await prisma.config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConfigUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConfigUpdateArgs<ExtArgs>>
    ): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Configs.
     * @param {ConfigDeleteManyArgs} args - Arguments to filter Configs to delete.
     * @example
     * // Delete a few Configs
     * const { count } = await prisma.config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConfigDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConfigDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configs
     * const config = await prisma.config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConfigUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConfigUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Config.
     * @param {ConfigUpsertArgs} args - Arguments to update or create a Config.
     * @example
     * // Update or create a Config
     * const config = await prisma.config.upsert({
     *   create: {
     *     // ... data to create a Config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Config we want to update
     *   }
     * })
    **/
    upsert<T extends ConfigUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConfigUpsertArgs<ExtArgs>>
    ): Prisma__ConfigClient<$Result.GetResult<Prisma.$ConfigPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigCountArgs} args - Arguments to filter Configs to count.
     * @example
     * // Count the number of Configs
     * const count = await prisma.config.count({
     *   where: {
     *     // ... the filter for the Configs we want to count
     *   }
     * })
    **/
    count<T extends ConfigCountArgs>(
      args?: Subset<T, ConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigAggregateArgs>(args: Subset<T, ConfigAggregateArgs>): Prisma.PrismaPromise<GetConfigAggregateType<T>>

    /**
     * Group by Config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigGroupByArgs['orderBy'] }
        : { orderBy?: ConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Config model
   */
  readonly fields: ConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Config model
   */ 
  interface ConfigFieldRefs {
    readonly key: FieldRef<"Config", 'String'>
    readonly type: FieldRef<"Config", 'String'>
    readonly value: FieldRef<"Config", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Config findUnique
   */
  export type ConfigFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Filter, which Config to fetch.
     */
    where: ConfigWhereUniqueInput
  }


  /**
   * Config findUniqueOrThrow
   */
  export type ConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Filter, which Config to fetch.
     */
    where: ConfigWhereUniqueInput
  }


  /**
   * Config findFirst
   */
  export type ConfigFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Filter, which Config to fetch.
     */
    where?: ConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configs to fetch.
     */
    orderBy?: ConfigOrderByWithRelationAndSearchRelevanceInput | ConfigOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configs.
     */
    cursor?: ConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configs.
     */
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }


  /**
   * Config findFirstOrThrow
   */
  export type ConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Filter, which Config to fetch.
     */
    where?: ConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configs to fetch.
     */
    orderBy?: ConfigOrderByWithRelationAndSearchRelevanceInput | ConfigOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configs.
     */
    cursor?: ConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configs.
     */
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }


  /**
   * Config findMany
   */
  export type ConfigFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Filter, which Configs to fetch.
     */
    where?: ConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configs to fetch.
     */
    orderBy?: ConfigOrderByWithRelationAndSearchRelevanceInput | ConfigOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Configs.
     */
    cursor?: ConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configs.
     */
    skip?: number
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }


  /**
   * Config create
   */
  export type ConfigCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a Config.
     */
    data: XOR<ConfigCreateInput, ConfigUncheckedCreateInput>
  }


  /**
   * Config createMany
   */
  export type ConfigCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Configs.
     */
    data: ConfigCreateManyInput | ConfigCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Config update
   */
  export type ConfigUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a Config.
     */
    data: XOR<ConfigUpdateInput, ConfigUncheckedUpdateInput>
    /**
     * Choose, which Config to update.
     */
    where: ConfigWhereUniqueInput
  }


  /**
   * Config updateMany
   */
  export type ConfigUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Configs.
     */
    data: XOR<ConfigUpdateManyMutationInput, ConfigUncheckedUpdateManyInput>
    /**
     * Filter which Configs to update
     */
    where?: ConfigWhereInput
  }


  /**
   * Config upsert
   */
  export type ConfigUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the Config to update in case it exists.
     */
    where: ConfigWhereUniqueInput
    /**
     * In case the Config found by the `where` argument doesn't exist, create a new Config with this data.
     */
    create: XOR<ConfigCreateInput, ConfigUncheckedCreateInput>
    /**
     * In case the Config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigUpdateInput, ConfigUncheckedUpdateInput>
  }


  /**
   * Config delete
   */
  export type ConfigDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
    /**
     * Filter which Config to delete.
     */
    where: ConfigWhereUniqueInput
  }


  /**
   * Config deleteMany
   */
  export type ConfigDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configs to delete
     */
    where?: ConfigWhereInput
  }


  /**
   * Config without action
   */
  export type ConfigDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Config
     */
    select?: ConfigSelect<ExtArgs> | null
  }



  /**
   * Model spatial_ref_sys
   */

  export type AggregateSpatial_ref_sys = {
    _count: Spatial_ref_sysCountAggregateOutputType | null
    _avg: Spatial_ref_sysAvgAggregateOutputType | null
    _sum: Spatial_ref_sysSumAggregateOutputType | null
    _min: Spatial_ref_sysMinAggregateOutputType | null
    _max: Spatial_ref_sysMaxAggregateOutputType | null
  }

  export type Spatial_ref_sysAvgAggregateOutputType = {
    srid: number | null
    auth_srid: number | null
  }

  export type Spatial_ref_sysSumAggregateOutputType = {
    srid: number | null
    auth_srid: number | null
  }

  export type Spatial_ref_sysMinAggregateOutputType = {
    srid: number | null
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
  }

  export type Spatial_ref_sysMaxAggregateOutputType = {
    srid: number | null
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
  }

  export type Spatial_ref_sysCountAggregateOutputType = {
    srid: number
    auth_name: number
    auth_srid: number
    srtext: number
    proj4text: number
    _all: number
  }


  export type Spatial_ref_sysAvgAggregateInputType = {
    srid?: true
    auth_srid?: true
  }

  export type Spatial_ref_sysSumAggregateInputType = {
    srid?: true
    auth_srid?: true
  }

  export type Spatial_ref_sysMinAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
  }

  export type Spatial_ref_sysMaxAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
  }

  export type Spatial_ref_sysCountAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
    _all?: true
  }

  export type Spatial_ref_sysAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which spatial_ref_sys to aggregate.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationAndSearchRelevanceInput | spatial_ref_sysOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned spatial_ref_sys
    **/
    _count?: true | Spatial_ref_sysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Spatial_ref_sysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Spatial_ref_sysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Spatial_ref_sysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Spatial_ref_sysMaxAggregateInputType
  }

  export type GetSpatial_ref_sysAggregateType<T extends Spatial_ref_sysAggregateArgs> = {
        [P in keyof T & keyof AggregateSpatial_ref_sys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpatial_ref_sys[P]>
      : GetScalarType<T[P], AggregateSpatial_ref_sys[P]>
  }




  export type spatial_ref_sysGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: spatial_ref_sysWhereInput
    orderBy?: spatial_ref_sysOrderByWithAggregationInput | spatial_ref_sysOrderByWithAggregationInput[]
    by: Spatial_ref_sysScalarFieldEnum[] | Spatial_ref_sysScalarFieldEnum
    having?: spatial_ref_sysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Spatial_ref_sysCountAggregateInputType | true
    _avg?: Spatial_ref_sysAvgAggregateInputType
    _sum?: Spatial_ref_sysSumAggregateInputType
    _min?: Spatial_ref_sysMinAggregateInputType
    _max?: Spatial_ref_sysMaxAggregateInputType
  }

  export type Spatial_ref_sysGroupByOutputType = {
    srid: number
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
    _count: Spatial_ref_sysCountAggregateOutputType | null
    _avg: Spatial_ref_sysAvgAggregateOutputType | null
    _sum: Spatial_ref_sysSumAggregateOutputType | null
    _min: Spatial_ref_sysMinAggregateOutputType | null
    _max: Spatial_ref_sysMaxAggregateOutputType | null
  }

  type GetSpatial_ref_sysGroupByPayload<T extends spatial_ref_sysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Spatial_ref_sysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Spatial_ref_sysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Spatial_ref_sysGroupByOutputType[P]>
            : GetScalarType<T[P], Spatial_ref_sysGroupByOutputType[P]>
        }
      >
    >


  export type spatial_ref_sysSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }, ExtArgs["result"]["spatial_ref_sys"]>

  export type spatial_ref_sysSelectScalar = {
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }


  export type $spatial_ref_sysPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "spatial_ref_sys"
    objects: {}
    scalars: $Extensions.GetResult<{
      srid: number
      auth_name: string | null
      auth_srid: number | null
      srtext: string | null
      proj4text: string | null
    }, ExtArgs["result"]["spatial_ref_sys"]>
    composites: {}
  }


  type spatial_ref_sysGetPayload<S extends boolean | null | undefined | spatial_ref_sysDefaultArgs> = $Result.GetResult<Prisma.$spatial_ref_sysPayload, S>

  type spatial_ref_sysCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<spatial_ref_sysFindManyArgs, 'select' | 'include'> & {
      select?: Spatial_ref_sysCountAggregateInputType | true
    }

  export interface spatial_ref_sysDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['spatial_ref_sys'], meta: { name: 'spatial_ref_sys' } }
    /**
     * Find zero or one Spatial_ref_sys that matches the filter.
     * @param {spatial_ref_sysFindUniqueArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends spatial_ref_sysFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, spatial_ref_sysFindUniqueArgs<ExtArgs>>
    ): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Spatial_ref_sys that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {spatial_ref_sysFindUniqueOrThrowArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Spatial_ref_sys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindFirstArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends spatial_ref_sysFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, spatial_ref_sysFindFirstArgs<ExtArgs>>
    ): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Spatial_ref_sys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindFirstOrThrowArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends spatial_ref_sysFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, spatial_ref_sysFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Spatial_ref_sys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany()
     * 
     * // Get first 10 Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany({ take: 10 })
     * 
     * // Only select the `srid`
     * const spatial_ref_sysWithSridOnly = await prisma.spatial_ref_sys.findMany({ select: { srid: true } })
     * 
    **/
    findMany<T extends spatial_ref_sysFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, spatial_ref_sysFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Spatial_ref_sys.
     * @param {spatial_ref_sysCreateArgs} args - Arguments to create a Spatial_ref_sys.
     * @example
     * // Create one Spatial_ref_sys
     * const Spatial_ref_sys = await prisma.spatial_ref_sys.create({
     *   data: {
     *     // ... data to create a Spatial_ref_sys
     *   }
     * })
     * 
    **/
    create<T extends spatial_ref_sysCreateArgs<ExtArgs>>(
      args: SelectSubset<T, spatial_ref_sysCreateArgs<ExtArgs>>
    ): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Spatial_ref_sys.
     *     @param {spatial_ref_sysCreateManyArgs} args - Arguments to create many Spatial_ref_sys.
     *     @example
     *     // Create many Spatial_ref_sys
     *     const spatial_ref_sys = await prisma.spatial_ref_sys.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends spatial_ref_sysCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, spatial_ref_sysCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Spatial_ref_sys.
     * @param {spatial_ref_sysDeleteArgs} args - Arguments to delete one Spatial_ref_sys.
     * @example
     * // Delete one Spatial_ref_sys
     * const Spatial_ref_sys = await prisma.spatial_ref_sys.delete({
     *   where: {
     *     // ... filter to delete one Spatial_ref_sys
     *   }
     * })
     * 
    **/
    delete<T extends spatial_ref_sysDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, spatial_ref_sysDeleteArgs<ExtArgs>>
    ): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Spatial_ref_sys.
     * @param {spatial_ref_sysUpdateArgs} args - Arguments to update one Spatial_ref_sys.
     * @example
     * // Update one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends spatial_ref_sysUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, spatial_ref_sysUpdateArgs<ExtArgs>>
    ): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Spatial_ref_sys.
     * @param {spatial_ref_sysDeleteManyArgs} args - Arguments to filter Spatial_ref_sys to delete.
     * @example
     * // Delete a few Spatial_ref_sys
     * const { count } = await prisma.spatial_ref_sys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends spatial_ref_sysDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, spatial_ref_sysDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends spatial_ref_sysUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, spatial_ref_sysUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Spatial_ref_sys.
     * @param {spatial_ref_sysUpsertArgs} args - Arguments to update or create a Spatial_ref_sys.
     * @example
     * // Update or create a Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.upsert({
     *   create: {
     *     // ... data to create a Spatial_ref_sys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Spatial_ref_sys we want to update
     *   }
     * })
    **/
    upsert<T extends spatial_ref_sysUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, spatial_ref_sysUpsertArgs<ExtArgs>>
    ): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysCountArgs} args - Arguments to filter Spatial_ref_sys to count.
     * @example
     * // Count the number of Spatial_ref_sys
     * const count = await prisma.spatial_ref_sys.count({
     *   where: {
     *     // ... the filter for the Spatial_ref_sys we want to count
     *   }
     * })
    **/
    count<T extends spatial_ref_sysCountArgs>(
      args?: Subset<T, spatial_ref_sysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Spatial_ref_sysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Spatial_ref_sysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Spatial_ref_sysAggregateArgs>(args: Subset<T, Spatial_ref_sysAggregateArgs>): Prisma.PrismaPromise<GetSpatial_ref_sysAggregateType<T>>

    /**
     * Group by Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends spatial_ref_sysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: spatial_ref_sysGroupByArgs['orderBy'] }
        : { orderBy?: spatial_ref_sysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, spatial_ref_sysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpatial_ref_sysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the spatial_ref_sys model
   */
  readonly fields: spatial_ref_sysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for spatial_ref_sys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__spatial_ref_sysClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the spatial_ref_sys model
   */ 
  interface spatial_ref_sysFieldRefs {
    readonly srid: FieldRef<"spatial_ref_sys", 'Int'>
    readonly auth_name: FieldRef<"spatial_ref_sys", 'String'>
    readonly auth_srid: FieldRef<"spatial_ref_sys", 'Int'>
    readonly srtext: FieldRef<"spatial_ref_sys", 'String'>
    readonly proj4text: FieldRef<"spatial_ref_sys", 'String'>
  }
    

  // Custom InputTypes

  /**
   * spatial_ref_sys findUnique
   */
  export type spatial_ref_sysFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where: spatial_ref_sysWhereUniqueInput
  }


  /**
   * spatial_ref_sys findUniqueOrThrow
   */
  export type spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where: spatial_ref_sysWhereUniqueInput
  }


  /**
   * spatial_ref_sys findFirst
   */
  export type spatial_ref_sysFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationAndSearchRelevanceInput | spatial_ref_sysOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of spatial_ref_sys.
     */
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }


  /**
   * spatial_ref_sys findFirstOrThrow
   */
  export type spatial_ref_sysFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationAndSearchRelevanceInput | spatial_ref_sysOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of spatial_ref_sys.
     */
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }


  /**
   * spatial_ref_sys findMany
   */
  export type spatial_ref_sysFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationAndSearchRelevanceInput | spatial_ref_sysOrderByWithRelationAndSearchRelevanceInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }


  /**
   * spatial_ref_sys create
   */
  export type spatial_ref_sysCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * The data needed to create a spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysCreateInput, spatial_ref_sysUncheckedCreateInput>
  }


  /**
   * spatial_ref_sys createMany
   */
  export type spatial_ref_sysCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many spatial_ref_sys.
     */
    data: spatial_ref_sysCreateManyInput | spatial_ref_sysCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * spatial_ref_sys update
   */
  export type spatial_ref_sysUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * The data needed to update a spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysUpdateInput, spatial_ref_sysUncheckedUpdateInput>
    /**
     * Choose, which spatial_ref_sys to update.
     */
    where: spatial_ref_sysWhereUniqueInput
  }


  /**
   * spatial_ref_sys updateMany
   */
  export type spatial_ref_sysUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysUpdateManyMutationInput, spatial_ref_sysUncheckedUpdateManyInput>
    /**
     * Filter which spatial_ref_sys to update
     */
    where?: spatial_ref_sysWhereInput
  }


  /**
   * spatial_ref_sys upsert
   */
  export type spatial_ref_sysUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * The filter to search for the spatial_ref_sys to update in case it exists.
     */
    where: spatial_ref_sysWhereUniqueInput
    /**
     * In case the spatial_ref_sys found by the `where` argument doesn't exist, create a new spatial_ref_sys with this data.
     */
    create: XOR<spatial_ref_sysCreateInput, spatial_ref_sysUncheckedCreateInput>
    /**
     * In case the spatial_ref_sys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<spatial_ref_sysUpdateInput, spatial_ref_sysUncheckedUpdateInput>
  }


  /**
   * spatial_ref_sys delete
   */
  export type spatial_ref_sysDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter which spatial_ref_sys to delete.
     */
    where: spatial_ref_sysWhereUniqueInput
  }


  /**
   * spatial_ref_sys deleteMany
   */
  export type spatial_ref_sysDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which spatial_ref_sys to delete
     */
    where?: spatial_ref_sysWhereInput
  }


  /**
   * spatial_ref_sys without action
   */
  export type spatial_ref_sysDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    username: 'username',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    text: 'text',
    likes: 'likes',
    likers: 'likers',
    commentableId: 'commentableId',
    commentableType: 'commentableType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    courierId: 'courierId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const CourierScalarFieldEnum: {
    id: 'id',
    node_uri: 'node_uri',
    firstName: 'firstName',
    lastName: 'lastName',
    phoneNumber: 'phoneNumber',
    status: 'status',
    deliverySetting: 'deliverySetting',
    rejectedOffers: 'rejectedOffers',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    stripeAccountId: 'stripeAccountId',
    stripeAccountStatus: 'stripeAccountStatus'
  };

  export type CourierScalarFieldEnum = (typeof CourierScalarFieldEnum)[keyof typeof CourierScalarFieldEnum]


  export const EarningScalarFieldEnum: {
    id: 'id',
    total: 'total',
    pending: 'pending',
    received: 'received',
    payoutMethod: 'payoutMethod',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    courierId: 'courierId'
  };

  export type EarningScalarFieldEnum = (typeof EarningScalarFieldEnum)[keyof typeof EarningScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    street: 'street',
    zipCode: 'zipCode',
    countryCode: 'countryCode',
    stateCode: 'stateCode',
    houseNumber: 'houseNumber',
    longitude: 'longitude',
    latitude: 'latitude',
    formattedAddress: 'formattedAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const PartnerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logo: 'logo',
    phoneNumber: 'phoneNumber',
    webhookUrl: 'webhookUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type PartnerScalarFieldEnum = (typeof PartnerScalarFieldEnum)[keyof typeof PartnerScalarFieldEnum]


  export const DeliveryQuoteScalarFieldEnum: {
    id: 'id',
    quote: 'quote',
    quoteRangeFrom: 'quoteRangeFrom',
    quoteRangeTo: 'quoteRangeTo',
    feePercentage: 'feePercentage',
    currency: 'currency',
    duration: 'duration',
    distance: 'distance',
    distanceUnit: 'distanceUnit',
    pickupPhoneNumber: 'pickupPhoneNumber',
    pickupName: 'pickupName',
    dropoffPhoneNumber: 'dropoffPhoneNumber',
    dropoffName: 'dropoffName',
    expiresAt: 'expiresAt',
    pickupReadyAt: 'pickupReadyAt',
    pickupDeadlineAt: 'pickupDeadlineAt',
    dropoffReadyAt: 'dropoffReadyAt',
    dropoffEta: 'dropoffEta',
    dropoffDeadlineAt: 'dropoffDeadlineAt',
    orderTotalValue: 'orderTotalValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    pickupLocationId: 'pickupLocationId',
    dropoffLocationId: 'dropoffLocationId',
    partnerId: 'partnerId',
    deliveryId: 'deliveryId'
  };

  export type DeliveryQuoteScalarFieldEnum = (typeof DeliveryQuoteScalarFieldEnum)[keyof typeof DeliveryQuoteScalarFieldEnum]


  export const DeliveryScalarFieldEnum: {
    id: 'id',
    pickupName: 'pickupName',
    pickupPhoneNumber: 'pickupPhoneNumber',
    pickupBusinessName: 'pickupBusinessName',
    pickupNotes: 'pickupNotes',
    pickupVerification: 'pickupVerification',
    pickupLocationId: 'pickupLocationId',
    pickupReadyAt: 'pickupReadyAt',
    pickupDeadlineAt: 'pickupDeadlineAt',
    dropoffName: 'dropoffName',
    dropoffPhoneNumber: 'dropoffPhoneNumber',
    dropoffBusinessName: 'dropoffBusinessName',
    dropoffNotes: 'dropoffNotes',
    dropoffSellerNotes: 'dropoffSellerNotes',
    dropoffVerification: 'dropoffVerification',
    dropoffReadyAt: 'dropoffReadyAt',
    dropoffEta: 'dropoffEta',
    dropoffDeadlineAt: 'dropoffDeadlineAt',
    deliverableAction: 'deliverableAction',
    undeliverableAction: 'undeliverableAction',
    undeliverableReason: 'undeliverableReason',
    dropoffLocationId: 'dropoffLocationId',
    deliveryTypes: 'deliveryTypes',
    requiresDropoffSignature: 'requiresDropoffSignature',
    requiresId: 'requiresId',
    orderReference: 'orderReference',
    orderTotalValue: 'orderTotalValue',
    orderItems: 'orderItems',
    status: 'status',
    customerNotes: 'customerNotes',
    currencyCode: 'currencyCode',
    pickupTypes: 'pickupTypes',
    imageType: 'imageType',
    imageName: 'imageName',
    imageData: 'imageData',
    idempotencyKey: 'idempotencyKey',
    externalStoreId: 'externalStoreId',
    returnVerification: 'returnVerification',
    externalUserInfo: 'externalUserInfo',
    externalId: 'externalId',
    courierId: 'courierId',
    partnerId: 'partnerId',
    deliveryQuoteId: 'deliveryQuoteId',
    totalCost: 'totalCost',
    fee: 'fee',
    feePercentage: 'feePercentage',
    pay: 'pay',
    tips: 'tips',
    totalCompensation: 'totalCompensation',
    rejectedByCouriers: 'rejectedByCouriers',
    matchedCourierId: 'matchedCourierId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliveryScalarFieldEnum = (typeof DeliveryScalarFieldEnum)[keyof typeof DeliveryScalarFieldEnum]


  export const DeliveryEventScalarFieldEnum: {
    id: 'id',
    transitionSuccessful: 'transitionSuccessful',
    type: 'type',
    actor: 'actor',
    eventSource: 'eventSource',
    oldStatus: 'oldStatus',
    newStatus: 'newStatus',
    message: 'message',
    deliveryId: 'deliveryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliveryEventScalarFieldEnum = (typeof DeliveryEventScalarFieldEnum)[keyof typeof DeliveryEventScalarFieldEnum]


  export const LocationNoteScalarFieldEnum: {
    id: 'id',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    actor: 'actor',
    locationId: 'locationId',
    deliveryId: 'deliveryId',
    courierId: 'courierId'
  };

  export type LocationNoteScalarFieldEnum = (typeof LocationNoteScalarFieldEnum)[keyof typeof LocationNoteScalarFieldEnum]


  export const LocationNoteReactionScalarFieldEnum: {
    id: 'id',
    reaction: 'reaction',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    locationNoteId: 'locationNoteId',
    courierId: 'courierId'
  };

  export type LocationNoteReactionScalarFieldEnum = (typeof LocationNoteReactionScalarFieldEnum)[keyof typeof LocationNoteReactionScalarFieldEnum]


  export const CourierSettingScalarFieldEnum: {
    id: 'id',
    vehicleType: 'vehicleType',
    preferredAreas: 'preferredAreas',
    shiftAvailability: 'shiftAvailability',
    deliveryPreferences: 'deliveryPreferences',
    foodPreferences: 'foodPreferences',
    earningGoals: 'earningGoals',
    deliverySpeed: 'deliverySpeed',
    restaurantTypes: 'restaurantTypes',
    cuisineTypes: 'cuisineTypes',
    preferredRestaurantPartners: 'preferredRestaurantPartners',
    dietaryRestrictions: 'dietaryRestrictions',
    payRate: 'payRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    courierId: 'courierId'
  };

  export type CourierSettingScalarFieldEnum = (typeof CourierSettingScalarFieldEnum)[keyof typeof CourierSettingScalarFieldEnum]


  export const PayoutScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    arrivalDate: 'arrivalDate',
    description: 'description',
    statementDescriptor: 'statementDescriptor',
    status: 'status',
    paymentId: 'paymentId',
    courierId: 'courierId'
  };

  export type PayoutScalarFieldEnum = (typeof PayoutScalarFieldEnum)[keyof typeof PayoutScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    capturedAt: 'capturedAt',
    canceledAt: 'canceledAt',
    amount: 'amount',
    status: 'status',
    deliveryId: 'deliveryId',
    provider: 'provider'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const StripePaymentDataScalarFieldEnum: {
    id: 'id',
    paymentIntentId: 'paymentIntentId',
    paymentMethodId: 'paymentMethodId',
    latestChargeId: 'latestChargeId',
    paymentId: 'paymentId'
  };

  export type StripePaymentDataScalarFieldEnum = (typeof StripePaymentDataScalarFieldEnum)[keyof typeof StripePaymentDataScalarFieldEnum]


  export const TransferScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    transferId: 'transferId',
    amount: 'amount',
    amountReversed: 'amountReversed',
    destination: 'destination',
    destinationPayment: 'destinationPayment',
    reversed: 'reversed',
    paymentId: 'paymentId',
    courierId: 'courierId'
  };

  export type TransferScalarFieldEnum = (typeof TransferScalarFieldEnum)[keyof typeof TransferScalarFieldEnum]


  export const RefundScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    refundId: 'refundId',
    amount: 'amount',
    description: 'description',
    reason: 'reason',
    status: 'status',
    paymentId: 'paymentId'
  };

  export type RefundScalarFieldEnum = (typeof RefundScalarFieldEnum)[keyof typeof RefundScalarFieldEnum]


  export const ConfigScalarFieldEnum: {
    key: 'key',
    type: 'type',
    value: 'value'
  };

  export type ConfigScalarFieldEnum = (typeof ConfigScalarFieldEnum)[keyof typeof ConfigScalarFieldEnum]


  export const Spatial_ref_sysScalarFieldEnum: {
    srid: 'srid',
    auth_name: 'auth_name',
    auth_srid: 'auth_srid',
    srtext: 'srtext',
    proj4text: 'proj4text'
  };

  export type Spatial_ref_sysScalarFieldEnum = (typeof Spatial_ref_sysScalarFieldEnum)[keyof typeof Spatial_ref_sysScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    username: 'username'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const CommentOrderByRelevanceFieldEnum: {
    id: 'id',
    text: 'text',
    likers: 'likers',
    commentableId: 'commentableId',
    commentableType: 'commentableType',
    courierId: 'courierId'
  };

  export type CommentOrderByRelevanceFieldEnum = (typeof CommentOrderByRelevanceFieldEnum)[keyof typeof CommentOrderByRelevanceFieldEnum]


  export const CourierOrderByRelevanceFieldEnum: {
    id: 'id',
    node_uri: 'node_uri',
    firstName: 'firstName',
    lastName: 'lastName',
    phoneNumber: 'phoneNumber',
    rejectedOffers: 'rejectedOffers',
    userId: 'userId',
    stripeAccountId: 'stripeAccountId'
  };

  export type CourierOrderByRelevanceFieldEnum = (typeof CourierOrderByRelevanceFieldEnum)[keyof typeof CourierOrderByRelevanceFieldEnum]


  export const EarningOrderByRelevanceFieldEnum: {
    id: 'id',
    payoutMethod: 'payoutMethod',
    courierId: 'courierId'
  };

  export type EarningOrderByRelevanceFieldEnum = (typeof EarningOrderByRelevanceFieldEnum)[keyof typeof EarningOrderByRelevanceFieldEnum]


  export const LocationOrderByRelevanceFieldEnum: {
    id: 'id',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    street: 'street',
    zipCode: 'zipCode',
    stateCode: 'stateCode',
    houseNumber: 'houseNumber',
    formattedAddress: 'formattedAddress'
  };

  export type LocationOrderByRelevanceFieldEnum = (typeof LocationOrderByRelevanceFieldEnum)[keyof typeof LocationOrderByRelevanceFieldEnum]


  export const PartnerOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    logo: 'logo',
    phoneNumber: 'phoneNumber',
    webhookUrl: 'webhookUrl',
    userId: 'userId'
  };

  export type PartnerOrderByRelevanceFieldEnum = (typeof PartnerOrderByRelevanceFieldEnum)[keyof typeof PartnerOrderByRelevanceFieldEnum]


  export const DeliveryQuoteOrderByRelevanceFieldEnum: {
    id: 'id',
    currency: 'currency',
    pickupPhoneNumber: 'pickupPhoneNumber',
    pickupName: 'pickupName',
    dropoffPhoneNumber: 'dropoffPhoneNumber',
    dropoffName: 'dropoffName',
    pickupLocationId: 'pickupLocationId',
    dropoffLocationId: 'dropoffLocationId',
    partnerId: 'partnerId',
    deliveryId: 'deliveryId'
  };

  export type DeliveryQuoteOrderByRelevanceFieldEnum = (typeof DeliveryQuoteOrderByRelevanceFieldEnum)[keyof typeof DeliveryQuoteOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const DeliveryOrderByRelevanceFieldEnum: {
    id: 'id',
    pickupName: 'pickupName',
    pickupPhoneNumber: 'pickupPhoneNumber',
    pickupBusinessName: 'pickupBusinessName',
    pickupNotes: 'pickupNotes',
    pickupLocationId: 'pickupLocationId',
    dropoffName: 'dropoffName',
    dropoffPhoneNumber: 'dropoffPhoneNumber',
    dropoffBusinessName: 'dropoffBusinessName',
    dropoffNotes: 'dropoffNotes',
    dropoffSellerNotes: 'dropoffSellerNotes',
    undeliverableReason: 'undeliverableReason',
    dropoffLocationId: 'dropoffLocationId',
    deliveryTypes: 'deliveryTypes',
    orderReference: 'orderReference',
    customerNotes: 'customerNotes',
    currencyCode: 'currencyCode',
    pickupTypes: 'pickupTypes',
    imageType: 'imageType',
    imageName: 'imageName',
    idempotencyKey: 'idempotencyKey',
    externalStoreId: 'externalStoreId',
    externalId: 'externalId',
    courierId: 'courierId',
    partnerId: 'partnerId',
    deliveryQuoteId: 'deliveryQuoteId',
    rejectedByCouriers: 'rejectedByCouriers',
    matchedCourierId: 'matchedCourierId'
  };

  export type DeliveryOrderByRelevanceFieldEnum = (typeof DeliveryOrderByRelevanceFieldEnum)[keyof typeof DeliveryOrderByRelevanceFieldEnum]


  export const DeliveryEventOrderByRelevanceFieldEnum: {
    id: 'id',
    message: 'message',
    deliveryId: 'deliveryId'
  };

  export type DeliveryEventOrderByRelevanceFieldEnum = (typeof DeliveryEventOrderByRelevanceFieldEnum)[keyof typeof DeliveryEventOrderByRelevanceFieldEnum]


  export const LocationNoteOrderByRelevanceFieldEnum: {
    id: 'id',
    note: 'note',
    locationId: 'locationId',
    deliveryId: 'deliveryId',
    courierId: 'courierId'
  };

  export type LocationNoteOrderByRelevanceFieldEnum = (typeof LocationNoteOrderByRelevanceFieldEnum)[keyof typeof LocationNoteOrderByRelevanceFieldEnum]


  export const LocationNoteReactionOrderByRelevanceFieldEnum: {
    id: 'id',
    locationNoteId: 'locationNoteId',
    courierId: 'courierId'
  };

  export type LocationNoteReactionOrderByRelevanceFieldEnum = (typeof LocationNoteReactionOrderByRelevanceFieldEnum)[keyof typeof LocationNoteReactionOrderByRelevanceFieldEnum]


  export const CourierSettingOrderByRelevanceFieldEnum: {
    id: 'id',
    preferredAreas: 'preferredAreas',
    deliveryPreferences: 'deliveryPreferences',
    foodPreferences: 'foodPreferences',
    restaurantTypes: 'restaurantTypes',
    cuisineTypes: 'cuisineTypes',
    preferredRestaurantPartners: 'preferredRestaurantPartners',
    dietaryRestrictions: 'dietaryRestrictions',
    courierId: 'courierId'
  };

  export type CourierSettingOrderByRelevanceFieldEnum = (typeof CourierSettingOrderByRelevanceFieldEnum)[keyof typeof CourierSettingOrderByRelevanceFieldEnum]


  export const PayoutOrderByRelevanceFieldEnum: {
    id: 'id',
    description: 'description',
    statementDescriptor: 'statementDescriptor',
    paymentId: 'paymentId',
    courierId: 'courierId'
  };

  export type PayoutOrderByRelevanceFieldEnum = (typeof PayoutOrderByRelevanceFieldEnum)[keyof typeof PayoutOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    id: 'id',
    deliveryId: 'deliveryId'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const StripePaymentDataOrderByRelevanceFieldEnum: {
    id: 'id',
    paymentIntentId: 'paymentIntentId',
    paymentMethodId: 'paymentMethodId',
    latestChargeId: 'latestChargeId',
    paymentId: 'paymentId'
  };

  export type StripePaymentDataOrderByRelevanceFieldEnum = (typeof StripePaymentDataOrderByRelevanceFieldEnum)[keyof typeof StripePaymentDataOrderByRelevanceFieldEnum]


  export const TransferOrderByRelevanceFieldEnum: {
    id: 'id',
    transferId: 'transferId',
    destination: 'destination',
    destinationPayment: 'destinationPayment',
    paymentId: 'paymentId',
    courierId: 'courierId'
  };

  export type TransferOrderByRelevanceFieldEnum = (typeof TransferOrderByRelevanceFieldEnum)[keyof typeof TransferOrderByRelevanceFieldEnum]


  export const RefundOrderByRelevanceFieldEnum: {
    id: 'id',
    refundId: 'refundId',
    description: 'description',
    paymentId: 'paymentId'
  };

  export type RefundOrderByRelevanceFieldEnum = (typeof RefundOrderByRelevanceFieldEnum)[keyof typeof RefundOrderByRelevanceFieldEnum]


  export const ConfigOrderByRelevanceFieldEnum: {
    key: 'key',
    type: 'type',
    value: 'value'
  };

  export type ConfigOrderByRelevanceFieldEnum = (typeof ConfigOrderByRelevanceFieldEnum)[keyof typeof ConfigOrderByRelevanceFieldEnum]


  export const spatial_ref_sysOrderByRelevanceFieldEnum: {
    auth_name: 'auth_name',
    srtext: 'srtext',
    proj4text: 'proj4text'
  };

  export type spatial_ref_sysOrderByRelevanceFieldEnum = (typeof spatial_ref_sysOrderByRelevanceFieldEnum)[keyof typeof spatial_ref_sysOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'EnumUserRole[]'
   */
  export type ListEnumEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumUserRole[]'>
    


  /**
   * Reference to a field of type 'EnumUserRole'
   */
  export type EnumEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumUserRole'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'EnumCourierStatus'
   */
  export type EnumEnumCourierStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumCourierStatus'>
    


  /**
   * Reference to a field of type 'EnumCourierStatus[]'
   */
  export type ListEnumEnumCourierStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumCourierStatus[]'>
    


  /**
   * Reference to a field of type 'EnumCourierDeliverySetting'
   */
  export type EnumEnumCourierDeliverySettingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumCourierDeliverySetting'>
    


  /**
   * Reference to a field of type 'EnumCourierDeliverySetting[]'
   */
  export type ListEnumEnumCourierDeliverySettingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumCourierDeliverySetting[]'>
    


  /**
   * Reference to a field of type 'EnumStripeAccountStatus'
   */
  export type EnumEnumStripeAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumStripeAccountStatus'>
    


  /**
   * Reference to a field of type 'EnumStripeAccountStatus[]'
   */
  export type ListEnumEnumStripeAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumStripeAccountStatus[]'>
    


  /**
   * Reference to a field of type 'EnumCountryCode'
   */
  export type EnumEnumCountryCodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumCountryCode'>
    


  /**
   * Reference to a field of type 'EnumCountryCode[]'
   */
  export type ListEnumEnumCountryCodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumCountryCode[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'EnumDistanceUnit'
   */
  export type EnumEnumDistanceUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumDistanceUnit'>
    


  /**
   * Reference to a field of type 'EnumDistanceUnit[]'
   */
  export type ListEnumEnumDistanceUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumDistanceUnit[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'EnumDeliverableAction'
   */
  export type EnumEnumDeliverableActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumDeliverableAction'>
    


  /**
   * Reference to a field of type 'EnumDeliverableAction[]'
   */
  export type ListEnumEnumDeliverableActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumDeliverableAction[]'>
    


  /**
   * Reference to a field of type 'EnumUndeliverableAction'
   */
  export type EnumEnumUndeliverableActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumUndeliverableAction'>
    


  /**
   * Reference to a field of type 'EnumUndeliverableAction[]'
   */
  export type ListEnumEnumUndeliverableActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumUndeliverableAction[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'EnumDeliveryStatus'
   */
  export type EnumEnumDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumDeliveryStatus'>
    


  /**
   * Reference to a field of type 'EnumDeliveryStatus[]'
   */
  export type ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumDeliveryStatus[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'EnumDeliveryEventType'
   */
  export type EnumEnumDeliveryEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumDeliveryEventType'>
    


  /**
   * Reference to a field of type 'EnumDeliveryEventType[]'
   */
  export type ListEnumEnumDeliveryEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumDeliveryEventType[]'>
    


  /**
   * Reference to a field of type 'EnumEventActor'
   */
  export type EnumEnumEventActorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumEventActor'>
    


  /**
   * Reference to a field of type 'EnumEventActor[]'
   */
  export type ListEnumEnumEventActorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumEventActor[]'>
    


  /**
   * Reference to a field of type 'EnumDeliveryEventSource'
   */
  export type EnumEnumDeliveryEventSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumDeliveryEventSource'>
    


  /**
   * Reference to a field of type 'EnumDeliveryEventSource[]'
   */
  export type ListEnumEnumDeliveryEventSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumDeliveryEventSource[]'>
    


  /**
   * Reference to a field of type 'EnumLocationNoteActor'
   */
  export type EnumEnumLocationNoteActorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumLocationNoteActor'>
    


  /**
   * Reference to a field of type 'EnumLocationNoteActor[]'
   */
  export type ListEnumEnumLocationNoteActorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumLocationNoteActor[]'>
    


  /**
   * Reference to a field of type 'EnumLocationNoteReactionType'
   */
  export type EnumEnumLocationNoteReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumLocationNoteReactionType'>
    


  /**
   * Reference to a field of type 'EnumLocationNoteReactionType[]'
   */
  export type ListEnumEnumLocationNoteReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumLocationNoteReactionType[]'>
    


  /**
   * Reference to a field of type 'EnumSettingVehicleType'
   */
  export type EnumEnumSettingVehicleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumSettingVehicleType'>
    


  /**
   * Reference to a field of type 'EnumSettingVehicleType[]'
   */
  export type ListEnumEnumSettingVehicleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumSettingVehicleType[]'>
    


  /**
   * Reference to a field of type 'EnumSettingDeliverySpeed'
   */
  export type EnumEnumSettingDeliverySpeedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumSettingDeliverySpeed'>
    


  /**
   * Reference to a field of type 'EnumSettingDeliverySpeed[]'
   */
  export type ListEnumEnumSettingDeliverySpeedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumSettingDeliverySpeed[]'>
    


  /**
   * Reference to a field of type 'EnumPayoutStatus'
   */
  export type EnumEnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumPayoutStatus'>
    


  /**
   * Reference to a field of type 'EnumPayoutStatus[]'
   */
  export type ListEnumEnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumPayoutStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'EnumPaymentStatus'
   */
  export type EnumEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumPaymentStatus'>
    


  /**
   * Reference to a field of type 'EnumPaymentStatus[]'
   */
  export type ListEnumEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumPaymentStatus[]'>
    


  /**
   * Reference to a field of type 'EnumPaymentProvider'
   */
  export type EnumEnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumPaymentProvider'>
    


  /**
   * Reference to a field of type 'EnumPaymentProvider[]'
   */
  export type ListEnumEnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumPaymentProvider[]'>
    


  /**
   * Reference to a field of type 'EnumRefundReason'
   */
  export type EnumEnumRefundReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumRefundReason'>
    


  /**
   * Reference to a field of type 'EnumRefundReason[]'
   */
  export type ListEnumEnumRefundReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumRefundReason[]'>
    


  /**
   * Reference to a field of type 'EnumRefundStatus'
   */
  export type EnumEnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumRefundStatus'>
    


  /**
   * Reference to a field of type 'EnumRefundStatus[]'
   */
  export type ListEnumEnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnumRefundStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumEnumUserRoleNullableListFilter<"User">
    username?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    courier?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
  }

  export type UserOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    username?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courier?: CourierOrderByWithRelationAndSearchRelevanceInput
    partner?: PartnerOrderByWithRelationAndSearchRelevanceInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumEnumUserRoleNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    courier?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    username?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumEnumUserRoleNullableListFilter<"User">
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    text?: StringNullableFilter<"Comment"> | string | null
    likes?: IntNullableFilter<"Comment"> | number | null
    likers?: StringNullableListFilter<"Comment">
    commentableId?: StringFilter<"Comment"> | string
    commentableType?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    courierId?: StringNullableFilter<"Comment"> | string | null
    couriers?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
  }

  export type CommentOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    text?: SortOrderInput | SortOrder
    likes?: SortOrderInput | SortOrder
    likers?: SortOrder
    commentableId?: SortOrder
    commentableType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrderInput | SortOrder
    couriers?: CourierOrderByWithRelationAndSearchRelevanceInput
    _relevance?: CommentOrderByRelevanceInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    text?: StringNullableFilter<"Comment"> | string | null
    likes?: IntNullableFilter<"Comment"> | number | null
    likers?: StringNullableListFilter<"Comment">
    commentableId?: StringFilter<"Comment"> | string
    commentableType?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    courierId?: StringNullableFilter<"Comment"> | string | null
    couriers?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrderInput | SortOrder
    likes?: SortOrderInput | SortOrder
    likers?: SortOrder
    commentableId?: SortOrder
    commentableType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    text?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    likes?: IntNullableWithAggregatesFilter<"Comment"> | number | null
    likers?: StringNullableListFilter<"Comment">
    commentableId?: StringWithAggregatesFilter<"Comment"> | string
    commentableType?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    courierId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
  }

  export type CourierWhereInput = {
    AND?: CourierWhereInput | CourierWhereInput[]
    OR?: CourierWhereInput[]
    NOT?: CourierWhereInput | CourierWhereInput[]
    id?: StringFilter<"Courier"> | string
    node_uri?: StringNullableFilter<"Courier"> | string | null
    firstName?: StringFilter<"Courier"> | string
    lastName?: StringFilter<"Courier"> | string
    phoneNumber?: StringNullableFilter<"Courier"> | string | null
    status?: EnumEnumCourierStatusFilter<"Courier"> | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFilter<"Courier"> | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: StringNullableListFilter<"Courier">
    createdAt?: DateTimeFilter<"Courier"> | Date | string
    updatedAt?: DateTimeFilter<"Courier"> | Date | string
    userId?: StringFilter<"Courier"> | string
    stripeAccountId?: StringNullableFilter<"Courier"> | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFilter<"Courier"> | $Enums.EnumStripeAccountStatus
    user?: XOR<UserRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
    earnings?: EarningListRelationFilter
    deliveries?: DeliveryListRelationFilter
    settings?: XOR<CourierSettingNullableRelationFilter, CourierSettingWhereInput> | null
    Payout?: PayoutListRelationFilter
    Transfer?: TransferListRelationFilter
    locationNotes?: LocationNoteListRelationFilter
    locationNoteReactions?: LocationNoteReactionListRelationFilter
  }

  export type CourierOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    node_uri?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    deliverySetting?: SortOrder
    rejectedOffers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    stripeAccountId?: SortOrderInput | SortOrder
    stripeAccountStatus?: SortOrder
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    comments?: CommentOrderByRelationAggregateInput
    earnings?: EarningOrderByRelationAggregateInput
    deliveries?: DeliveryOrderByRelationAggregateInput
    settings?: CourierSettingOrderByWithRelationAndSearchRelevanceInput
    Payout?: PayoutOrderByRelationAggregateInput
    Transfer?: TransferOrderByRelationAggregateInput
    locationNotes?: LocationNoteOrderByRelationAggregateInput
    locationNoteReactions?: LocationNoteReactionOrderByRelationAggregateInput
    _relevance?: CourierOrderByRelevanceInput
  }

  export type CourierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phoneNumber?: string
    userId?: string
    stripeAccountId?: string
    AND?: CourierWhereInput | CourierWhereInput[]
    OR?: CourierWhereInput[]
    NOT?: CourierWhereInput | CourierWhereInput[]
    node_uri?: StringNullableFilter<"Courier"> | string | null
    firstName?: StringFilter<"Courier"> | string
    lastName?: StringFilter<"Courier"> | string
    status?: EnumEnumCourierStatusFilter<"Courier"> | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFilter<"Courier"> | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: StringNullableListFilter<"Courier">
    createdAt?: DateTimeFilter<"Courier"> | Date | string
    updatedAt?: DateTimeFilter<"Courier"> | Date | string
    stripeAccountStatus?: EnumEnumStripeAccountStatusFilter<"Courier"> | $Enums.EnumStripeAccountStatus
    user?: XOR<UserRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
    earnings?: EarningListRelationFilter
    deliveries?: DeliveryListRelationFilter
    settings?: XOR<CourierSettingNullableRelationFilter, CourierSettingWhereInput> | null
    Payout?: PayoutListRelationFilter
    Transfer?: TransferListRelationFilter
    locationNotes?: LocationNoteListRelationFilter
    locationNoteReactions?: LocationNoteReactionListRelationFilter
  }, "id" | "phoneNumber" | "userId" | "stripeAccountId">

  export type CourierOrderByWithAggregationInput = {
    id?: SortOrder
    node_uri?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    deliverySetting?: SortOrder
    rejectedOffers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    stripeAccountId?: SortOrderInput | SortOrder
    stripeAccountStatus?: SortOrder
    _count?: CourierCountOrderByAggregateInput
    _max?: CourierMaxOrderByAggregateInput
    _min?: CourierMinOrderByAggregateInput
  }

  export type CourierScalarWhereWithAggregatesInput = {
    AND?: CourierScalarWhereWithAggregatesInput | CourierScalarWhereWithAggregatesInput[]
    OR?: CourierScalarWhereWithAggregatesInput[]
    NOT?: CourierScalarWhereWithAggregatesInput | CourierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Courier"> | string
    node_uri?: StringNullableWithAggregatesFilter<"Courier"> | string | null
    firstName?: StringWithAggregatesFilter<"Courier"> | string
    lastName?: StringWithAggregatesFilter<"Courier"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Courier"> | string | null
    status?: EnumEnumCourierStatusWithAggregatesFilter<"Courier"> | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingWithAggregatesFilter<"Courier"> | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: StringNullableListFilter<"Courier">
    createdAt?: DateTimeWithAggregatesFilter<"Courier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Courier"> | Date | string
    userId?: StringWithAggregatesFilter<"Courier"> | string
    stripeAccountId?: StringNullableWithAggregatesFilter<"Courier"> | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusWithAggregatesFilter<"Courier"> | $Enums.EnumStripeAccountStatus
  }

  export type EarningWhereInput = {
    AND?: EarningWhereInput | EarningWhereInput[]
    OR?: EarningWhereInput[]
    NOT?: EarningWhereInput | EarningWhereInput[]
    id?: StringFilter<"Earning"> | string
    total?: IntFilter<"Earning"> | number
    pending?: IntFilter<"Earning"> | number
    received?: IntFilter<"Earning"> | number
    payoutMethod?: StringNullableFilter<"Earning"> | string | null
    createdAt?: DateTimeFilter<"Earning"> | Date | string
    updatedAt?: DateTimeFilter<"Earning"> | Date | string
    courierId?: StringNullableFilter<"Earning"> | string | null
    couriers?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
  }

  export type EarningOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    total?: SortOrder
    pending?: SortOrder
    received?: SortOrder
    payoutMethod?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrderInput | SortOrder
    couriers?: CourierOrderByWithRelationAndSearchRelevanceInput
    _relevance?: EarningOrderByRelevanceInput
  }

  export type EarningWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EarningWhereInput | EarningWhereInput[]
    OR?: EarningWhereInput[]
    NOT?: EarningWhereInput | EarningWhereInput[]
    total?: IntFilter<"Earning"> | number
    pending?: IntFilter<"Earning"> | number
    received?: IntFilter<"Earning"> | number
    payoutMethod?: StringNullableFilter<"Earning"> | string | null
    createdAt?: DateTimeFilter<"Earning"> | Date | string
    updatedAt?: DateTimeFilter<"Earning"> | Date | string
    courierId?: StringNullableFilter<"Earning"> | string | null
    couriers?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
  }, "id">

  export type EarningOrderByWithAggregationInput = {
    id?: SortOrder
    total?: SortOrder
    pending?: SortOrder
    received?: SortOrder
    payoutMethod?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrderInput | SortOrder
    _count?: EarningCountOrderByAggregateInput
    _avg?: EarningAvgOrderByAggregateInput
    _max?: EarningMaxOrderByAggregateInput
    _min?: EarningMinOrderByAggregateInput
    _sum?: EarningSumOrderByAggregateInput
  }

  export type EarningScalarWhereWithAggregatesInput = {
    AND?: EarningScalarWhereWithAggregatesInput | EarningScalarWhereWithAggregatesInput[]
    OR?: EarningScalarWhereWithAggregatesInput[]
    NOT?: EarningScalarWhereWithAggregatesInput | EarningScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Earning"> | string
    total?: IntWithAggregatesFilter<"Earning"> | number
    pending?: IntWithAggregatesFilter<"Earning"> | number
    received?: IntWithAggregatesFilter<"Earning"> | number
    payoutMethod?: StringNullableWithAggregatesFilter<"Earning"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Earning"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Earning"> | Date | string
    courierId?: StringNullableWithAggregatesFilter<"Earning"> | string | null
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    addressLine1?: StringNullableFilter<"Location"> | string | null
    addressLine2?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    state?: StringNullableFilter<"Location"> | string | null
    street?: StringNullableFilter<"Location"> | string | null
    zipCode?: StringNullableFilter<"Location"> | string | null
    countryCode?: EnumEnumCountryCodeFilter<"Location"> | $Enums.EnumCountryCode
    stateCode?: StringNullableFilter<"Location"> | string | null
    houseNumber?: StringNullableFilter<"Location"> | string | null
    longitude?: FloatFilter<"Location"> | number
    latitude?: FloatFilter<"Location"> | number
    formattedAddress?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    locationNotes?: LocationNoteListRelationFilter
    pickupDelivery?: DeliveryListRelationFilter
    dropoffDelivery?: DeliveryListRelationFilter
    pickupDeliveryQuotes?: DeliveryQuoteListRelationFilter
    dropoffDeliveryQuotes?: DeliveryQuoteListRelationFilter
  }

  export type LocationOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    countryCode?: SortOrder
    stateCode?: SortOrderInput | SortOrder
    houseNumber?: SortOrderInput | SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    formattedAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationNotes?: LocationNoteOrderByRelationAggregateInput
    pickupDelivery?: DeliveryOrderByRelationAggregateInput
    dropoffDelivery?: DeliveryOrderByRelationAggregateInput
    pickupDeliveryQuotes?: DeliveryQuoteOrderByRelationAggregateInput
    dropoffDeliveryQuotes?: DeliveryQuoteOrderByRelationAggregateInput
    _relevance?: LocationOrderByRelevanceInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    addressLine1?: StringNullableFilter<"Location"> | string | null
    addressLine2?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    state?: StringNullableFilter<"Location"> | string | null
    street?: StringNullableFilter<"Location"> | string | null
    zipCode?: StringNullableFilter<"Location"> | string | null
    countryCode?: EnumEnumCountryCodeFilter<"Location"> | $Enums.EnumCountryCode
    stateCode?: StringNullableFilter<"Location"> | string | null
    houseNumber?: StringNullableFilter<"Location"> | string | null
    longitude?: FloatFilter<"Location"> | number
    latitude?: FloatFilter<"Location"> | number
    formattedAddress?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    locationNotes?: LocationNoteListRelationFilter
    pickupDelivery?: DeliveryListRelationFilter
    dropoffDelivery?: DeliveryListRelationFilter
    pickupDeliveryQuotes?: DeliveryQuoteListRelationFilter
    dropoffDeliveryQuotes?: DeliveryQuoteListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    countryCode?: SortOrder
    stateCode?: SortOrderInput | SortOrder
    houseNumber?: SortOrderInput | SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    formattedAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    addressLine1?: StringNullableWithAggregatesFilter<"Location"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"Location"> | string | null
    city?: StringNullableWithAggregatesFilter<"Location"> | string | null
    state?: StringNullableWithAggregatesFilter<"Location"> | string | null
    street?: StringNullableWithAggregatesFilter<"Location"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"Location"> | string | null
    countryCode?: EnumEnumCountryCodeWithAggregatesFilter<"Location"> | $Enums.EnumCountryCode
    stateCode?: StringNullableWithAggregatesFilter<"Location"> | string | null
    houseNumber?: StringNullableWithAggregatesFilter<"Location"> | string | null
    longitude?: FloatWithAggregatesFilter<"Location"> | number
    latitude?: FloatWithAggregatesFilter<"Location"> | number
    formattedAddress?: StringNullableWithAggregatesFilter<"Location"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type PartnerWhereInput = {
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    id?: StringFilter<"Partner"> | string
    name?: StringFilter<"Partner"> | string
    logo?: StringNullableFilter<"Partner"> | string | null
    phoneNumber?: StringNullableFilter<"Partner"> | string | null
    webhookUrl?: StringNullableFilter<"Partner"> | string | null
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    userId?: StringNullableFilter<"Partner"> | string | null
    deliveries?: DeliveryListRelationFilter
    deliveryQuotes?: DeliveryQuoteListRelationFilter
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type PartnerOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    deliveries?: DeliveryOrderByRelationAggregateInput
    deliveryQuotes?: DeliveryQuoteOrderByRelationAggregateInput
    user?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: PartnerOrderByRelevanceInput
  }

  export type PartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    name?: StringFilter<"Partner"> | string
    logo?: StringNullableFilter<"Partner"> | string | null
    phoneNumber?: StringNullableFilter<"Partner"> | string | null
    webhookUrl?: StringNullableFilter<"Partner"> | string | null
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    deliveries?: DeliveryListRelationFilter
    deliveryQuotes?: DeliveryQuoteListRelationFilter
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "userId">

  export type PartnerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: PartnerCountOrderByAggregateInput
    _max?: PartnerMaxOrderByAggregateInput
    _min?: PartnerMinOrderByAggregateInput
  }

  export type PartnerScalarWhereWithAggregatesInput = {
    AND?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    OR?: PartnerScalarWhereWithAggregatesInput[]
    NOT?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Partner"> | string
    name?: StringWithAggregatesFilter<"Partner"> | string
    logo?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    webhookUrl?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"Partner"> | string | null
  }

  export type DeliveryQuoteWhereInput = {
    AND?: DeliveryQuoteWhereInput | DeliveryQuoteWhereInput[]
    OR?: DeliveryQuoteWhereInput[]
    NOT?: DeliveryQuoteWhereInput | DeliveryQuoteWhereInput[]
    id?: StringFilter<"DeliveryQuote"> | string
    quote?: FloatNullableFilter<"DeliveryQuote"> | number | null
    quoteRangeFrom?: FloatFilter<"DeliveryQuote"> | number
    quoteRangeTo?: FloatFilter<"DeliveryQuote"> | number
    feePercentage?: FloatFilter<"DeliveryQuote"> | number
    currency?: StringFilter<"DeliveryQuote"> | string
    duration?: IntFilter<"DeliveryQuote"> | number
    distance?: FloatFilter<"DeliveryQuote"> | number
    distanceUnit?: EnumEnumDistanceUnitFilter<"DeliveryQuote"> | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: StringNullableFilter<"DeliveryQuote"> | string | null
    pickupName?: StringNullableFilter<"DeliveryQuote"> | string | null
    dropoffPhoneNumber?: StringNullableFilter<"DeliveryQuote"> | string | null
    dropoffName?: StringNullableFilter<"DeliveryQuote"> | string | null
    expiresAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    pickupReadyAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    pickupDeadlineAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    dropoffReadyAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    dropoffEta?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    dropoffDeadlineAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    orderTotalValue?: FloatFilter<"DeliveryQuote"> | number
    createdAt?: DateTimeFilter<"DeliveryQuote"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryQuote"> | Date | string
    pickupLocationId?: StringFilter<"DeliveryQuote"> | string
    dropoffLocationId?: StringFilter<"DeliveryQuote"> | string
    partnerId?: StringNullableFilter<"DeliveryQuote"> | string | null
    deliveryId?: StringNullableFilter<"DeliveryQuote"> | string | null
    pickupLocation?: XOR<LocationRelationFilter, LocationWhereInput>
    dropoffLocation?: XOR<LocationRelationFilter, LocationWhereInput>
    partners?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    Delivery?: XOR<DeliveryNullableRelationFilter, DeliveryWhereInput> | null
  }

  export type DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    quote?: SortOrderInput | SortOrder
    quoteRangeFrom?: SortOrder
    quoteRangeTo?: SortOrder
    feePercentage?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    distanceUnit?: SortOrder
    pickupPhoneNumber?: SortOrderInput | SortOrder
    pickupName?: SortOrderInput | SortOrder
    dropoffPhoneNumber?: SortOrderInput | SortOrder
    dropoffName?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    pickupReadyAt?: SortOrderInput | SortOrder
    pickupDeadlineAt?: SortOrderInput | SortOrder
    dropoffReadyAt?: SortOrderInput | SortOrder
    dropoffEta?: SortOrderInput | SortOrder
    dropoffDeadlineAt?: SortOrderInput | SortOrder
    orderTotalValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pickupLocationId?: SortOrder
    dropoffLocationId?: SortOrder
    partnerId?: SortOrderInput | SortOrder
    deliveryId?: SortOrderInput | SortOrder
    pickupLocation?: LocationOrderByWithRelationAndSearchRelevanceInput
    dropoffLocation?: LocationOrderByWithRelationAndSearchRelevanceInput
    partners?: PartnerOrderByWithRelationAndSearchRelevanceInput
    Delivery?: DeliveryOrderByWithRelationAndSearchRelevanceInput
    _relevance?: DeliveryQuoteOrderByRelevanceInput
  }

  export type DeliveryQuoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryQuoteWhereInput | DeliveryQuoteWhereInput[]
    OR?: DeliveryQuoteWhereInput[]
    NOT?: DeliveryQuoteWhereInput | DeliveryQuoteWhereInput[]
    quote?: FloatNullableFilter<"DeliveryQuote"> | number | null
    quoteRangeFrom?: FloatFilter<"DeliveryQuote"> | number
    quoteRangeTo?: FloatFilter<"DeliveryQuote"> | number
    feePercentage?: FloatFilter<"DeliveryQuote"> | number
    currency?: StringFilter<"DeliveryQuote"> | string
    duration?: IntFilter<"DeliveryQuote"> | number
    distance?: FloatFilter<"DeliveryQuote"> | number
    distanceUnit?: EnumEnumDistanceUnitFilter<"DeliveryQuote"> | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: StringNullableFilter<"DeliveryQuote"> | string | null
    pickupName?: StringNullableFilter<"DeliveryQuote"> | string | null
    dropoffPhoneNumber?: StringNullableFilter<"DeliveryQuote"> | string | null
    dropoffName?: StringNullableFilter<"DeliveryQuote"> | string | null
    expiresAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    pickupReadyAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    pickupDeadlineAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    dropoffReadyAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    dropoffEta?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    dropoffDeadlineAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    orderTotalValue?: FloatFilter<"DeliveryQuote"> | number
    createdAt?: DateTimeFilter<"DeliveryQuote"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryQuote"> | Date | string
    pickupLocationId?: StringFilter<"DeliveryQuote"> | string
    dropoffLocationId?: StringFilter<"DeliveryQuote"> | string
    partnerId?: StringNullableFilter<"DeliveryQuote"> | string | null
    deliveryId?: StringNullableFilter<"DeliveryQuote"> | string | null
    pickupLocation?: XOR<LocationRelationFilter, LocationWhereInput>
    dropoffLocation?: XOR<LocationRelationFilter, LocationWhereInput>
    partners?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    Delivery?: XOR<DeliveryNullableRelationFilter, DeliveryWhereInput> | null
  }, "id">

  export type DeliveryQuoteOrderByWithAggregationInput = {
    id?: SortOrder
    quote?: SortOrderInput | SortOrder
    quoteRangeFrom?: SortOrder
    quoteRangeTo?: SortOrder
    feePercentage?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    distanceUnit?: SortOrder
    pickupPhoneNumber?: SortOrderInput | SortOrder
    pickupName?: SortOrderInput | SortOrder
    dropoffPhoneNumber?: SortOrderInput | SortOrder
    dropoffName?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    pickupReadyAt?: SortOrderInput | SortOrder
    pickupDeadlineAt?: SortOrderInput | SortOrder
    dropoffReadyAt?: SortOrderInput | SortOrder
    dropoffEta?: SortOrderInput | SortOrder
    dropoffDeadlineAt?: SortOrderInput | SortOrder
    orderTotalValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pickupLocationId?: SortOrder
    dropoffLocationId?: SortOrder
    partnerId?: SortOrderInput | SortOrder
    deliveryId?: SortOrderInput | SortOrder
    _count?: DeliveryQuoteCountOrderByAggregateInput
    _avg?: DeliveryQuoteAvgOrderByAggregateInput
    _max?: DeliveryQuoteMaxOrderByAggregateInput
    _min?: DeliveryQuoteMinOrderByAggregateInput
    _sum?: DeliveryQuoteSumOrderByAggregateInput
  }

  export type DeliveryQuoteScalarWhereWithAggregatesInput = {
    AND?: DeliveryQuoteScalarWhereWithAggregatesInput | DeliveryQuoteScalarWhereWithAggregatesInput[]
    OR?: DeliveryQuoteScalarWhereWithAggregatesInput[]
    NOT?: DeliveryQuoteScalarWhereWithAggregatesInput | DeliveryQuoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryQuote"> | string
    quote?: FloatNullableWithAggregatesFilter<"DeliveryQuote"> | number | null
    quoteRangeFrom?: FloatWithAggregatesFilter<"DeliveryQuote"> | number
    quoteRangeTo?: FloatWithAggregatesFilter<"DeliveryQuote"> | number
    feePercentage?: FloatWithAggregatesFilter<"DeliveryQuote"> | number
    currency?: StringWithAggregatesFilter<"DeliveryQuote"> | string
    duration?: IntWithAggregatesFilter<"DeliveryQuote"> | number
    distance?: FloatWithAggregatesFilter<"DeliveryQuote"> | number
    distanceUnit?: EnumEnumDistanceUnitWithAggregatesFilter<"DeliveryQuote"> | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: StringNullableWithAggregatesFilter<"DeliveryQuote"> | string | null
    pickupName?: StringNullableWithAggregatesFilter<"DeliveryQuote"> | string | null
    dropoffPhoneNumber?: StringNullableWithAggregatesFilter<"DeliveryQuote"> | string | null
    dropoffName?: StringNullableWithAggregatesFilter<"DeliveryQuote"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"DeliveryQuote"> | Date | string | null
    pickupReadyAt?: DateTimeNullableWithAggregatesFilter<"DeliveryQuote"> | Date | string | null
    pickupDeadlineAt?: DateTimeNullableWithAggregatesFilter<"DeliveryQuote"> | Date | string | null
    dropoffReadyAt?: DateTimeNullableWithAggregatesFilter<"DeliveryQuote"> | Date | string | null
    dropoffEta?: DateTimeNullableWithAggregatesFilter<"DeliveryQuote"> | Date | string | null
    dropoffDeadlineAt?: DateTimeNullableWithAggregatesFilter<"DeliveryQuote"> | Date | string | null
    orderTotalValue?: FloatWithAggregatesFilter<"DeliveryQuote"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryQuote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliveryQuote"> | Date | string
    pickupLocationId?: StringWithAggregatesFilter<"DeliveryQuote"> | string
    dropoffLocationId?: StringWithAggregatesFilter<"DeliveryQuote"> | string
    partnerId?: StringNullableWithAggregatesFilter<"DeliveryQuote"> | string | null
    deliveryId?: StringNullableWithAggregatesFilter<"DeliveryQuote"> | string | null
  }

  export type DeliveryWhereInput = {
    AND?: DeliveryWhereInput | DeliveryWhereInput[]
    OR?: DeliveryWhereInput[]
    NOT?: DeliveryWhereInput | DeliveryWhereInput[]
    id?: StringFilter<"Delivery"> | string
    pickupName?: StringFilter<"Delivery"> | string
    pickupPhoneNumber?: StringFilter<"Delivery"> | string
    pickupBusinessName?: StringFilter<"Delivery"> | string
    pickupNotes?: StringNullableFilter<"Delivery"> | string | null
    pickupVerification?: JsonNullableFilter<"Delivery">
    pickupLocationId?: StringFilter<"Delivery"> | string
    pickupReadyAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    pickupDeadlineAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    dropoffName?: StringFilter<"Delivery"> | string
    dropoffPhoneNumber?: StringFilter<"Delivery"> | string
    dropoffBusinessName?: StringNullableFilter<"Delivery"> | string | null
    dropoffNotes?: StringNullableFilter<"Delivery"> | string | null
    dropoffSellerNotes?: StringNullableFilter<"Delivery"> | string | null
    dropoffVerification?: JsonNullableFilter<"Delivery">
    dropoffReadyAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    dropoffEta?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    dropoffDeadlineAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFilter<"Delivery"> | $Enums.EnumDeliverableAction
    undeliverableAction?: EnumEnumUndeliverableActionNullableFilter<"Delivery"> | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: StringNullableFilter<"Delivery"> | string | null
    dropoffLocationId?: StringFilter<"Delivery"> | string
    deliveryTypes?: StringNullableListFilter<"Delivery">
    requiresDropoffSignature?: BoolFilter<"Delivery"> | boolean
    requiresId?: BoolFilter<"Delivery"> | boolean
    orderReference?: StringNullableFilter<"Delivery"> | string | null
    orderTotalValue?: IntNullableFilter<"Delivery"> | number | null
    orderItems?: JsonNullableFilter<"Delivery">
    status?: EnumEnumDeliveryStatusFilter<"Delivery"> | $Enums.EnumDeliveryStatus
    customerNotes?: StringNullableListFilter<"Delivery">
    currencyCode?: StringFilter<"Delivery"> | string
    pickupTypes?: StringNullableListFilter<"Delivery">
    imageType?: StringNullableFilter<"Delivery"> | string | null
    imageName?: StringNullableFilter<"Delivery"> | string | null
    imageData?: BytesNullableFilter<"Delivery"> | Buffer | null
    idempotencyKey?: StringNullableFilter<"Delivery"> | string | null
    externalStoreId?: StringNullableFilter<"Delivery"> | string | null
    returnVerification?: JsonNullableFilter<"Delivery">
    externalUserInfo?: JsonNullableFilter<"Delivery">
    externalId?: StringNullableFilter<"Delivery"> | string | null
    courierId?: StringNullableFilter<"Delivery"> | string | null
    partnerId?: StringNullableFilter<"Delivery"> | string | null
    deliveryQuoteId?: StringFilter<"Delivery"> | string
    totalCost?: FloatNullableFilter<"Delivery"> | number | null
    fee?: FloatNullableFilter<"Delivery"> | number | null
    feePercentage?: FloatNullableFilter<"Delivery"> | number | null
    pay?: FloatNullableFilter<"Delivery"> | number | null
    tips?: FloatFilter<"Delivery"> | number
    totalCompensation?: FloatNullableFilter<"Delivery"> | number | null
    rejectedByCouriers?: StringNullableListFilter<"Delivery">
    matchedCourierId?: StringNullableFilter<"Delivery"> | string | null
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
    pickupLocation?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    dropoffLocation?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    courier?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    delivery?: XOR<DeliveryQuoteRelationFilter, DeliveryQuoteWhereInput>
    payment?: PaymentListRelationFilter
    deliveryEvent?: DeliveryEventListRelationFilter
    locationNote?: LocationNoteListRelationFilter
  }

  export type DeliveryOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    pickupName?: SortOrder
    pickupPhoneNumber?: SortOrder
    pickupBusinessName?: SortOrder
    pickupNotes?: SortOrderInput | SortOrder
    pickupVerification?: SortOrderInput | SortOrder
    pickupLocationId?: SortOrder
    pickupReadyAt?: SortOrderInput | SortOrder
    pickupDeadlineAt?: SortOrderInput | SortOrder
    dropoffName?: SortOrder
    dropoffPhoneNumber?: SortOrder
    dropoffBusinessName?: SortOrderInput | SortOrder
    dropoffNotes?: SortOrderInput | SortOrder
    dropoffSellerNotes?: SortOrderInput | SortOrder
    dropoffVerification?: SortOrderInput | SortOrder
    dropoffReadyAt?: SortOrderInput | SortOrder
    dropoffEta?: SortOrderInput | SortOrder
    dropoffDeadlineAt?: SortOrderInput | SortOrder
    deliverableAction?: SortOrder
    undeliverableAction?: SortOrderInput | SortOrder
    undeliverableReason?: SortOrderInput | SortOrder
    dropoffLocationId?: SortOrder
    deliveryTypes?: SortOrder
    requiresDropoffSignature?: SortOrder
    requiresId?: SortOrder
    orderReference?: SortOrderInput | SortOrder
    orderTotalValue?: SortOrderInput | SortOrder
    orderItems?: SortOrderInput | SortOrder
    status?: SortOrder
    customerNotes?: SortOrder
    currencyCode?: SortOrder
    pickupTypes?: SortOrder
    imageType?: SortOrderInput | SortOrder
    imageName?: SortOrderInput | SortOrder
    imageData?: SortOrderInput | SortOrder
    idempotencyKey?: SortOrderInput | SortOrder
    externalStoreId?: SortOrderInput | SortOrder
    returnVerification?: SortOrderInput | SortOrder
    externalUserInfo?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    courierId?: SortOrderInput | SortOrder
    partnerId?: SortOrderInput | SortOrder
    deliveryQuoteId?: SortOrder
    totalCost?: SortOrderInput | SortOrder
    fee?: SortOrderInput | SortOrder
    feePercentage?: SortOrderInput | SortOrder
    pay?: SortOrderInput | SortOrder
    tips?: SortOrder
    totalCompensation?: SortOrderInput | SortOrder
    rejectedByCouriers?: SortOrder
    matchedCourierId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pickupLocation?: LocationOrderByWithRelationAndSearchRelevanceInput
    dropoffLocation?: LocationOrderByWithRelationAndSearchRelevanceInput
    courier?: CourierOrderByWithRelationAndSearchRelevanceInput
    partner?: PartnerOrderByWithRelationAndSearchRelevanceInput
    delivery?: DeliveryQuoteOrderByWithRelationAndSearchRelevanceInput
    payment?: PaymentOrderByRelationAggregateInput
    deliveryEvent?: DeliveryEventOrderByRelationAggregateInput
    locationNote?: LocationNoteOrderByRelationAggregateInput
    _relevance?: DeliveryOrderByRelevanceInput
  }

  export type DeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deliveryQuoteId?: string
    idempotencyKey_partnerId?: DeliveryIdempotencyKeyPartnerIdCompoundUniqueInput
    AND?: DeliveryWhereInput | DeliveryWhereInput[]
    OR?: DeliveryWhereInput[]
    NOT?: DeliveryWhereInput | DeliveryWhereInput[]
    pickupName?: StringFilter<"Delivery"> | string
    pickupPhoneNumber?: StringFilter<"Delivery"> | string
    pickupBusinessName?: StringFilter<"Delivery"> | string
    pickupNotes?: StringNullableFilter<"Delivery"> | string | null
    pickupVerification?: JsonNullableFilter<"Delivery">
    pickupLocationId?: StringFilter<"Delivery"> | string
    pickupReadyAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    pickupDeadlineAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    dropoffName?: StringFilter<"Delivery"> | string
    dropoffPhoneNumber?: StringFilter<"Delivery"> | string
    dropoffBusinessName?: StringNullableFilter<"Delivery"> | string | null
    dropoffNotes?: StringNullableFilter<"Delivery"> | string | null
    dropoffSellerNotes?: StringNullableFilter<"Delivery"> | string | null
    dropoffVerification?: JsonNullableFilter<"Delivery">
    dropoffReadyAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    dropoffEta?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    dropoffDeadlineAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFilter<"Delivery"> | $Enums.EnumDeliverableAction
    undeliverableAction?: EnumEnumUndeliverableActionNullableFilter<"Delivery"> | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: StringNullableFilter<"Delivery"> | string | null
    dropoffLocationId?: StringFilter<"Delivery"> | string
    deliveryTypes?: StringNullableListFilter<"Delivery">
    requiresDropoffSignature?: BoolFilter<"Delivery"> | boolean
    requiresId?: BoolFilter<"Delivery"> | boolean
    orderReference?: StringNullableFilter<"Delivery"> | string | null
    orderTotalValue?: IntNullableFilter<"Delivery"> | number | null
    orderItems?: JsonNullableFilter<"Delivery">
    status?: EnumEnumDeliveryStatusFilter<"Delivery"> | $Enums.EnumDeliveryStatus
    customerNotes?: StringNullableListFilter<"Delivery">
    currencyCode?: StringFilter<"Delivery"> | string
    pickupTypes?: StringNullableListFilter<"Delivery">
    imageType?: StringNullableFilter<"Delivery"> | string | null
    imageName?: StringNullableFilter<"Delivery"> | string | null
    imageData?: BytesNullableFilter<"Delivery"> | Buffer | null
    idempotencyKey?: StringNullableFilter<"Delivery"> | string | null
    externalStoreId?: StringNullableFilter<"Delivery"> | string | null
    returnVerification?: JsonNullableFilter<"Delivery">
    externalUserInfo?: JsonNullableFilter<"Delivery">
    externalId?: StringNullableFilter<"Delivery"> | string | null
    courierId?: StringNullableFilter<"Delivery"> | string | null
    partnerId?: StringNullableFilter<"Delivery"> | string | null
    totalCost?: FloatNullableFilter<"Delivery"> | number | null
    fee?: FloatNullableFilter<"Delivery"> | number | null
    feePercentage?: FloatNullableFilter<"Delivery"> | number | null
    pay?: FloatNullableFilter<"Delivery"> | number | null
    tips?: FloatFilter<"Delivery"> | number
    totalCompensation?: FloatNullableFilter<"Delivery"> | number | null
    rejectedByCouriers?: StringNullableListFilter<"Delivery">
    matchedCourierId?: StringNullableFilter<"Delivery"> | string | null
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
    pickupLocation?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    dropoffLocation?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    courier?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    delivery?: XOR<DeliveryQuoteRelationFilter, DeliveryQuoteWhereInput>
    payment?: PaymentListRelationFilter
    deliveryEvent?: DeliveryEventListRelationFilter
    locationNote?: LocationNoteListRelationFilter
  }, "id" | "deliveryQuoteId" | "idempotencyKey_partnerId">

  export type DeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    pickupName?: SortOrder
    pickupPhoneNumber?: SortOrder
    pickupBusinessName?: SortOrder
    pickupNotes?: SortOrderInput | SortOrder
    pickupVerification?: SortOrderInput | SortOrder
    pickupLocationId?: SortOrder
    pickupReadyAt?: SortOrderInput | SortOrder
    pickupDeadlineAt?: SortOrderInput | SortOrder
    dropoffName?: SortOrder
    dropoffPhoneNumber?: SortOrder
    dropoffBusinessName?: SortOrderInput | SortOrder
    dropoffNotes?: SortOrderInput | SortOrder
    dropoffSellerNotes?: SortOrderInput | SortOrder
    dropoffVerification?: SortOrderInput | SortOrder
    dropoffReadyAt?: SortOrderInput | SortOrder
    dropoffEta?: SortOrderInput | SortOrder
    dropoffDeadlineAt?: SortOrderInput | SortOrder
    deliverableAction?: SortOrder
    undeliverableAction?: SortOrderInput | SortOrder
    undeliverableReason?: SortOrderInput | SortOrder
    dropoffLocationId?: SortOrder
    deliveryTypes?: SortOrder
    requiresDropoffSignature?: SortOrder
    requiresId?: SortOrder
    orderReference?: SortOrderInput | SortOrder
    orderTotalValue?: SortOrderInput | SortOrder
    orderItems?: SortOrderInput | SortOrder
    status?: SortOrder
    customerNotes?: SortOrder
    currencyCode?: SortOrder
    pickupTypes?: SortOrder
    imageType?: SortOrderInput | SortOrder
    imageName?: SortOrderInput | SortOrder
    imageData?: SortOrderInput | SortOrder
    idempotencyKey?: SortOrderInput | SortOrder
    externalStoreId?: SortOrderInput | SortOrder
    returnVerification?: SortOrderInput | SortOrder
    externalUserInfo?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    courierId?: SortOrderInput | SortOrder
    partnerId?: SortOrderInput | SortOrder
    deliveryQuoteId?: SortOrder
    totalCost?: SortOrderInput | SortOrder
    fee?: SortOrderInput | SortOrder
    feePercentage?: SortOrderInput | SortOrder
    pay?: SortOrderInput | SortOrder
    tips?: SortOrder
    totalCompensation?: SortOrderInput | SortOrder
    rejectedByCouriers?: SortOrder
    matchedCourierId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliveryCountOrderByAggregateInput
    _avg?: DeliveryAvgOrderByAggregateInput
    _max?: DeliveryMaxOrderByAggregateInput
    _min?: DeliveryMinOrderByAggregateInput
    _sum?: DeliverySumOrderByAggregateInput
  }

  export type DeliveryScalarWhereWithAggregatesInput = {
    AND?: DeliveryScalarWhereWithAggregatesInput | DeliveryScalarWhereWithAggregatesInput[]
    OR?: DeliveryScalarWhereWithAggregatesInput[]
    NOT?: DeliveryScalarWhereWithAggregatesInput | DeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Delivery"> | string
    pickupName?: StringWithAggregatesFilter<"Delivery"> | string
    pickupPhoneNumber?: StringWithAggregatesFilter<"Delivery"> | string
    pickupBusinessName?: StringWithAggregatesFilter<"Delivery"> | string
    pickupNotes?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    pickupVerification?: JsonNullableWithAggregatesFilter<"Delivery">
    pickupLocationId?: StringWithAggregatesFilter<"Delivery"> | string
    pickupReadyAt?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    pickupDeadlineAt?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    dropoffName?: StringWithAggregatesFilter<"Delivery"> | string
    dropoffPhoneNumber?: StringWithAggregatesFilter<"Delivery"> | string
    dropoffBusinessName?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    dropoffNotes?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    dropoffSellerNotes?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    dropoffVerification?: JsonNullableWithAggregatesFilter<"Delivery">
    dropoffReadyAt?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    dropoffEta?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    dropoffDeadlineAt?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionWithAggregatesFilter<"Delivery"> | $Enums.EnumDeliverableAction
    undeliverableAction?: EnumEnumUndeliverableActionNullableWithAggregatesFilter<"Delivery"> | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    dropoffLocationId?: StringWithAggregatesFilter<"Delivery"> | string
    deliveryTypes?: StringNullableListFilter<"Delivery">
    requiresDropoffSignature?: BoolWithAggregatesFilter<"Delivery"> | boolean
    requiresId?: BoolWithAggregatesFilter<"Delivery"> | boolean
    orderReference?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    orderTotalValue?: IntNullableWithAggregatesFilter<"Delivery"> | number | null
    orderItems?: JsonNullableWithAggregatesFilter<"Delivery">
    status?: EnumEnumDeliveryStatusWithAggregatesFilter<"Delivery"> | $Enums.EnumDeliveryStatus
    customerNotes?: StringNullableListFilter<"Delivery">
    currencyCode?: StringWithAggregatesFilter<"Delivery"> | string
    pickupTypes?: StringNullableListFilter<"Delivery">
    imageType?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    imageName?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    imageData?: BytesNullableWithAggregatesFilter<"Delivery"> | Buffer | null
    idempotencyKey?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    externalStoreId?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    returnVerification?: JsonNullableWithAggregatesFilter<"Delivery">
    externalUserInfo?: JsonNullableWithAggregatesFilter<"Delivery">
    externalId?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    courierId?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    partnerId?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    deliveryQuoteId?: StringWithAggregatesFilter<"Delivery"> | string
    totalCost?: FloatNullableWithAggregatesFilter<"Delivery"> | number | null
    fee?: FloatNullableWithAggregatesFilter<"Delivery"> | number | null
    feePercentage?: FloatNullableWithAggregatesFilter<"Delivery"> | number | null
    pay?: FloatNullableWithAggregatesFilter<"Delivery"> | number | null
    tips?: FloatWithAggregatesFilter<"Delivery"> | number
    totalCompensation?: FloatNullableWithAggregatesFilter<"Delivery"> | number | null
    rejectedByCouriers?: StringNullableListFilter<"Delivery">
    matchedCourierId?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Delivery"> | Date | string
  }

  export type DeliveryEventWhereInput = {
    AND?: DeliveryEventWhereInput | DeliveryEventWhereInput[]
    OR?: DeliveryEventWhereInput[]
    NOT?: DeliveryEventWhereInput | DeliveryEventWhereInput[]
    id?: StringFilter<"DeliveryEvent"> | string
    transitionSuccessful?: BoolFilter<"DeliveryEvent"> | boolean
    type?: EnumEnumDeliveryEventTypeFilter<"DeliveryEvent"> | $Enums.EnumDeliveryEventType
    actor?: EnumEnumEventActorFilter<"DeliveryEvent"> | $Enums.EnumEventActor
    eventSource?: EnumEnumDeliveryEventSourceFilter<"DeliveryEvent"> | $Enums.EnumDeliveryEventSource
    oldStatus?: EnumEnumDeliveryStatusNullableFilter<"DeliveryEvent"> | $Enums.EnumDeliveryStatus | null
    newStatus?: EnumEnumDeliveryStatusNullableFilter<"DeliveryEvent"> | $Enums.EnumDeliveryStatus | null
    message?: StringNullableFilter<"DeliveryEvent"> | string | null
    deliveryId?: StringFilter<"DeliveryEvent"> | string
    createdAt?: DateTimeFilter<"DeliveryEvent"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryEvent"> | Date | string
    delivery?: XOR<DeliveryRelationFilter, DeliveryWhereInput>
  }

  export type DeliveryEventOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    transitionSuccessful?: SortOrder
    type?: SortOrder
    actor?: SortOrder
    eventSource?: SortOrder
    oldStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    deliveryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    delivery?: DeliveryOrderByWithRelationAndSearchRelevanceInput
    _relevance?: DeliveryEventOrderByRelevanceInput
  }

  export type DeliveryEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryEventWhereInput | DeliveryEventWhereInput[]
    OR?: DeliveryEventWhereInput[]
    NOT?: DeliveryEventWhereInput | DeliveryEventWhereInput[]
    transitionSuccessful?: BoolFilter<"DeliveryEvent"> | boolean
    type?: EnumEnumDeliveryEventTypeFilter<"DeliveryEvent"> | $Enums.EnumDeliveryEventType
    actor?: EnumEnumEventActorFilter<"DeliveryEvent"> | $Enums.EnumEventActor
    eventSource?: EnumEnumDeliveryEventSourceFilter<"DeliveryEvent"> | $Enums.EnumDeliveryEventSource
    oldStatus?: EnumEnumDeliveryStatusNullableFilter<"DeliveryEvent"> | $Enums.EnumDeliveryStatus | null
    newStatus?: EnumEnumDeliveryStatusNullableFilter<"DeliveryEvent"> | $Enums.EnumDeliveryStatus | null
    message?: StringNullableFilter<"DeliveryEvent"> | string | null
    deliveryId?: StringFilter<"DeliveryEvent"> | string
    createdAt?: DateTimeFilter<"DeliveryEvent"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryEvent"> | Date | string
    delivery?: XOR<DeliveryRelationFilter, DeliveryWhereInput>
  }, "id">

  export type DeliveryEventOrderByWithAggregationInput = {
    id?: SortOrder
    transitionSuccessful?: SortOrder
    type?: SortOrder
    actor?: SortOrder
    eventSource?: SortOrder
    oldStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    deliveryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliveryEventCountOrderByAggregateInput
    _max?: DeliveryEventMaxOrderByAggregateInput
    _min?: DeliveryEventMinOrderByAggregateInput
  }

  export type DeliveryEventScalarWhereWithAggregatesInput = {
    AND?: DeliveryEventScalarWhereWithAggregatesInput | DeliveryEventScalarWhereWithAggregatesInput[]
    OR?: DeliveryEventScalarWhereWithAggregatesInput[]
    NOT?: DeliveryEventScalarWhereWithAggregatesInput | DeliveryEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryEvent"> | string
    transitionSuccessful?: BoolWithAggregatesFilter<"DeliveryEvent"> | boolean
    type?: EnumEnumDeliveryEventTypeWithAggregatesFilter<"DeliveryEvent"> | $Enums.EnumDeliveryEventType
    actor?: EnumEnumEventActorWithAggregatesFilter<"DeliveryEvent"> | $Enums.EnumEventActor
    eventSource?: EnumEnumDeliveryEventSourceWithAggregatesFilter<"DeliveryEvent"> | $Enums.EnumDeliveryEventSource
    oldStatus?: EnumEnumDeliveryStatusNullableWithAggregatesFilter<"DeliveryEvent"> | $Enums.EnumDeliveryStatus | null
    newStatus?: EnumEnumDeliveryStatusNullableWithAggregatesFilter<"DeliveryEvent"> | $Enums.EnumDeliveryStatus | null
    message?: StringNullableWithAggregatesFilter<"DeliveryEvent"> | string | null
    deliveryId?: StringWithAggregatesFilter<"DeliveryEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliveryEvent"> | Date | string
  }

  export type LocationNoteWhereInput = {
    AND?: LocationNoteWhereInput | LocationNoteWhereInput[]
    OR?: LocationNoteWhereInput[]
    NOT?: LocationNoteWhereInput | LocationNoteWhereInput[]
    id?: StringFilter<"LocationNote"> | string
    note?: StringNullableFilter<"LocationNote"> | string | null
    createdAt?: DateTimeFilter<"LocationNote"> | Date | string
    updatedAt?: DateTimeFilter<"LocationNote"> | Date | string
    actor?: EnumEnumLocationNoteActorFilter<"LocationNote"> | $Enums.EnumLocationNoteActor
    locationId?: StringNullableFilter<"LocationNote"> | string | null
    deliveryId?: StringNullableFilter<"LocationNote"> | string | null
    courierId?: StringNullableFilter<"LocationNote"> | string | null
    locations?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    delivery?: XOR<DeliveryNullableRelationFilter, DeliveryWhereInput> | null
    couriers?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
    noteReactions?: LocationNoteReactionListRelationFilter
  }

  export type LocationNoteOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    actor?: SortOrder
    locationId?: SortOrderInput | SortOrder
    deliveryId?: SortOrderInput | SortOrder
    courierId?: SortOrderInput | SortOrder
    locations?: LocationOrderByWithRelationAndSearchRelevanceInput
    delivery?: DeliveryOrderByWithRelationAndSearchRelevanceInput
    couriers?: CourierOrderByWithRelationAndSearchRelevanceInput
    noteReactions?: LocationNoteReactionOrderByRelationAggregateInput
    _relevance?: LocationNoteOrderByRelevanceInput
  }

  export type LocationNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationNoteWhereInput | LocationNoteWhereInput[]
    OR?: LocationNoteWhereInput[]
    NOT?: LocationNoteWhereInput | LocationNoteWhereInput[]
    note?: StringNullableFilter<"LocationNote"> | string | null
    createdAt?: DateTimeFilter<"LocationNote"> | Date | string
    updatedAt?: DateTimeFilter<"LocationNote"> | Date | string
    actor?: EnumEnumLocationNoteActorFilter<"LocationNote"> | $Enums.EnumLocationNoteActor
    locationId?: StringNullableFilter<"LocationNote"> | string | null
    deliveryId?: StringNullableFilter<"LocationNote"> | string | null
    courierId?: StringNullableFilter<"LocationNote"> | string | null
    locations?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    delivery?: XOR<DeliveryNullableRelationFilter, DeliveryWhereInput> | null
    couriers?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
    noteReactions?: LocationNoteReactionListRelationFilter
  }, "id">

  export type LocationNoteOrderByWithAggregationInput = {
    id?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    actor?: SortOrder
    locationId?: SortOrderInput | SortOrder
    deliveryId?: SortOrderInput | SortOrder
    courierId?: SortOrderInput | SortOrder
    _count?: LocationNoteCountOrderByAggregateInput
    _max?: LocationNoteMaxOrderByAggregateInput
    _min?: LocationNoteMinOrderByAggregateInput
  }

  export type LocationNoteScalarWhereWithAggregatesInput = {
    AND?: LocationNoteScalarWhereWithAggregatesInput | LocationNoteScalarWhereWithAggregatesInput[]
    OR?: LocationNoteScalarWhereWithAggregatesInput[]
    NOT?: LocationNoteScalarWhereWithAggregatesInput | LocationNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocationNote"> | string
    note?: StringNullableWithAggregatesFilter<"LocationNote"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LocationNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LocationNote"> | Date | string
    actor?: EnumEnumLocationNoteActorWithAggregatesFilter<"LocationNote"> | $Enums.EnumLocationNoteActor
    locationId?: StringNullableWithAggregatesFilter<"LocationNote"> | string | null
    deliveryId?: StringNullableWithAggregatesFilter<"LocationNote"> | string | null
    courierId?: StringNullableWithAggregatesFilter<"LocationNote"> | string | null
  }

  export type LocationNoteReactionWhereInput = {
    AND?: LocationNoteReactionWhereInput | LocationNoteReactionWhereInput[]
    OR?: LocationNoteReactionWhereInput[]
    NOT?: LocationNoteReactionWhereInput | LocationNoteReactionWhereInput[]
    id?: StringFilter<"LocationNoteReaction"> | string
    reaction?: EnumEnumLocationNoteReactionTypeFilter<"LocationNoteReaction"> | $Enums.EnumLocationNoteReactionType
    createdAt?: DateTimeFilter<"LocationNoteReaction"> | Date | string
    updatedAt?: DateTimeFilter<"LocationNoteReaction"> | Date | string
    locationNoteId?: StringFilter<"LocationNoteReaction"> | string
    courierId?: StringFilter<"LocationNoteReaction"> | string
    locationNote?: XOR<LocationNoteRelationFilter, LocationNoteWhereInput>
    couriers?: XOR<CourierRelationFilter, CourierWhereInput>
  }

  export type LocationNoteReactionOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationNoteId?: SortOrder
    courierId?: SortOrder
    locationNote?: LocationNoteOrderByWithRelationAndSearchRelevanceInput
    couriers?: CourierOrderByWithRelationAndSearchRelevanceInput
    _relevance?: LocationNoteReactionOrderByRelevanceInput
  }

  export type LocationNoteReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationNoteReactionWhereInput | LocationNoteReactionWhereInput[]
    OR?: LocationNoteReactionWhereInput[]
    NOT?: LocationNoteReactionWhereInput | LocationNoteReactionWhereInput[]
    reaction?: EnumEnumLocationNoteReactionTypeFilter<"LocationNoteReaction"> | $Enums.EnumLocationNoteReactionType
    createdAt?: DateTimeFilter<"LocationNoteReaction"> | Date | string
    updatedAt?: DateTimeFilter<"LocationNoteReaction"> | Date | string
    locationNoteId?: StringFilter<"LocationNoteReaction"> | string
    courierId?: StringFilter<"LocationNoteReaction"> | string
    locationNote?: XOR<LocationNoteRelationFilter, LocationNoteWhereInput>
    couriers?: XOR<CourierRelationFilter, CourierWhereInput>
  }, "id">

  export type LocationNoteReactionOrderByWithAggregationInput = {
    id?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationNoteId?: SortOrder
    courierId?: SortOrder
    _count?: LocationNoteReactionCountOrderByAggregateInput
    _max?: LocationNoteReactionMaxOrderByAggregateInput
    _min?: LocationNoteReactionMinOrderByAggregateInput
  }

  export type LocationNoteReactionScalarWhereWithAggregatesInput = {
    AND?: LocationNoteReactionScalarWhereWithAggregatesInput | LocationNoteReactionScalarWhereWithAggregatesInput[]
    OR?: LocationNoteReactionScalarWhereWithAggregatesInput[]
    NOT?: LocationNoteReactionScalarWhereWithAggregatesInput | LocationNoteReactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocationNoteReaction"> | string
    reaction?: EnumEnumLocationNoteReactionTypeWithAggregatesFilter<"LocationNoteReaction"> | $Enums.EnumLocationNoteReactionType
    createdAt?: DateTimeWithAggregatesFilter<"LocationNoteReaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LocationNoteReaction"> | Date | string
    locationNoteId?: StringWithAggregatesFilter<"LocationNoteReaction"> | string
    courierId?: StringWithAggregatesFilter<"LocationNoteReaction"> | string
  }

  export type CourierSettingWhereInput = {
    AND?: CourierSettingWhereInput | CourierSettingWhereInput[]
    OR?: CourierSettingWhereInput[]
    NOT?: CourierSettingWhereInput | CourierSettingWhereInput[]
    id?: StringFilter<"CourierSetting"> | string
    vehicleType?: EnumEnumSettingVehicleTypeNullableFilter<"CourierSetting"> | $Enums.EnumSettingVehicleType | null
    preferredAreas?: StringNullableListFilter<"CourierSetting">
    shiftAvailability?: JsonNullableFilter<"CourierSetting">
    deliveryPreferences?: StringNullableListFilter<"CourierSetting">
    foodPreferences?: StringNullableListFilter<"CourierSetting">
    earningGoals?: JsonNullableFilter<"CourierSetting">
    deliverySpeed?: EnumEnumSettingDeliverySpeedNullableFilter<"CourierSetting"> | $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes?: StringNullableListFilter<"CourierSetting">
    cuisineTypes?: StringNullableListFilter<"CourierSetting">
    preferredRestaurantPartners?: StringNullableListFilter<"CourierSetting">
    dietaryRestrictions?: StringNullableListFilter<"CourierSetting">
    payRate?: JsonNullableFilter<"CourierSetting">
    createdAt?: DateTimeFilter<"CourierSetting"> | Date | string
    updatedAt?: DateTimeFilter<"CourierSetting"> | Date | string
    courierId?: StringNullableFilter<"CourierSetting"> | string | null
    couriers?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
  }

  export type CourierSettingOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    vehicleType?: SortOrderInput | SortOrder
    preferredAreas?: SortOrder
    shiftAvailability?: SortOrderInput | SortOrder
    deliveryPreferences?: SortOrder
    foodPreferences?: SortOrder
    earningGoals?: SortOrderInput | SortOrder
    deliverySpeed?: SortOrderInput | SortOrder
    restaurantTypes?: SortOrder
    cuisineTypes?: SortOrder
    preferredRestaurantPartners?: SortOrder
    dietaryRestrictions?: SortOrder
    payRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrderInput | SortOrder
    couriers?: CourierOrderByWithRelationAndSearchRelevanceInput
    _relevance?: CourierSettingOrderByRelevanceInput
  }

  export type CourierSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courierId?: string
    AND?: CourierSettingWhereInput | CourierSettingWhereInput[]
    OR?: CourierSettingWhereInput[]
    NOT?: CourierSettingWhereInput | CourierSettingWhereInput[]
    vehicleType?: EnumEnumSettingVehicleTypeNullableFilter<"CourierSetting"> | $Enums.EnumSettingVehicleType | null
    preferredAreas?: StringNullableListFilter<"CourierSetting">
    shiftAvailability?: JsonNullableFilter<"CourierSetting">
    deliveryPreferences?: StringNullableListFilter<"CourierSetting">
    foodPreferences?: StringNullableListFilter<"CourierSetting">
    earningGoals?: JsonNullableFilter<"CourierSetting">
    deliverySpeed?: EnumEnumSettingDeliverySpeedNullableFilter<"CourierSetting"> | $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes?: StringNullableListFilter<"CourierSetting">
    cuisineTypes?: StringNullableListFilter<"CourierSetting">
    preferredRestaurantPartners?: StringNullableListFilter<"CourierSetting">
    dietaryRestrictions?: StringNullableListFilter<"CourierSetting">
    payRate?: JsonNullableFilter<"CourierSetting">
    createdAt?: DateTimeFilter<"CourierSetting"> | Date | string
    updatedAt?: DateTimeFilter<"CourierSetting"> | Date | string
    couriers?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
  }, "id" | "courierId">

  export type CourierSettingOrderByWithAggregationInput = {
    id?: SortOrder
    vehicleType?: SortOrderInput | SortOrder
    preferredAreas?: SortOrder
    shiftAvailability?: SortOrderInput | SortOrder
    deliveryPreferences?: SortOrder
    foodPreferences?: SortOrder
    earningGoals?: SortOrderInput | SortOrder
    deliverySpeed?: SortOrderInput | SortOrder
    restaurantTypes?: SortOrder
    cuisineTypes?: SortOrder
    preferredRestaurantPartners?: SortOrder
    dietaryRestrictions?: SortOrder
    payRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrderInput | SortOrder
    _count?: CourierSettingCountOrderByAggregateInput
    _max?: CourierSettingMaxOrderByAggregateInput
    _min?: CourierSettingMinOrderByAggregateInput
  }

  export type CourierSettingScalarWhereWithAggregatesInput = {
    AND?: CourierSettingScalarWhereWithAggregatesInput | CourierSettingScalarWhereWithAggregatesInput[]
    OR?: CourierSettingScalarWhereWithAggregatesInput[]
    NOT?: CourierSettingScalarWhereWithAggregatesInput | CourierSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourierSetting"> | string
    vehicleType?: EnumEnumSettingVehicleTypeNullableWithAggregatesFilter<"CourierSetting"> | $Enums.EnumSettingVehicleType | null
    preferredAreas?: StringNullableListFilter<"CourierSetting">
    shiftAvailability?: JsonNullableWithAggregatesFilter<"CourierSetting">
    deliveryPreferences?: StringNullableListFilter<"CourierSetting">
    foodPreferences?: StringNullableListFilter<"CourierSetting">
    earningGoals?: JsonNullableWithAggregatesFilter<"CourierSetting">
    deliverySpeed?: EnumEnumSettingDeliverySpeedNullableWithAggregatesFilter<"CourierSetting"> | $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes?: StringNullableListFilter<"CourierSetting">
    cuisineTypes?: StringNullableListFilter<"CourierSetting">
    preferredRestaurantPartners?: StringNullableListFilter<"CourierSetting">
    dietaryRestrictions?: StringNullableListFilter<"CourierSetting">
    payRate?: JsonNullableWithAggregatesFilter<"CourierSetting">
    createdAt?: DateTimeWithAggregatesFilter<"CourierSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourierSetting"> | Date | string
    courierId?: StringNullableWithAggregatesFilter<"CourierSetting"> | string | null
  }

  export type PayoutWhereInput = {
    AND?: PayoutWhereInput | PayoutWhereInput[]
    OR?: PayoutWhereInput[]
    NOT?: PayoutWhereInput | PayoutWhereInput[]
    id?: StringFilter<"Payout"> | string
    amount?: IntFilter<"Payout"> | number
    arrivalDate?: DateTimeFilter<"Payout"> | Date | string
    description?: StringNullableFilter<"Payout"> | string | null
    statementDescriptor?: StringNullableFilter<"Payout"> | string | null
    status?: EnumEnumPayoutStatusFilter<"Payout"> | $Enums.EnumPayoutStatus
    paymentId?: StringFilter<"Payout"> | string
    courierId?: StringNullableFilter<"Payout"> | string | null
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
    courier?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
  }

  export type PayoutOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    amount?: SortOrder
    arrivalDate?: SortOrder
    description?: SortOrderInput | SortOrder
    statementDescriptor?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    courierId?: SortOrderInput | SortOrder
    payment?: PaymentOrderByWithRelationAndSearchRelevanceInput
    courier?: CourierOrderByWithRelationAndSearchRelevanceInput
    _relevance?: PayoutOrderByRelevanceInput
  }

  export type PayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayoutWhereInput | PayoutWhereInput[]
    OR?: PayoutWhereInput[]
    NOT?: PayoutWhereInput | PayoutWhereInput[]
    amount?: IntFilter<"Payout"> | number
    arrivalDate?: DateTimeFilter<"Payout"> | Date | string
    description?: StringNullableFilter<"Payout"> | string | null
    statementDescriptor?: StringNullableFilter<"Payout"> | string | null
    status?: EnumEnumPayoutStatusFilter<"Payout"> | $Enums.EnumPayoutStatus
    paymentId?: StringFilter<"Payout"> | string
    courierId?: StringNullableFilter<"Payout"> | string | null
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
    courier?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
  }, "id">

  export type PayoutOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    arrivalDate?: SortOrder
    description?: SortOrderInput | SortOrder
    statementDescriptor?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    courierId?: SortOrderInput | SortOrder
    _count?: PayoutCountOrderByAggregateInput
    _avg?: PayoutAvgOrderByAggregateInput
    _max?: PayoutMaxOrderByAggregateInput
    _min?: PayoutMinOrderByAggregateInput
    _sum?: PayoutSumOrderByAggregateInput
  }

  export type PayoutScalarWhereWithAggregatesInput = {
    AND?: PayoutScalarWhereWithAggregatesInput | PayoutScalarWhereWithAggregatesInput[]
    OR?: PayoutScalarWhereWithAggregatesInput[]
    NOT?: PayoutScalarWhereWithAggregatesInput | PayoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payout"> | string
    amount?: IntWithAggregatesFilter<"Payout"> | number
    arrivalDate?: DateTimeWithAggregatesFilter<"Payout"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Payout"> | string | null
    statementDescriptor?: StringNullableWithAggregatesFilter<"Payout"> | string | null
    status?: EnumEnumPayoutStatusWithAggregatesFilter<"Payout"> | $Enums.EnumPayoutStatus
    paymentId?: StringWithAggregatesFilter<"Payout"> | string
    courierId?: StringNullableWithAggregatesFilter<"Payout"> | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    capturedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFilter<"Payment"> | $Enums.EnumPaymentStatus
    deliveryId?: StringFilter<"Payment"> | string
    provider?: EnumEnumPaymentProviderFilter<"Payment"> | $Enums.EnumPaymentProvider
    delivery?: XOR<DeliveryRelationFilter, DeliveryWhereInput>
    transfers?: TransferListRelationFilter
    refunds?: RefundListRelationFilter
    payouts?: PayoutListRelationFilter
    stripeData?: XOR<StripePaymentDataNullableRelationFilter, StripePaymentDataWhereInput> | null
  }

  export type PaymentOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    capturedAt?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    deliveryId?: SortOrder
    provider?: SortOrder
    delivery?: DeliveryOrderByWithRelationAndSearchRelevanceInput
    transfers?: TransferOrderByRelationAggregateInput
    refunds?: RefundOrderByRelationAggregateInput
    payouts?: PayoutOrderByRelationAggregateInput
    stripeData?: StripePaymentDataOrderByWithRelationAndSearchRelevanceInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    capturedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFilter<"Payment"> | $Enums.EnumPaymentStatus
    deliveryId?: StringFilter<"Payment"> | string
    provider?: EnumEnumPaymentProviderFilter<"Payment"> | $Enums.EnumPaymentProvider
    delivery?: XOR<DeliveryRelationFilter, DeliveryWhereInput>
    transfers?: TransferListRelationFilter
    refunds?: RefundListRelationFilter
    payouts?: PayoutListRelationFilter
    stripeData?: XOR<StripePaymentDataNullableRelationFilter, StripePaymentDataWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    capturedAt?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    deliveryId?: SortOrder
    provider?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    capturedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.EnumPaymentStatus
    deliveryId?: StringWithAggregatesFilter<"Payment"> | string
    provider?: EnumEnumPaymentProviderWithAggregatesFilter<"Payment"> | $Enums.EnumPaymentProvider
  }

  export type StripePaymentDataWhereInput = {
    AND?: StripePaymentDataWhereInput | StripePaymentDataWhereInput[]
    OR?: StripePaymentDataWhereInput[]
    NOT?: StripePaymentDataWhereInput | StripePaymentDataWhereInput[]
    id?: StringFilter<"StripePaymentData"> | string
    paymentIntentId?: StringFilter<"StripePaymentData"> | string
    paymentMethodId?: StringFilter<"StripePaymentData"> | string
    latestChargeId?: StringNullableFilter<"StripePaymentData"> | string | null
    paymentId?: StringNullableFilter<"StripePaymentData"> | string | null
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
  }

  export type StripePaymentDataOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    paymentIntentId?: SortOrder
    paymentMethodId?: SortOrder
    latestChargeId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    payment?: PaymentOrderByWithRelationAndSearchRelevanceInput
    _relevance?: StripePaymentDataOrderByRelevanceInput
  }

  export type StripePaymentDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentIntentId?: string
    latestChargeId?: string
    paymentId?: string
    AND?: StripePaymentDataWhereInput | StripePaymentDataWhereInput[]
    OR?: StripePaymentDataWhereInput[]
    NOT?: StripePaymentDataWhereInput | StripePaymentDataWhereInput[]
    paymentMethodId?: StringFilter<"StripePaymentData"> | string
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
  }, "id" | "paymentIntentId" | "latestChargeId" | "paymentId">

  export type StripePaymentDataOrderByWithAggregationInput = {
    id?: SortOrder
    paymentIntentId?: SortOrder
    paymentMethodId?: SortOrder
    latestChargeId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    _count?: StripePaymentDataCountOrderByAggregateInput
    _max?: StripePaymentDataMaxOrderByAggregateInput
    _min?: StripePaymentDataMinOrderByAggregateInput
  }

  export type StripePaymentDataScalarWhereWithAggregatesInput = {
    AND?: StripePaymentDataScalarWhereWithAggregatesInput | StripePaymentDataScalarWhereWithAggregatesInput[]
    OR?: StripePaymentDataScalarWhereWithAggregatesInput[]
    NOT?: StripePaymentDataScalarWhereWithAggregatesInput | StripePaymentDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StripePaymentData"> | string
    paymentIntentId?: StringWithAggregatesFilter<"StripePaymentData"> | string
    paymentMethodId?: StringWithAggregatesFilter<"StripePaymentData"> | string
    latestChargeId?: StringNullableWithAggregatesFilter<"StripePaymentData"> | string | null
    paymentId?: StringNullableWithAggregatesFilter<"StripePaymentData"> | string | null
  }

  export type TransferWhereInput = {
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    id?: StringFilter<"Transfer"> | string
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    transferId?: StringFilter<"Transfer"> | string
    amount?: IntFilter<"Transfer"> | number
    amountReversed?: IntFilter<"Transfer"> | number
    destination?: StringFilter<"Transfer"> | string
    destinationPayment?: StringNullableFilter<"Transfer"> | string | null
    reversed?: BoolFilter<"Transfer"> | boolean
    paymentId?: StringNullableFilter<"Transfer"> | string | null
    courierId?: StringNullableFilter<"Transfer"> | string | null
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
    courier?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
  }

  export type TransferOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transferId?: SortOrder
    amount?: SortOrder
    amountReversed?: SortOrder
    destination?: SortOrder
    destinationPayment?: SortOrderInput | SortOrder
    reversed?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    courierId?: SortOrderInput | SortOrder
    payment?: PaymentOrderByWithRelationAndSearchRelevanceInput
    courier?: CourierOrderByWithRelationAndSearchRelevanceInput
    _relevance?: TransferOrderByRelevanceInput
  }

  export type TransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transferId?: string
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    amount?: IntFilter<"Transfer"> | number
    amountReversed?: IntFilter<"Transfer"> | number
    destination?: StringFilter<"Transfer"> | string
    destinationPayment?: StringNullableFilter<"Transfer"> | string | null
    reversed?: BoolFilter<"Transfer"> | boolean
    paymentId?: StringNullableFilter<"Transfer"> | string | null
    courierId?: StringNullableFilter<"Transfer"> | string | null
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
    courier?: XOR<CourierNullableRelationFilter, CourierWhereInput> | null
  }, "id" | "transferId">

  export type TransferOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transferId?: SortOrder
    amount?: SortOrder
    amountReversed?: SortOrder
    destination?: SortOrder
    destinationPayment?: SortOrderInput | SortOrder
    reversed?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    courierId?: SortOrderInput | SortOrder
    _count?: TransferCountOrderByAggregateInput
    _avg?: TransferAvgOrderByAggregateInput
    _max?: TransferMaxOrderByAggregateInput
    _min?: TransferMinOrderByAggregateInput
    _sum?: TransferSumOrderByAggregateInput
  }

  export type TransferScalarWhereWithAggregatesInput = {
    AND?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    OR?: TransferScalarWhereWithAggregatesInput[]
    NOT?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transfer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    transferId?: StringWithAggregatesFilter<"Transfer"> | string
    amount?: IntWithAggregatesFilter<"Transfer"> | number
    amountReversed?: IntWithAggregatesFilter<"Transfer"> | number
    destination?: StringWithAggregatesFilter<"Transfer"> | string
    destinationPayment?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    reversed?: BoolWithAggregatesFilter<"Transfer"> | boolean
    paymentId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    courierId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
  }

  export type RefundWhereInput = {
    AND?: RefundWhereInput | RefundWhereInput[]
    OR?: RefundWhereInput[]
    NOT?: RefundWhereInput | RefundWhereInput[]
    id?: StringFilter<"Refund"> | string
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    updatedAt?: DateTimeFilter<"Refund"> | Date | string
    refundId?: StringNullableFilter<"Refund"> | string | null
    amount?: IntFilter<"Refund"> | number
    description?: StringNullableFilter<"Refund"> | string | null
    reason?: EnumEnumRefundReasonNullableFilter<"Refund"> | $Enums.EnumRefundReason | null
    status?: EnumEnumRefundStatusNullableFilter<"Refund"> | $Enums.EnumRefundStatus | null
    paymentId?: StringFilter<"Refund"> | string
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
  }

  export type RefundOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundId?: SortOrderInput | SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    paymentId?: SortOrder
    payment?: PaymentOrderByWithRelationAndSearchRelevanceInput
    _relevance?: RefundOrderByRelevanceInput
  }

  export type RefundWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refundId?: string
    AND?: RefundWhereInput | RefundWhereInput[]
    OR?: RefundWhereInput[]
    NOT?: RefundWhereInput | RefundWhereInput[]
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    updatedAt?: DateTimeFilter<"Refund"> | Date | string
    amount?: IntFilter<"Refund"> | number
    description?: StringNullableFilter<"Refund"> | string | null
    reason?: EnumEnumRefundReasonNullableFilter<"Refund"> | $Enums.EnumRefundReason | null
    status?: EnumEnumRefundStatusNullableFilter<"Refund"> | $Enums.EnumRefundStatus | null
    paymentId?: StringFilter<"Refund"> | string
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
  }, "id" | "refundId">

  export type RefundOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundId?: SortOrderInput | SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    paymentId?: SortOrder
    _count?: RefundCountOrderByAggregateInput
    _avg?: RefundAvgOrderByAggregateInput
    _max?: RefundMaxOrderByAggregateInput
    _min?: RefundMinOrderByAggregateInput
    _sum?: RefundSumOrderByAggregateInput
  }

  export type RefundScalarWhereWithAggregatesInput = {
    AND?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[]
    OR?: RefundScalarWhereWithAggregatesInput[]
    NOT?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Refund"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Refund"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Refund"> | Date | string
    refundId?: StringNullableWithAggregatesFilter<"Refund"> | string | null
    amount?: IntWithAggregatesFilter<"Refund"> | number
    description?: StringNullableWithAggregatesFilter<"Refund"> | string | null
    reason?: EnumEnumRefundReasonNullableWithAggregatesFilter<"Refund"> | $Enums.EnumRefundReason | null
    status?: EnumEnumRefundStatusNullableWithAggregatesFilter<"Refund"> | $Enums.EnumRefundStatus | null
    paymentId?: StringWithAggregatesFilter<"Refund"> | string
  }

  export type ConfigWhereInput = {
    AND?: ConfigWhereInput | ConfigWhereInput[]
    OR?: ConfigWhereInput[]
    NOT?: ConfigWhereInput | ConfigWhereInput[]
    key?: StringFilter<"Config"> | string
    type?: StringFilter<"Config"> | string
    value?: StringFilter<"Config"> | string
  }

  export type ConfigOrderByWithRelationAndSearchRelevanceInput = {
    key?: SortOrder
    type?: SortOrder
    value?: SortOrder
    _relevance?: ConfigOrderByRelevanceInput
  }

  export type ConfigWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: ConfigWhereInput | ConfigWhereInput[]
    OR?: ConfigWhereInput[]
    NOT?: ConfigWhereInput | ConfigWhereInput[]
    type?: StringFilter<"Config"> | string
    value?: StringFilter<"Config"> | string
  }, "key">

  export type ConfigOrderByWithAggregationInput = {
    key?: SortOrder
    type?: SortOrder
    value?: SortOrder
    _count?: ConfigCountOrderByAggregateInput
    _max?: ConfigMaxOrderByAggregateInput
    _min?: ConfigMinOrderByAggregateInput
  }

  export type ConfigScalarWhereWithAggregatesInput = {
    AND?: ConfigScalarWhereWithAggregatesInput | ConfigScalarWhereWithAggregatesInput[]
    OR?: ConfigScalarWhereWithAggregatesInput[]
    NOT?: ConfigScalarWhereWithAggregatesInput | ConfigScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"Config"> | string
    type?: StringWithAggregatesFilter<"Config"> | string
    value?: StringWithAggregatesFilter<"Config"> | string
  }

  export type spatial_ref_sysWhereInput = {
    AND?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    OR?: spatial_ref_sysWhereInput[]
    NOT?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    srid?: IntFilter<"spatial_ref_sys"> | number
    auth_name?: StringNullableFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableFilter<"spatial_ref_sys"> | string | null
  }

  export type spatial_ref_sysOrderByWithRelationAndSearchRelevanceInput = {
    srid?: SortOrder
    auth_name?: SortOrderInput | SortOrder
    auth_srid?: SortOrderInput | SortOrder
    srtext?: SortOrderInput | SortOrder
    proj4text?: SortOrderInput | SortOrder
    _relevance?: spatial_ref_sysOrderByRelevanceInput
  }

  export type spatial_ref_sysWhereUniqueInput = Prisma.AtLeast<{
    srid?: number
    AND?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    OR?: spatial_ref_sysWhereInput[]
    NOT?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    auth_name?: StringNullableFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableFilter<"spatial_ref_sys"> | string | null
  }, "srid">

  export type spatial_ref_sysOrderByWithAggregationInput = {
    srid?: SortOrder
    auth_name?: SortOrderInput | SortOrder
    auth_srid?: SortOrderInput | SortOrder
    srtext?: SortOrderInput | SortOrder
    proj4text?: SortOrderInput | SortOrder
    _count?: spatial_ref_sysCountOrderByAggregateInput
    _avg?: spatial_ref_sysAvgOrderByAggregateInput
    _max?: spatial_ref_sysMaxOrderByAggregateInput
    _min?: spatial_ref_sysMinOrderByAggregateInput
    _sum?: spatial_ref_sysSumOrderByAggregateInput
  }

  export type spatial_ref_sysScalarWhereWithAggregatesInput = {
    AND?: spatial_ref_sysScalarWhereWithAggregatesInput | spatial_ref_sysScalarWhereWithAggregatesInput[]
    OR?: spatial_ref_sysScalarWhereWithAggregatesInput[]
    NOT?: spatial_ref_sysScalarWhereWithAggregatesInput | spatial_ref_sysScalarWhereWithAggregatesInput[]
    srid?: IntWithAggregatesFilter<"spatial_ref_sys"> | number
    auth_name?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableWithAggregatesFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    password?: string | null
    role?: UserCreateroleInput | $Enums.EnumUserRole[]
    username?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courier?: CourierCreateNestedOneWithoutUserInput
    partner?: PartnerCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    password?: string | null
    role?: UserCreateroleInput | $Enums.EnumUserRole[]
    username?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courier?: CourierUncheckedCreateNestedOneWithoutUserInput
    partner?: PartnerUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | $Enums.EnumUserRole[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courier?: CourierUpdateOneWithoutUserNestedInput
    partner?: PartnerUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | $Enums.EnumUserRole[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courier?: CourierUncheckedUpdateOneWithoutUserNestedInput
    partner?: PartnerUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    password?: string | null
    role?: UserCreateroleInput | $Enums.EnumUserRole[]
    username?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | $Enums.EnumUserRole[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | $Enums.EnumUserRole[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    text?: string | null
    likes?: number | null
    likers?: CommentCreatelikersInput | string[]
    commentableId: string
    commentableType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    couriers?: CourierCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    text?: string | null
    likes?: number | null
    likers?: CommentCreatelikersInput | string[]
    commentableId: string
    commentableType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courierId?: string | null
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    likers?: CommentUpdatelikersInput | string[]
    commentableId?: StringFieldUpdateOperationsInput | string
    commentableType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couriers?: CourierUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    likers?: CommentUpdatelikersInput | string[]
    commentableId?: StringFieldUpdateOperationsInput | string
    commentableType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateManyInput = {
    id?: string
    text?: string | null
    likes?: number | null
    likers?: CommentCreatelikersInput | string[]
    commentableId: string
    commentableType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courierId?: string | null
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    likers?: CommentUpdatelikersInput | string[]
    commentableId?: StringFieldUpdateOperationsInput | string
    commentableType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    likers?: CommentUpdatelikersInput | string[]
    commentableId?: StringFieldUpdateOperationsInput | string
    commentableType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourierCreateInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    user: UserCreateNestedOneWithoutCourierInput
    comments?: CommentCreateNestedManyWithoutCouriersInput
    earnings?: EarningCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    settings?: CourierSettingCreateNestedOneWithoutCouriersInput
    Payout?: PayoutCreateNestedManyWithoutCourierInput
    Transfer?: TransferCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionCreateNestedManyWithoutCouriersInput
  }

  export type CourierUncheckedCreateInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedCreateNestedManyWithoutCouriersInput
    earnings?: EarningUncheckedCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    settings?: CourierSettingUncheckedCreateNestedOneWithoutCouriersInput
    Payout?: PayoutUncheckedCreateNestedManyWithoutCourierInput
    Transfer?: TransferUncheckedCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteUncheckedCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionUncheckedCreateNestedManyWithoutCouriersInput
  }

  export type CourierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    comments?: CommentUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUpdateManyWithoutCouriersNestedInput
  }

  export type CourierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUncheckedUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUncheckedUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUncheckedUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUncheckedUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUncheckedUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUncheckedUpdateManyWithoutCouriersNestedInput
  }

  export type CourierCreateManyInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
  }

  export type CourierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
  }

  export type CourierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
  }

  export type EarningCreateInput = {
    id?: string
    total: number
    pending: number
    received: number
    payoutMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    couriers?: CourierCreateNestedOneWithoutEarningsInput
  }

  export type EarningUncheckedCreateInput = {
    id?: string
    total: number
    pending: number
    received: number
    payoutMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courierId?: string | null
  }

  export type EarningUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    received?: IntFieldUpdateOperationsInput | number
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couriers?: CourierUpdateOneWithoutEarningsNestedInput
  }

  export type EarningUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    received?: IntFieldUpdateOperationsInput | number
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EarningCreateManyInput = {
    id?: string
    total: number
    pending: number
    received: number
    payoutMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courierId?: string | null
  }

  export type EarningUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    received?: IntFieldUpdateOperationsInput | number
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EarningUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    received?: IntFieldUpdateOperationsInput | number
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationCreateInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    street?: string | null
    zipCode?: string | null
    countryCode?: $Enums.EnumCountryCode
    stateCode?: string | null
    houseNumber?: string | null
    longitude: number
    latitude: number
    formattedAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNotes?: LocationNoteCreateNestedManyWithoutLocationsInput
    pickupDelivery?: DeliveryCreateNestedManyWithoutPickupLocationInput
    dropoffDelivery?: DeliveryCreateNestedManyWithoutDropoffLocationInput
    pickupDeliveryQuotes?: DeliveryQuoteCreateNestedManyWithoutPickupLocationInput
    dropoffDeliveryQuotes?: DeliveryQuoteCreateNestedManyWithoutDropoffLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    street?: string | null
    zipCode?: string | null
    countryCode?: $Enums.EnumCountryCode
    stateCode?: string | null
    houseNumber?: string | null
    longitude: number
    latitude: number
    formattedAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNotes?: LocationNoteUncheckedCreateNestedManyWithoutLocationsInput
    pickupDelivery?: DeliveryUncheckedCreateNestedManyWithoutPickupLocationInput
    dropoffDelivery?: DeliveryUncheckedCreateNestedManyWithoutDropoffLocationInput
    pickupDeliveryQuotes?: DeliveryQuoteUncheckedCreateNestedManyWithoutPickupLocationInput
    dropoffDeliveryQuotes?: DeliveryQuoteUncheckedCreateNestedManyWithoutDropoffLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: EnumEnumCountryCodeFieldUpdateOperationsInput | $Enums.EnumCountryCode
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    formattedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNotes?: LocationNoteUpdateManyWithoutLocationsNestedInput
    pickupDelivery?: DeliveryUpdateManyWithoutPickupLocationNestedInput
    dropoffDelivery?: DeliveryUpdateManyWithoutDropoffLocationNestedInput
    pickupDeliveryQuotes?: DeliveryQuoteUpdateManyWithoutPickupLocationNestedInput
    dropoffDeliveryQuotes?: DeliveryQuoteUpdateManyWithoutDropoffLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: EnumEnumCountryCodeFieldUpdateOperationsInput | $Enums.EnumCountryCode
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    formattedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNotes?: LocationNoteUncheckedUpdateManyWithoutLocationsNestedInput
    pickupDelivery?: DeliveryUncheckedUpdateManyWithoutPickupLocationNestedInput
    dropoffDelivery?: DeliveryUncheckedUpdateManyWithoutDropoffLocationNestedInput
    pickupDeliveryQuotes?: DeliveryQuoteUncheckedUpdateManyWithoutPickupLocationNestedInput
    dropoffDeliveryQuotes?: DeliveryQuoteUncheckedUpdateManyWithoutDropoffLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    street?: string | null
    zipCode?: string | null
    countryCode?: $Enums.EnumCountryCode
    stateCode?: string | null
    houseNumber?: string | null
    longitude: number
    latitude: number
    formattedAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: EnumEnumCountryCodeFieldUpdateOperationsInput | $Enums.EnumCountryCode
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    formattedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: EnumEnumCountryCodeFieldUpdateOperationsInput | $Enums.EnumCountryCode
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    formattedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerCreateInput = {
    id?: string
    name: string
    logo?: string | null
    phoneNumber?: string | null
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: DeliveryCreateNestedManyWithoutPartnerInput
    deliveryQuotes?: DeliveryQuoteCreateNestedManyWithoutPartnersInput
    user?: UserCreateNestedOneWithoutPartnerInput
  }

  export type PartnerUncheckedCreateInput = {
    id?: string
    name: string
    logo?: string | null
    phoneNumber?: string | null
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutPartnerInput
    deliveryQuotes?: DeliveryQuoteUncheckedCreateNestedManyWithoutPartnersInput
  }

  export type PartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: DeliveryUpdateManyWithoutPartnerNestedInput
    deliveryQuotes?: DeliveryQuoteUpdateManyWithoutPartnersNestedInput
    user?: UserUpdateOneWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveries?: DeliveryUncheckedUpdateManyWithoutPartnerNestedInput
    deliveryQuotes?: DeliveryQuoteUncheckedUpdateManyWithoutPartnersNestedInput
  }

  export type PartnerCreateManyInput = {
    id?: string
    name: string
    logo?: string | null
    phoneNumber?: string | null
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type PartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryQuoteCreateInput = {
    id?: string
    quote?: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage?: number
    currency: string
    duration: number
    distance: number
    distanceUnit?: $Enums.EnumDistanceUnit
    pickupPhoneNumber?: string | null
    pickupName?: string | null
    dropoffPhoneNumber?: string | null
    dropoffName?: string | null
    expiresAt?: Date | string | null
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    orderTotalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryId?: string | null
    pickupLocation: LocationCreateNestedOneWithoutPickupDeliveryQuotesInput
    dropoffLocation: LocationCreateNestedOneWithoutDropoffDeliveryQuotesInput
    partners?: PartnerCreateNestedOneWithoutDeliveryQuotesInput
    Delivery?: DeliveryCreateNestedOneWithoutDeliveryInput
  }

  export type DeliveryQuoteUncheckedCreateInput = {
    id?: string
    quote?: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage?: number
    currency: string
    duration: number
    distance: number
    distanceUnit?: $Enums.EnumDistanceUnit
    pickupPhoneNumber?: string | null
    pickupName?: string | null
    dropoffPhoneNumber?: string | null
    dropoffName?: string | null
    expiresAt?: Date | string | null
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    orderTotalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocationId: string
    dropoffLocationId: string
    partnerId?: string | null
    deliveryId?: string | null
    Delivery?: DeliveryUncheckedCreateNestedOneWithoutDeliveryInput
  }

  export type DeliveryQuoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLocation?: LocationUpdateOneRequiredWithoutPickupDeliveryQuotesNestedInput
    dropoffLocation?: LocationUpdateOneRequiredWithoutDropoffDeliveryQuotesNestedInput
    partners?: PartnerUpdateOneWithoutDeliveryQuotesNestedInput
    Delivery?: DeliveryUpdateOneWithoutDeliveryNestedInput
  }

  export type DeliveryQuoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    Delivery?: DeliveryUncheckedUpdateOneWithoutDeliveryNestedInput
  }

  export type DeliveryQuoteCreateManyInput = {
    id?: string
    quote?: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage?: number
    currency: string
    duration: number
    distance: number
    distanceUnit?: $Enums.EnumDistanceUnit
    pickupPhoneNumber?: string | null
    pickupName?: string | null
    dropoffPhoneNumber?: string | null
    dropoffName?: string | null
    expiresAt?: Date | string | null
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    orderTotalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocationId: string
    dropoffLocationId: string
    partnerId?: string | null
    deliveryId?: string | null
  }

  export type DeliveryQuoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryQuoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryCreateInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocation?: LocationCreateNestedOneWithoutPickupDeliveryInput
    dropoffLocation?: LocationCreateNestedOneWithoutDropoffDeliveryInput
    courier?: CourierCreateNestedOneWithoutDeliveriesInput
    partner?: PartnerCreateNestedOneWithoutDeliveriesInput
    delivery: DeliveryQuoteCreateNestedOneWithoutDeliveryInput
    payment?: PaymentCreateNestedManyWithoutDeliveryInput
    deliveryEvent?: DeliveryEventCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId: string
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    dropoffLocationId: string
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    courierId?: string | null
    partnerId?: string | null
    deliveryQuoteId: string
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedManyWithoutDeliveryInput
    deliveryEvent?: DeliveryEventUncheckedCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocation?: LocationUpdateOneWithoutPickupDeliveryNestedInput
    dropoffLocation?: LocationUpdateOneWithoutDropoffDeliveryNestedInput
    courier?: CourierUpdateOneWithoutDeliveriesNestedInput
    partner?: PartnerUpdateOneWithoutDeliveriesNestedInput
    delivery?: DeliveryQuoteUpdateOneRequiredWithoutDeliveryNestedInput
    payment?: PaymentUpdateManyWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQuoteId?: StringFieldUpdateOperationsInput | string
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateManyWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUncheckedUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryCreateManyInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId: string
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    dropoffLocationId: string
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    courierId?: string | null
    partnerId?: string | null
    deliveryQuoteId: string
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQuoteId?: StringFieldUpdateOperationsInput | string
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEventCreateInput = {
    id?: string
    transitionSuccessful: boolean
    type: $Enums.EnumDeliveryEventType
    actor: $Enums.EnumEventActor
    eventSource: $Enums.EnumDeliveryEventSource
    oldStatus?: $Enums.EnumDeliveryStatus | null
    newStatus?: $Enums.EnumDeliveryStatus | null
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    delivery: DeliveryCreateNestedOneWithoutDeliveryEventInput
  }

  export type DeliveryEventUncheckedCreateInput = {
    id?: string
    transitionSuccessful: boolean
    type: $Enums.EnumDeliveryEventType
    actor: $Enums.EnumEventActor
    eventSource: $Enums.EnumDeliveryEventSource
    oldStatus?: $Enums.EnumDeliveryStatus | null
    newStatus?: $Enums.EnumDeliveryStatus | null
    message?: string | null
    deliveryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transitionSuccessful?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumEnumDeliveryEventTypeFieldUpdateOperationsInput | $Enums.EnumDeliveryEventType
    actor?: EnumEnumEventActorFieldUpdateOperationsInput | $Enums.EnumEventActor
    eventSource?: EnumEnumDeliveryEventSourceFieldUpdateOperationsInput | $Enums.EnumDeliveryEventSource
    oldStatus?: NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus | null
    newStatus?: NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery?: DeliveryUpdateOneRequiredWithoutDeliveryEventNestedInput
  }

  export type DeliveryEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transitionSuccessful?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumEnumDeliveryEventTypeFieldUpdateOperationsInput | $Enums.EnumDeliveryEventType
    actor?: EnumEnumEventActorFieldUpdateOperationsInput | $Enums.EnumEventActor
    eventSource?: EnumEnumDeliveryEventSourceFieldUpdateOperationsInput | $Enums.EnumDeliveryEventSource
    oldStatus?: NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus | null
    newStatus?: NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEventCreateManyInput = {
    id?: string
    transitionSuccessful: boolean
    type: $Enums.EnumDeliveryEventType
    actor: $Enums.EnumEventActor
    eventSource: $Enums.EnumDeliveryEventSource
    oldStatus?: $Enums.EnumDeliveryStatus | null
    newStatus?: $Enums.EnumDeliveryStatus | null
    message?: string | null
    deliveryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transitionSuccessful?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumEnumDeliveryEventTypeFieldUpdateOperationsInput | $Enums.EnumDeliveryEventType
    actor?: EnumEnumEventActorFieldUpdateOperationsInput | $Enums.EnumEventActor
    eventSource?: EnumEnumDeliveryEventSourceFieldUpdateOperationsInput | $Enums.EnumDeliveryEventSource
    oldStatus?: NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus | null
    newStatus?: NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transitionSuccessful?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumEnumDeliveryEventTypeFieldUpdateOperationsInput | $Enums.EnumDeliveryEventType
    actor?: EnumEnumEventActorFieldUpdateOperationsInput | $Enums.EnumEventActor
    eventSource?: EnumEnumDeliveryEventSourceFieldUpdateOperationsInput | $Enums.EnumDeliveryEventSource
    oldStatus?: NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus | null
    newStatus?: NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationNoteCreateInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor: $Enums.EnumLocationNoteActor
    locations?: LocationCreateNestedOneWithoutLocationNotesInput
    delivery?: DeliveryCreateNestedOneWithoutLocationNoteInput
    couriers?: CourierCreateNestedOneWithoutLocationNotesInput
    noteReactions?: LocationNoteReactionCreateNestedManyWithoutLocationNoteInput
  }

  export type LocationNoteUncheckedCreateInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor: $Enums.EnumLocationNoteActor
    locationId?: string | null
    deliveryId?: string | null
    courierId?: string | null
    noteReactions?: LocationNoteReactionUncheckedCreateNestedManyWithoutLocationNoteInput
  }

  export type LocationNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
    locations?: LocationUpdateOneWithoutLocationNotesNestedInput
    delivery?: DeliveryUpdateOneWithoutLocationNoteNestedInput
    couriers?: CourierUpdateOneWithoutLocationNotesNestedInput
    noteReactions?: LocationNoteReactionUpdateManyWithoutLocationNoteNestedInput
  }

  export type LocationNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    noteReactions?: LocationNoteReactionUncheckedUpdateManyWithoutLocationNoteNestedInput
  }

  export type LocationNoteCreateManyInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor: $Enums.EnumLocationNoteActor
    locationId?: string | null
    deliveryId?: string | null
    courierId?: string | null
  }

  export type LocationNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
  }

  export type LocationNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationNoteReactionCreateInput = {
    id?: string
    reaction: $Enums.EnumLocationNoteReactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNote: LocationNoteCreateNestedOneWithoutNoteReactionsInput
    couriers: CourierCreateNestedOneWithoutLocationNoteReactionsInput
  }

  export type LocationNoteReactionUncheckedCreateInput = {
    id?: string
    reaction: $Enums.EnumLocationNoteReactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNoteId: string
    courierId: string
  }

  export type LocationNoteReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reaction?: EnumEnumLocationNoteReactionTypeFieldUpdateOperationsInput | $Enums.EnumLocationNoteReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNote?: LocationNoteUpdateOneRequiredWithoutNoteReactionsNestedInput
    couriers?: CourierUpdateOneRequiredWithoutLocationNoteReactionsNestedInput
  }

  export type LocationNoteReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reaction?: EnumEnumLocationNoteReactionTypeFieldUpdateOperationsInput | $Enums.EnumLocationNoteReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNoteId?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
  }

  export type LocationNoteReactionCreateManyInput = {
    id?: string
    reaction: $Enums.EnumLocationNoteReactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNoteId: string
    courierId: string
  }

  export type LocationNoteReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reaction?: EnumEnumLocationNoteReactionTypeFieldUpdateOperationsInput | $Enums.EnumLocationNoteReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationNoteReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reaction?: EnumEnumLocationNoteReactionTypeFieldUpdateOperationsInput | $Enums.EnumLocationNoteReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNoteId?: StringFieldUpdateOperationsInput | string
    courierId?: StringFieldUpdateOperationsInput | string
  }

  export type CourierSettingCreateInput = {
    id?: string
    vehicleType?: $Enums.EnumSettingVehicleType | null
    preferredAreas?: CourierSettingCreatepreferredAreasInput | string[]
    shiftAvailability?: NullableJsonNullValueInput | InputJsonValue
    deliveryPreferences?: CourierSettingCreatedeliveryPreferencesInput | string[]
    foodPreferences?: CourierSettingCreatefoodPreferencesInput | string[]
    earningGoals?: NullableJsonNullValueInput | InputJsonValue
    deliverySpeed?: $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes?: CourierSettingCreaterestaurantTypesInput | string[]
    cuisineTypes?: CourierSettingCreatecuisineTypesInput | string[]
    preferredRestaurantPartners?: CourierSettingCreatepreferredRestaurantPartnersInput | string[]
    dietaryRestrictions?: CourierSettingCreatedietaryRestrictionsInput | string[]
    payRate?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    couriers?: CourierCreateNestedOneWithoutSettingsInput
  }

  export type CourierSettingUncheckedCreateInput = {
    id?: string
    vehicleType?: $Enums.EnumSettingVehicleType | null
    preferredAreas?: CourierSettingCreatepreferredAreasInput | string[]
    shiftAvailability?: NullableJsonNullValueInput | InputJsonValue
    deliveryPreferences?: CourierSettingCreatedeliveryPreferencesInput | string[]
    foodPreferences?: CourierSettingCreatefoodPreferencesInput | string[]
    earningGoals?: NullableJsonNullValueInput | InputJsonValue
    deliverySpeed?: $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes?: CourierSettingCreaterestaurantTypesInput | string[]
    cuisineTypes?: CourierSettingCreatecuisineTypesInput | string[]
    preferredRestaurantPartners?: CourierSettingCreatepreferredRestaurantPartnersInput | string[]
    dietaryRestrictions?: CourierSettingCreatedietaryRestrictionsInput | string[]
    payRate?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    courierId?: string | null
  }

  export type CourierSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableEnumEnumSettingVehicleTypeFieldUpdateOperationsInput | $Enums.EnumSettingVehicleType | null
    preferredAreas?: CourierSettingUpdatepreferredAreasInput | string[]
    shiftAvailability?: NullableJsonNullValueInput | InputJsonValue
    deliveryPreferences?: CourierSettingUpdatedeliveryPreferencesInput | string[]
    foodPreferences?: CourierSettingUpdatefoodPreferencesInput | string[]
    earningGoals?: NullableJsonNullValueInput | InputJsonValue
    deliverySpeed?: NullableEnumEnumSettingDeliverySpeedFieldUpdateOperationsInput | $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes?: CourierSettingUpdaterestaurantTypesInput | string[]
    cuisineTypes?: CourierSettingUpdatecuisineTypesInput | string[]
    preferredRestaurantPartners?: CourierSettingUpdatepreferredRestaurantPartnersInput | string[]
    dietaryRestrictions?: CourierSettingUpdatedietaryRestrictionsInput | string[]
    payRate?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couriers?: CourierUpdateOneWithoutSettingsNestedInput
  }

  export type CourierSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableEnumEnumSettingVehicleTypeFieldUpdateOperationsInput | $Enums.EnumSettingVehicleType | null
    preferredAreas?: CourierSettingUpdatepreferredAreasInput | string[]
    shiftAvailability?: NullableJsonNullValueInput | InputJsonValue
    deliveryPreferences?: CourierSettingUpdatedeliveryPreferencesInput | string[]
    foodPreferences?: CourierSettingUpdatefoodPreferencesInput | string[]
    earningGoals?: NullableJsonNullValueInput | InputJsonValue
    deliverySpeed?: NullableEnumEnumSettingDeliverySpeedFieldUpdateOperationsInput | $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes?: CourierSettingUpdaterestaurantTypesInput | string[]
    cuisineTypes?: CourierSettingUpdatecuisineTypesInput | string[]
    preferredRestaurantPartners?: CourierSettingUpdatepreferredRestaurantPartnersInput | string[]
    dietaryRestrictions?: CourierSettingUpdatedietaryRestrictionsInput | string[]
    payRate?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourierSettingCreateManyInput = {
    id?: string
    vehicleType?: $Enums.EnumSettingVehicleType | null
    preferredAreas?: CourierSettingCreatepreferredAreasInput | string[]
    shiftAvailability?: NullableJsonNullValueInput | InputJsonValue
    deliveryPreferences?: CourierSettingCreatedeliveryPreferencesInput | string[]
    foodPreferences?: CourierSettingCreatefoodPreferencesInput | string[]
    earningGoals?: NullableJsonNullValueInput | InputJsonValue
    deliverySpeed?: $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes?: CourierSettingCreaterestaurantTypesInput | string[]
    cuisineTypes?: CourierSettingCreatecuisineTypesInput | string[]
    preferredRestaurantPartners?: CourierSettingCreatepreferredRestaurantPartnersInput | string[]
    dietaryRestrictions?: CourierSettingCreatedietaryRestrictionsInput | string[]
    payRate?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    courierId?: string | null
  }

  export type CourierSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableEnumEnumSettingVehicleTypeFieldUpdateOperationsInput | $Enums.EnumSettingVehicleType | null
    preferredAreas?: CourierSettingUpdatepreferredAreasInput | string[]
    shiftAvailability?: NullableJsonNullValueInput | InputJsonValue
    deliveryPreferences?: CourierSettingUpdatedeliveryPreferencesInput | string[]
    foodPreferences?: CourierSettingUpdatefoodPreferencesInput | string[]
    earningGoals?: NullableJsonNullValueInput | InputJsonValue
    deliverySpeed?: NullableEnumEnumSettingDeliverySpeedFieldUpdateOperationsInput | $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes?: CourierSettingUpdaterestaurantTypesInput | string[]
    cuisineTypes?: CourierSettingUpdatecuisineTypesInput | string[]
    preferredRestaurantPartners?: CourierSettingUpdatepreferredRestaurantPartnersInput | string[]
    dietaryRestrictions?: CourierSettingUpdatedietaryRestrictionsInput | string[]
    payRate?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourierSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableEnumEnumSettingVehicleTypeFieldUpdateOperationsInput | $Enums.EnumSettingVehicleType | null
    preferredAreas?: CourierSettingUpdatepreferredAreasInput | string[]
    shiftAvailability?: NullableJsonNullValueInput | InputJsonValue
    deliveryPreferences?: CourierSettingUpdatedeliveryPreferencesInput | string[]
    foodPreferences?: CourierSettingUpdatefoodPreferencesInput | string[]
    earningGoals?: NullableJsonNullValueInput | InputJsonValue
    deliverySpeed?: NullableEnumEnumSettingDeliverySpeedFieldUpdateOperationsInput | $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes?: CourierSettingUpdaterestaurantTypesInput | string[]
    cuisineTypes?: CourierSettingUpdatecuisineTypesInput | string[]
    preferredRestaurantPartners?: CourierSettingUpdatepreferredRestaurantPartnersInput | string[]
    dietaryRestrictions?: CourierSettingUpdatedietaryRestrictionsInput | string[]
    payRate?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PayoutCreateInput = {
    id?: string
    amount: number
    arrivalDate: Date | string
    description?: string | null
    statementDescriptor?: string | null
    status: $Enums.EnumPayoutStatus
    payment: PaymentCreateNestedOneWithoutPayoutsInput
    courier?: CourierCreateNestedOneWithoutPayoutInput
  }

  export type PayoutUncheckedCreateInput = {
    id?: string
    amount: number
    arrivalDate: Date | string
    description?: string | null
    statementDescriptor?: string | null
    status: $Enums.EnumPayoutStatus
    paymentId: string
    courierId?: string | null
  }

  export type PayoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statementDescriptor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumPayoutStatusFieldUpdateOperationsInput | $Enums.EnumPayoutStatus
    payment?: PaymentUpdateOneRequiredWithoutPayoutsNestedInput
    courier?: CourierUpdateOneWithoutPayoutNestedInput
  }

  export type PayoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statementDescriptor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumPayoutStatusFieldUpdateOperationsInput | $Enums.EnumPayoutStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PayoutCreateManyInput = {
    id?: string
    amount: number
    arrivalDate: Date | string
    description?: string | null
    statementDescriptor?: string | null
    status: $Enums.EnumPayoutStatus
    paymentId: string
    courierId?: string | null
  }

  export type PayoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statementDescriptor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumPayoutStatusFieldUpdateOperationsInput | $Enums.EnumPayoutStatus
  }

  export type PayoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statementDescriptor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumPayoutStatusFieldUpdateOperationsInput | $Enums.EnumPayoutStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capturedAt?: Date | string | null
    canceledAt?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.EnumPaymentStatus
    provider?: $Enums.EnumPaymentProvider
    delivery: DeliveryCreateNestedOneWithoutPaymentInput
    transfers?: TransferCreateNestedManyWithoutPaymentInput
    refunds?: RefundCreateNestedManyWithoutPaymentInput
    payouts?: PayoutCreateNestedManyWithoutPaymentInput
    stripeData?: StripePaymentDataCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capturedAt?: Date | string | null
    canceledAt?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.EnumPaymentStatus
    deliveryId: string
    provider?: $Enums.EnumPaymentProvider
    transfers?: TransferUncheckedCreateNestedManyWithoutPaymentInput
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutPaymentInput
    stripeData?: StripePaymentDataUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
    delivery?: DeliveryUpdateOneRequiredWithoutPaymentNestedInput
    transfers?: TransferUpdateManyWithoutPaymentNestedInput
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
    payouts?: PayoutUpdateManyWithoutPaymentNestedInput
    stripeData?: StripePaymentDataUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    deliveryId?: StringFieldUpdateOperationsInput | string
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
    transfers?: TransferUncheckedUpdateManyWithoutPaymentNestedInput
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutPaymentNestedInput
    stripeData?: StripePaymentDataUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capturedAt?: Date | string | null
    canceledAt?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.EnumPaymentStatus
    deliveryId: string
    provider?: $Enums.EnumPaymentProvider
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    deliveryId?: StringFieldUpdateOperationsInput | string
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
  }

  export type StripePaymentDataCreateInput = {
    id?: string
    paymentIntentId: string
    paymentMethodId: string
    latestChargeId?: string | null
    payment?: PaymentCreateNestedOneWithoutStripeDataInput
  }

  export type StripePaymentDataUncheckedCreateInput = {
    id?: string
    paymentIntentId: string
    paymentMethodId: string
    latestChargeId?: string | null
    paymentId?: string | null
  }

  export type StripePaymentDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    latestChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: PaymentUpdateOneWithoutStripeDataNestedInput
  }

  export type StripePaymentDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    latestChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StripePaymentDataCreateManyInput = {
    id?: string
    paymentIntentId: string
    paymentMethodId: string
    latestChargeId?: string | null
    paymentId?: string | null
  }

  export type StripePaymentDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    latestChargeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StripePaymentDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    latestChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransferCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transferId: string
    amount: number
    amountReversed: number
    destination: string
    destinationPayment?: string | null
    reversed?: boolean
    payment?: PaymentCreateNestedOneWithoutTransfersInput
    courier?: CourierCreateNestedOneWithoutTransferInput
  }

  export type TransferUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transferId: string
    amount: number
    amountReversed: number
    destination: string
    destinationPayment?: string | null
    reversed?: boolean
    paymentId?: string | null
    courierId?: string | null
  }

  export type TransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    amountReversed?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    destinationPayment?: NullableStringFieldUpdateOperationsInput | string | null
    reversed?: BoolFieldUpdateOperationsInput | boolean
    payment?: PaymentUpdateOneWithoutTransfersNestedInput
    courier?: CourierUpdateOneWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    amountReversed?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    destinationPayment?: NullableStringFieldUpdateOperationsInput | string | null
    reversed?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransferCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transferId: string
    amount: number
    amountReversed: number
    destination: string
    destinationPayment?: string | null
    reversed?: boolean
    paymentId?: string | null
    courierId?: string | null
  }

  export type TransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    amountReversed?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    destinationPayment?: NullableStringFieldUpdateOperationsInput | string | null
    reversed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    amountReversed?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    destinationPayment?: NullableStringFieldUpdateOperationsInput | string | null
    reversed?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefundCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refundId?: string | null
    amount: number
    description?: string | null
    reason?: $Enums.EnumRefundReason | null
    status?: $Enums.EnumRefundStatus | null
    payment: PaymentCreateNestedOneWithoutRefundsInput
  }

  export type RefundUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refundId?: string | null
    amount: number
    description?: string | null
    reason?: $Enums.EnumRefundReason | null
    status?: $Enums.EnumRefundStatus | null
    paymentId: string
  }

  export type RefundUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableEnumEnumRefundReasonFieldUpdateOperationsInput | $Enums.EnumRefundReason | null
    status?: NullableEnumEnumRefundStatusFieldUpdateOperationsInput | $Enums.EnumRefundStatus | null
    payment?: PaymentUpdateOneRequiredWithoutRefundsNestedInput
  }

  export type RefundUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableEnumEnumRefundReasonFieldUpdateOperationsInput | $Enums.EnumRefundReason | null
    status?: NullableEnumEnumRefundStatusFieldUpdateOperationsInput | $Enums.EnumRefundStatus | null
    paymentId?: StringFieldUpdateOperationsInput | string
  }

  export type RefundCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refundId?: string | null
    amount: number
    description?: string | null
    reason?: $Enums.EnumRefundReason | null
    status?: $Enums.EnumRefundStatus | null
    paymentId: string
  }

  export type RefundUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableEnumEnumRefundReasonFieldUpdateOperationsInput | $Enums.EnumRefundReason | null
    status?: NullableEnumEnumRefundStatusFieldUpdateOperationsInput | $Enums.EnumRefundStatus | null
  }

  export type RefundUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableEnumEnumRefundReasonFieldUpdateOperationsInput | $Enums.EnumRefundReason | null
    status?: NullableEnumEnumRefundStatusFieldUpdateOperationsInput | $Enums.EnumRefundStatus | null
    paymentId?: StringFieldUpdateOperationsInput | string
  }

  export type ConfigCreateInput = {
    key: string
    type: string
    value: string
  }

  export type ConfigUncheckedCreateInput = {
    key: string
    type: string
    value: string
  }

  export type ConfigUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ConfigUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ConfigCreateManyInput = {
    key: string
    type: string
    value: string
  }

  export type ConfigUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ConfigUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type spatial_ref_sysCreateInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUncheckedCreateInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUpdateInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysUncheckedUpdateInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysCreateManyInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUpdateManyMutationInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysUncheckedUpdateManyInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumEnumUserRoleNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumUserRole[] | ListEnumEnumUserRoleFieldRefInput<$PrismaModel> | null
    has?: $Enums.EnumUserRole | EnumEnumUserRoleFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.EnumUserRole[] | ListEnumEnumUserRoleFieldRefInput<$PrismaModel>
    hasSome?: $Enums.EnumUserRole[] | ListEnumEnumUserRoleFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CourierNullableRelationFilter = {
    is?: CourierWhereInput | null
    isNot?: CourierWhereInput | null
  }

  export type PartnerNullableRelationFilter = {
    is?: PartnerWhereInput | null
    isNot?: PartnerWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    username?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CommentOrderByRelevanceInput = {
    fields: CommentOrderByRelevanceFieldEnum | CommentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    likes?: SortOrder
    likers?: SortOrder
    commentableId?: SortOrder
    commentableType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    likes?: SortOrder
    commentableId?: SortOrder
    commentableType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    likes?: SortOrder
    commentableId?: SortOrder
    commentableType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumEnumCourierStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumCourierStatus | EnumEnumCourierStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumCourierStatus[] | ListEnumEnumCourierStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumCourierStatus[] | ListEnumEnumCourierStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumCourierStatusFilter<$PrismaModel> | $Enums.EnumCourierStatus
  }

  export type EnumEnumCourierDeliverySettingFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumCourierDeliverySetting | EnumEnumCourierDeliverySettingFieldRefInput<$PrismaModel>
    in?: $Enums.EnumCourierDeliverySetting[] | ListEnumEnumCourierDeliverySettingFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumCourierDeliverySetting[] | ListEnumEnumCourierDeliverySettingFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumCourierDeliverySettingFilter<$PrismaModel> | $Enums.EnumCourierDeliverySetting
  }

  export type EnumEnumStripeAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumStripeAccountStatus | EnumEnumStripeAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumStripeAccountStatus[] | ListEnumEnumStripeAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumStripeAccountStatus[] | ListEnumEnumStripeAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumStripeAccountStatusFilter<$PrismaModel> | $Enums.EnumStripeAccountStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type EarningListRelationFilter = {
    every?: EarningWhereInput
    some?: EarningWhereInput
    none?: EarningWhereInput
  }

  export type DeliveryListRelationFilter = {
    every?: DeliveryWhereInput
    some?: DeliveryWhereInput
    none?: DeliveryWhereInput
  }

  export type CourierSettingNullableRelationFilter = {
    is?: CourierSettingWhereInput | null
    isNot?: CourierSettingWhereInput | null
  }

  export type PayoutListRelationFilter = {
    every?: PayoutWhereInput
    some?: PayoutWhereInput
    none?: PayoutWhereInput
  }

  export type TransferListRelationFilter = {
    every?: TransferWhereInput
    some?: TransferWhereInput
    none?: TransferWhereInput
  }

  export type LocationNoteListRelationFilter = {
    every?: LocationNoteWhereInput
    some?: LocationNoteWhereInput
    none?: LocationNoteWhereInput
  }

  export type LocationNoteReactionListRelationFilter = {
    every?: LocationNoteReactionWhereInput
    some?: LocationNoteReactionWhereInput
    none?: LocationNoteReactionWhereInput
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EarningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationNoteReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourierOrderByRelevanceInput = {
    fields: CourierOrderByRelevanceFieldEnum | CourierOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CourierCountOrderByAggregateInput = {
    id?: SortOrder
    node_uri?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    status?: SortOrder
    deliverySetting?: SortOrder
    rejectedOffers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    stripeAccountId?: SortOrder
    stripeAccountStatus?: SortOrder
  }

  export type CourierMaxOrderByAggregateInput = {
    id?: SortOrder
    node_uri?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    status?: SortOrder
    deliverySetting?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    stripeAccountId?: SortOrder
    stripeAccountStatus?: SortOrder
  }

  export type CourierMinOrderByAggregateInput = {
    id?: SortOrder
    node_uri?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    status?: SortOrder
    deliverySetting?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    stripeAccountId?: SortOrder
    stripeAccountStatus?: SortOrder
  }

  export type EnumEnumCourierStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumCourierStatus | EnumEnumCourierStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumCourierStatus[] | ListEnumEnumCourierStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumCourierStatus[] | ListEnumEnumCourierStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumCourierStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnumCourierStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumCourierStatusFilter<$PrismaModel>
    _max?: NestedEnumEnumCourierStatusFilter<$PrismaModel>
  }

  export type EnumEnumCourierDeliverySettingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumCourierDeliverySetting | EnumEnumCourierDeliverySettingFieldRefInput<$PrismaModel>
    in?: $Enums.EnumCourierDeliverySetting[] | ListEnumEnumCourierDeliverySettingFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumCourierDeliverySetting[] | ListEnumEnumCourierDeliverySettingFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumCourierDeliverySettingWithAggregatesFilter<$PrismaModel> | $Enums.EnumCourierDeliverySetting
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumCourierDeliverySettingFilter<$PrismaModel>
    _max?: NestedEnumEnumCourierDeliverySettingFilter<$PrismaModel>
  }

  export type EnumEnumStripeAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumStripeAccountStatus | EnumEnumStripeAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumStripeAccountStatus[] | ListEnumEnumStripeAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumStripeAccountStatus[] | ListEnumEnumStripeAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumStripeAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnumStripeAccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumStripeAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumEnumStripeAccountStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EarningOrderByRelevanceInput = {
    fields: EarningOrderByRelevanceFieldEnum | EarningOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EarningCountOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    pending?: SortOrder
    received?: SortOrder
    payoutMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrder
  }

  export type EarningAvgOrderByAggregateInput = {
    total?: SortOrder
    pending?: SortOrder
    received?: SortOrder
  }

  export type EarningMaxOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    pending?: SortOrder
    received?: SortOrder
    payoutMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrder
  }

  export type EarningMinOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    pending?: SortOrder
    received?: SortOrder
    payoutMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrder
  }

  export type EarningSumOrderByAggregateInput = {
    total?: SortOrder
    pending?: SortOrder
    received?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumEnumCountryCodeFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumCountryCode | EnumEnumCountryCodeFieldRefInput<$PrismaModel>
    in?: $Enums.EnumCountryCode[] | ListEnumEnumCountryCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumCountryCode[] | ListEnumEnumCountryCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumCountryCodeFilter<$PrismaModel> | $Enums.EnumCountryCode
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DeliveryQuoteListRelationFilter = {
    every?: DeliveryQuoteWhereInput
    some?: DeliveryQuoteWhereInput
    none?: DeliveryQuoteWhereInput
  }

  export type DeliveryQuoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationOrderByRelevanceInput = {
    fields: LocationOrderByRelevanceFieldEnum | LocationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    street?: SortOrder
    zipCode?: SortOrder
    countryCode?: SortOrder
    stateCode?: SortOrder
    houseNumber?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    formattedAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    street?: SortOrder
    zipCode?: SortOrder
    countryCode?: SortOrder
    stateCode?: SortOrder
    houseNumber?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    formattedAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    street?: SortOrder
    zipCode?: SortOrder
    countryCode?: SortOrder
    stateCode?: SortOrder
    houseNumber?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    formattedAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type EnumEnumCountryCodeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumCountryCode | EnumEnumCountryCodeFieldRefInput<$PrismaModel>
    in?: $Enums.EnumCountryCode[] | ListEnumEnumCountryCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumCountryCode[] | ListEnumEnumCountryCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumCountryCodeWithAggregatesFilter<$PrismaModel> | $Enums.EnumCountryCode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumCountryCodeFilter<$PrismaModel>
    _max?: NestedEnumEnumCountryCodeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PartnerOrderByRelevanceInput = {
    fields: PartnerOrderByRelevanceFieldEnum | PartnerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PartnerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    phoneNumber?: SortOrder
    webhookUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type PartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    phoneNumber?: SortOrder
    webhookUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type PartnerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    phoneNumber?: SortOrder
    webhookUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumEnumDistanceUnitFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDistanceUnit | EnumEnumDistanceUnitFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDistanceUnit[] | ListEnumEnumDistanceUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDistanceUnit[] | ListEnumEnumDistanceUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDistanceUnitFilter<$PrismaModel> | $Enums.EnumDistanceUnit
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type LocationRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type DeliveryNullableRelationFilter = {
    is?: DeliveryWhereInput | null
    isNot?: DeliveryWhereInput | null
  }

  export type DeliveryQuoteOrderByRelevanceInput = {
    fields: DeliveryQuoteOrderByRelevanceFieldEnum | DeliveryQuoteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeliveryQuoteCountOrderByAggregateInput = {
    id?: SortOrder
    quote?: SortOrder
    quoteRangeFrom?: SortOrder
    quoteRangeTo?: SortOrder
    feePercentage?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    distanceUnit?: SortOrder
    pickupPhoneNumber?: SortOrder
    pickupName?: SortOrder
    dropoffPhoneNumber?: SortOrder
    dropoffName?: SortOrder
    expiresAt?: SortOrder
    pickupReadyAt?: SortOrder
    pickupDeadlineAt?: SortOrder
    dropoffReadyAt?: SortOrder
    dropoffEta?: SortOrder
    dropoffDeadlineAt?: SortOrder
    orderTotalValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pickupLocationId?: SortOrder
    dropoffLocationId?: SortOrder
    partnerId?: SortOrder
    deliveryId?: SortOrder
  }

  export type DeliveryQuoteAvgOrderByAggregateInput = {
    quote?: SortOrder
    quoteRangeFrom?: SortOrder
    quoteRangeTo?: SortOrder
    feePercentage?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    orderTotalValue?: SortOrder
  }

  export type DeliveryQuoteMaxOrderByAggregateInput = {
    id?: SortOrder
    quote?: SortOrder
    quoteRangeFrom?: SortOrder
    quoteRangeTo?: SortOrder
    feePercentage?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    distanceUnit?: SortOrder
    pickupPhoneNumber?: SortOrder
    pickupName?: SortOrder
    dropoffPhoneNumber?: SortOrder
    dropoffName?: SortOrder
    expiresAt?: SortOrder
    pickupReadyAt?: SortOrder
    pickupDeadlineAt?: SortOrder
    dropoffReadyAt?: SortOrder
    dropoffEta?: SortOrder
    dropoffDeadlineAt?: SortOrder
    orderTotalValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pickupLocationId?: SortOrder
    dropoffLocationId?: SortOrder
    partnerId?: SortOrder
    deliveryId?: SortOrder
  }

  export type DeliveryQuoteMinOrderByAggregateInput = {
    id?: SortOrder
    quote?: SortOrder
    quoteRangeFrom?: SortOrder
    quoteRangeTo?: SortOrder
    feePercentage?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    distanceUnit?: SortOrder
    pickupPhoneNumber?: SortOrder
    pickupName?: SortOrder
    dropoffPhoneNumber?: SortOrder
    dropoffName?: SortOrder
    expiresAt?: SortOrder
    pickupReadyAt?: SortOrder
    pickupDeadlineAt?: SortOrder
    dropoffReadyAt?: SortOrder
    dropoffEta?: SortOrder
    dropoffDeadlineAt?: SortOrder
    orderTotalValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pickupLocationId?: SortOrder
    dropoffLocationId?: SortOrder
    partnerId?: SortOrder
    deliveryId?: SortOrder
  }

  export type DeliveryQuoteSumOrderByAggregateInput = {
    quote?: SortOrder
    quoteRangeFrom?: SortOrder
    quoteRangeTo?: SortOrder
    feePercentage?: SortOrder
    duration?: SortOrder
    distance?: SortOrder
    orderTotalValue?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumEnumDistanceUnitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDistanceUnit | EnumEnumDistanceUnitFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDistanceUnit[] | ListEnumEnumDistanceUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDistanceUnit[] | ListEnumEnumDistanceUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDistanceUnitWithAggregatesFilter<$PrismaModel> | $Enums.EnumDistanceUnit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumDistanceUnitFilter<$PrismaModel>
    _max?: NestedEnumEnumDistanceUnitFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumEnumDeliverableActionFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliverableAction | EnumEnumDeliverableActionFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliverableAction[] | ListEnumEnumDeliverableActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliverableAction[] | ListEnumEnumDeliverableActionFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliverableActionFilter<$PrismaModel> | $Enums.EnumDeliverableAction
  }

  export type EnumEnumUndeliverableActionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumUndeliverableAction | EnumEnumUndeliverableActionFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumUndeliverableAction[] | ListEnumEnumUndeliverableActionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumUndeliverableAction[] | ListEnumEnumUndeliverableActionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumUndeliverableActionNullableFilter<$PrismaModel> | $Enums.EnumUndeliverableAction | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumEnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryStatus | EnumEnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliveryStatusFilter<$PrismaModel> | $Enums.EnumDeliveryStatus
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type LocationNullableRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type DeliveryQuoteRelationFilter = {
    is?: DeliveryQuoteWhereInput
    isNot?: DeliveryQuoteWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type DeliveryEventListRelationFilter = {
    every?: DeliveryEventWhereInput
    some?: DeliveryEventWhereInput
    none?: DeliveryEventWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryOrderByRelevanceInput = {
    fields: DeliveryOrderByRelevanceFieldEnum | DeliveryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeliveryIdempotencyKeyPartnerIdCompoundUniqueInput = {
    idempotencyKey: string
    partnerId: string
  }

  export type DeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    pickupName?: SortOrder
    pickupPhoneNumber?: SortOrder
    pickupBusinessName?: SortOrder
    pickupNotes?: SortOrder
    pickupVerification?: SortOrder
    pickupLocationId?: SortOrder
    pickupReadyAt?: SortOrder
    pickupDeadlineAt?: SortOrder
    dropoffName?: SortOrder
    dropoffPhoneNumber?: SortOrder
    dropoffBusinessName?: SortOrder
    dropoffNotes?: SortOrder
    dropoffSellerNotes?: SortOrder
    dropoffVerification?: SortOrder
    dropoffReadyAt?: SortOrder
    dropoffEta?: SortOrder
    dropoffDeadlineAt?: SortOrder
    deliverableAction?: SortOrder
    undeliverableAction?: SortOrder
    undeliverableReason?: SortOrder
    dropoffLocationId?: SortOrder
    deliveryTypes?: SortOrder
    requiresDropoffSignature?: SortOrder
    requiresId?: SortOrder
    orderReference?: SortOrder
    orderTotalValue?: SortOrder
    orderItems?: SortOrder
    status?: SortOrder
    customerNotes?: SortOrder
    currencyCode?: SortOrder
    pickupTypes?: SortOrder
    imageType?: SortOrder
    imageName?: SortOrder
    imageData?: SortOrder
    idempotencyKey?: SortOrder
    externalStoreId?: SortOrder
    returnVerification?: SortOrder
    externalUserInfo?: SortOrder
    externalId?: SortOrder
    courierId?: SortOrder
    partnerId?: SortOrder
    deliveryQuoteId?: SortOrder
    totalCost?: SortOrder
    fee?: SortOrder
    feePercentage?: SortOrder
    pay?: SortOrder
    tips?: SortOrder
    totalCompensation?: SortOrder
    rejectedByCouriers?: SortOrder
    matchedCourierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryAvgOrderByAggregateInput = {
    orderTotalValue?: SortOrder
    totalCost?: SortOrder
    fee?: SortOrder
    feePercentage?: SortOrder
    pay?: SortOrder
    tips?: SortOrder
    totalCompensation?: SortOrder
  }

  export type DeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    pickupName?: SortOrder
    pickupPhoneNumber?: SortOrder
    pickupBusinessName?: SortOrder
    pickupNotes?: SortOrder
    pickupLocationId?: SortOrder
    pickupReadyAt?: SortOrder
    pickupDeadlineAt?: SortOrder
    dropoffName?: SortOrder
    dropoffPhoneNumber?: SortOrder
    dropoffBusinessName?: SortOrder
    dropoffNotes?: SortOrder
    dropoffSellerNotes?: SortOrder
    dropoffReadyAt?: SortOrder
    dropoffEta?: SortOrder
    dropoffDeadlineAt?: SortOrder
    deliverableAction?: SortOrder
    undeliverableAction?: SortOrder
    undeliverableReason?: SortOrder
    dropoffLocationId?: SortOrder
    requiresDropoffSignature?: SortOrder
    requiresId?: SortOrder
    orderReference?: SortOrder
    orderTotalValue?: SortOrder
    status?: SortOrder
    currencyCode?: SortOrder
    imageType?: SortOrder
    imageName?: SortOrder
    imageData?: SortOrder
    idempotencyKey?: SortOrder
    externalStoreId?: SortOrder
    externalId?: SortOrder
    courierId?: SortOrder
    partnerId?: SortOrder
    deliveryQuoteId?: SortOrder
    totalCost?: SortOrder
    fee?: SortOrder
    feePercentage?: SortOrder
    pay?: SortOrder
    tips?: SortOrder
    totalCompensation?: SortOrder
    matchedCourierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    pickupName?: SortOrder
    pickupPhoneNumber?: SortOrder
    pickupBusinessName?: SortOrder
    pickupNotes?: SortOrder
    pickupLocationId?: SortOrder
    pickupReadyAt?: SortOrder
    pickupDeadlineAt?: SortOrder
    dropoffName?: SortOrder
    dropoffPhoneNumber?: SortOrder
    dropoffBusinessName?: SortOrder
    dropoffNotes?: SortOrder
    dropoffSellerNotes?: SortOrder
    dropoffReadyAt?: SortOrder
    dropoffEta?: SortOrder
    dropoffDeadlineAt?: SortOrder
    deliverableAction?: SortOrder
    undeliverableAction?: SortOrder
    undeliverableReason?: SortOrder
    dropoffLocationId?: SortOrder
    requiresDropoffSignature?: SortOrder
    requiresId?: SortOrder
    orderReference?: SortOrder
    orderTotalValue?: SortOrder
    status?: SortOrder
    currencyCode?: SortOrder
    imageType?: SortOrder
    imageName?: SortOrder
    imageData?: SortOrder
    idempotencyKey?: SortOrder
    externalStoreId?: SortOrder
    externalId?: SortOrder
    courierId?: SortOrder
    partnerId?: SortOrder
    deliveryQuoteId?: SortOrder
    totalCost?: SortOrder
    fee?: SortOrder
    feePercentage?: SortOrder
    pay?: SortOrder
    tips?: SortOrder
    totalCompensation?: SortOrder
    matchedCourierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliverySumOrderByAggregateInput = {
    orderTotalValue?: SortOrder
    totalCost?: SortOrder
    fee?: SortOrder
    feePercentage?: SortOrder
    pay?: SortOrder
    tips?: SortOrder
    totalCompensation?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumEnumDeliverableActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliverableAction | EnumEnumDeliverableActionFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliverableAction[] | ListEnumEnumDeliverableActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliverableAction[] | ListEnumEnumDeliverableActionFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliverableActionWithAggregatesFilter<$PrismaModel> | $Enums.EnumDeliverableAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumDeliverableActionFilter<$PrismaModel>
    _max?: NestedEnumEnumDeliverableActionFilter<$PrismaModel>
  }

  export type EnumEnumUndeliverableActionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumUndeliverableAction | EnumEnumUndeliverableActionFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumUndeliverableAction[] | ListEnumEnumUndeliverableActionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumUndeliverableAction[] | ListEnumEnumUndeliverableActionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumUndeliverableActionNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnumUndeliverableAction | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnumUndeliverableActionNullableFilter<$PrismaModel>
    _max?: NestedEnumEnumUndeliverableActionNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumEnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryStatus | EnumEnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnumDeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumEnumDeliveryStatusFilter<$PrismaModel>
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type EnumEnumDeliveryEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryEventType | EnumEnumDeliveryEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliveryEventType[] | ListEnumEnumDeliveryEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliveryEventType[] | ListEnumEnumDeliveryEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliveryEventTypeFilter<$PrismaModel> | $Enums.EnumDeliveryEventType
  }

  export type EnumEnumEventActorFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumEventActor | EnumEnumEventActorFieldRefInput<$PrismaModel>
    in?: $Enums.EnumEventActor[] | ListEnumEnumEventActorFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumEventActor[] | ListEnumEnumEventActorFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumEventActorFilter<$PrismaModel> | $Enums.EnumEventActor
  }

  export type EnumEnumDeliveryEventSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryEventSource | EnumEnumDeliveryEventSourceFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliveryEventSource[] | ListEnumEnumDeliveryEventSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliveryEventSource[] | ListEnumEnumDeliveryEventSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliveryEventSourceFilter<$PrismaModel> | $Enums.EnumDeliveryEventSource
  }

  export type EnumEnumDeliveryStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryStatus | EnumEnumDeliveryStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumDeliveryStatusNullableFilter<$PrismaModel> | $Enums.EnumDeliveryStatus | null
  }

  export type DeliveryRelationFilter = {
    is?: DeliveryWhereInput
    isNot?: DeliveryWhereInput
  }

  export type DeliveryEventOrderByRelevanceInput = {
    fields: DeliveryEventOrderByRelevanceFieldEnum | DeliveryEventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeliveryEventCountOrderByAggregateInput = {
    id?: SortOrder
    transitionSuccessful?: SortOrder
    type?: SortOrder
    actor?: SortOrder
    eventSource?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    message?: SortOrder
    deliveryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryEventMaxOrderByAggregateInput = {
    id?: SortOrder
    transitionSuccessful?: SortOrder
    type?: SortOrder
    actor?: SortOrder
    eventSource?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    message?: SortOrder
    deliveryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryEventMinOrderByAggregateInput = {
    id?: SortOrder
    transitionSuccessful?: SortOrder
    type?: SortOrder
    actor?: SortOrder
    eventSource?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    message?: SortOrder
    deliveryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEnumDeliveryEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryEventType | EnumEnumDeliveryEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliveryEventType[] | ListEnumEnumDeliveryEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliveryEventType[] | ListEnumEnumDeliveryEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliveryEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EnumDeliveryEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumDeliveryEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEnumDeliveryEventTypeFilter<$PrismaModel>
  }

  export type EnumEnumEventActorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumEventActor | EnumEnumEventActorFieldRefInput<$PrismaModel>
    in?: $Enums.EnumEventActor[] | ListEnumEnumEventActorFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumEventActor[] | ListEnumEnumEventActorFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumEventActorWithAggregatesFilter<$PrismaModel> | $Enums.EnumEventActor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumEventActorFilter<$PrismaModel>
    _max?: NestedEnumEnumEventActorFilter<$PrismaModel>
  }

  export type EnumEnumDeliveryEventSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryEventSource | EnumEnumDeliveryEventSourceFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliveryEventSource[] | ListEnumEnumDeliveryEventSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliveryEventSource[] | ListEnumEnumDeliveryEventSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliveryEventSourceWithAggregatesFilter<$PrismaModel> | $Enums.EnumDeliveryEventSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumDeliveryEventSourceFilter<$PrismaModel>
    _max?: NestedEnumEnumDeliveryEventSourceFilter<$PrismaModel>
  }

  export type EnumEnumDeliveryStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryStatus | EnumEnumDeliveryStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumDeliveryStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnumDeliveryStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnumDeliveryStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumEnumDeliveryStatusNullableFilter<$PrismaModel>
  }

  export type EnumEnumLocationNoteActorFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumLocationNoteActor | EnumEnumLocationNoteActorFieldRefInput<$PrismaModel>
    in?: $Enums.EnumLocationNoteActor[] | ListEnumEnumLocationNoteActorFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumLocationNoteActor[] | ListEnumEnumLocationNoteActorFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumLocationNoteActorFilter<$PrismaModel> | $Enums.EnumLocationNoteActor
  }

  export type LocationNoteOrderByRelevanceInput = {
    fields: LocationNoteOrderByRelevanceFieldEnum | LocationNoteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LocationNoteCountOrderByAggregateInput = {
    id?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    actor?: SortOrder
    locationId?: SortOrder
    deliveryId?: SortOrder
    courierId?: SortOrder
  }

  export type LocationNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    actor?: SortOrder
    locationId?: SortOrder
    deliveryId?: SortOrder
    courierId?: SortOrder
  }

  export type LocationNoteMinOrderByAggregateInput = {
    id?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    actor?: SortOrder
    locationId?: SortOrder
    deliveryId?: SortOrder
    courierId?: SortOrder
  }

  export type EnumEnumLocationNoteActorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumLocationNoteActor | EnumEnumLocationNoteActorFieldRefInput<$PrismaModel>
    in?: $Enums.EnumLocationNoteActor[] | ListEnumEnumLocationNoteActorFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumLocationNoteActor[] | ListEnumEnumLocationNoteActorFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumLocationNoteActorWithAggregatesFilter<$PrismaModel> | $Enums.EnumLocationNoteActor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumLocationNoteActorFilter<$PrismaModel>
    _max?: NestedEnumEnumLocationNoteActorFilter<$PrismaModel>
  }

  export type EnumEnumLocationNoteReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumLocationNoteReactionType | EnumEnumLocationNoteReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EnumLocationNoteReactionType[] | ListEnumEnumLocationNoteReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumLocationNoteReactionType[] | ListEnumEnumLocationNoteReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumLocationNoteReactionTypeFilter<$PrismaModel> | $Enums.EnumLocationNoteReactionType
  }

  export type LocationNoteRelationFilter = {
    is?: LocationNoteWhereInput
    isNot?: LocationNoteWhereInput
  }

  export type CourierRelationFilter = {
    is?: CourierWhereInput
    isNot?: CourierWhereInput
  }

  export type LocationNoteReactionOrderByRelevanceInput = {
    fields: LocationNoteReactionOrderByRelevanceFieldEnum | LocationNoteReactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LocationNoteReactionCountOrderByAggregateInput = {
    id?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationNoteId?: SortOrder
    courierId?: SortOrder
  }

  export type LocationNoteReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationNoteId?: SortOrder
    courierId?: SortOrder
  }

  export type LocationNoteReactionMinOrderByAggregateInput = {
    id?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationNoteId?: SortOrder
    courierId?: SortOrder
  }

  export type EnumEnumLocationNoteReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumLocationNoteReactionType | EnumEnumLocationNoteReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EnumLocationNoteReactionType[] | ListEnumEnumLocationNoteReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumLocationNoteReactionType[] | ListEnumEnumLocationNoteReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumLocationNoteReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.EnumLocationNoteReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumLocationNoteReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumEnumLocationNoteReactionTypeFilter<$PrismaModel>
  }

  export type EnumEnumSettingVehicleTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumSettingVehicleType | EnumEnumSettingVehicleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumSettingVehicleType[] | ListEnumEnumSettingVehicleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumSettingVehicleType[] | ListEnumEnumSettingVehicleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumSettingVehicleTypeNullableFilter<$PrismaModel> | $Enums.EnumSettingVehicleType | null
  }

  export type EnumEnumSettingDeliverySpeedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumSettingDeliverySpeed | EnumEnumSettingDeliverySpeedFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumSettingDeliverySpeed[] | ListEnumEnumSettingDeliverySpeedFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumSettingDeliverySpeed[] | ListEnumEnumSettingDeliverySpeedFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumSettingDeliverySpeedNullableFilter<$PrismaModel> | $Enums.EnumSettingDeliverySpeed | null
  }

  export type CourierSettingOrderByRelevanceInput = {
    fields: CourierSettingOrderByRelevanceFieldEnum | CourierSettingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CourierSettingCountOrderByAggregateInput = {
    id?: SortOrder
    vehicleType?: SortOrder
    preferredAreas?: SortOrder
    shiftAvailability?: SortOrder
    deliveryPreferences?: SortOrder
    foodPreferences?: SortOrder
    earningGoals?: SortOrder
    deliverySpeed?: SortOrder
    restaurantTypes?: SortOrder
    cuisineTypes?: SortOrder
    preferredRestaurantPartners?: SortOrder
    dietaryRestrictions?: SortOrder
    payRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrder
  }

  export type CourierSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicleType?: SortOrder
    deliverySpeed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrder
  }

  export type CourierSettingMinOrderByAggregateInput = {
    id?: SortOrder
    vehicleType?: SortOrder
    deliverySpeed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courierId?: SortOrder
  }

  export type EnumEnumSettingVehicleTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumSettingVehicleType | EnumEnumSettingVehicleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumSettingVehicleType[] | ListEnumEnumSettingVehicleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumSettingVehicleType[] | ListEnumEnumSettingVehicleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumSettingVehicleTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnumSettingVehicleType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnumSettingVehicleTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEnumSettingVehicleTypeNullableFilter<$PrismaModel>
  }

  export type EnumEnumSettingDeliverySpeedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumSettingDeliverySpeed | EnumEnumSettingDeliverySpeedFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumSettingDeliverySpeed[] | ListEnumEnumSettingDeliverySpeedFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumSettingDeliverySpeed[] | ListEnumEnumSettingDeliverySpeedFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumSettingDeliverySpeedNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnumSettingDeliverySpeed | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnumSettingDeliverySpeedNullableFilter<$PrismaModel>
    _max?: NestedEnumEnumSettingDeliverySpeedNullableFilter<$PrismaModel>
  }

  export type EnumEnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumPayoutStatus | EnumEnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumPayoutStatus[] | ListEnumEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumPayoutStatus[] | ListEnumEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumPayoutStatusFilter<$PrismaModel> | $Enums.EnumPayoutStatus
  }

  export type PaymentRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type PayoutOrderByRelevanceInput = {
    fields: PayoutOrderByRelevanceFieldEnum | PayoutOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PayoutCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    arrivalDate?: SortOrder
    description?: SortOrder
    statementDescriptor?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    courierId?: SortOrder
  }

  export type PayoutAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PayoutMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    arrivalDate?: SortOrder
    description?: SortOrder
    statementDescriptor?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    courierId?: SortOrder
  }

  export type PayoutMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    arrivalDate?: SortOrder
    description?: SortOrder
    statementDescriptor?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    courierId?: SortOrder
  }

  export type PayoutSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumEnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumPayoutStatus | EnumEnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumPayoutStatus[] | ListEnumEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumPayoutStatus[] | ListEnumEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnumPayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumEnumPayoutStatusFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumPaymentStatus | EnumEnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumPaymentStatus[] | ListEnumEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumPaymentStatus[] | ListEnumEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumPaymentStatusFilter<$PrismaModel> | $Enums.EnumPaymentStatus
  }

  export type EnumEnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumPaymentProvider | EnumEnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.EnumPaymentProvider[] | ListEnumEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumPaymentProvider[] | ListEnumEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumPaymentProviderFilter<$PrismaModel> | $Enums.EnumPaymentProvider
  }

  export type RefundListRelationFilter = {
    every?: RefundWhereInput
    some?: RefundWhereInput
    none?: RefundWhereInput
  }

  export type StripePaymentDataNullableRelationFilter = {
    is?: StripePaymentDataWhereInput | null
    isNot?: StripePaymentDataWhereInput | null
  }

  export type RefundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    capturedAt?: SortOrder
    canceledAt?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    deliveryId?: SortOrder
    provider?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    capturedAt?: SortOrder
    canceledAt?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    deliveryId?: SortOrder
    provider?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    capturedAt?: SortOrder
    canceledAt?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    deliveryId?: SortOrder
    provider?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumPaymentStatus | EnumEnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumPaymentStatus[] | ListEnumEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumPaymentStatus[] | ListEnumEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnumPaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumEnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumPaymentProvider | EnumEnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.EnumPaymentProvider[] | ListEnumEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumPaymentProvider[] | ListEnumEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.EnumPaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumEnumPaymentProviderFilter<$PrismaModel>
  }

  export type PaymentNullableRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type StripePaymentDataOrderByRelevanceInput = {
    fields: StripePaymentDataOrderByRelevanceFieldEnum | StripePaymentDataOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StripePaymentDataCountOrderByAggregateInput = {
    id?: SortOrder
    paymentIntentId?: SortOrder
    paymentMethodId?: SortOrder
    latestChargeId?: SortOrder
    paymentId?: SortOrder
  }

  export type StripePaymentDataMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentIntentId?: SortOrder
    paymentMethodId?: SortOrder
    latestChargeId?: SortOrder
    paymentId?: SortOrder
  }

  export type StripePaymentDataMinOrderByAggregateInput = {
    id?: SortOrder
    paymentIntentId?: SortOrder
    paymentMethodId?: SortOrder
    latestChargeId?: SortOrder
    paymentId?: SortOrder
  }

  export type TransferOrderByRelevanceInput = {
    fields: TransferOrderByRelevanceFieldEnum | TransferOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TransferCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transferId?: SortOrder
    amount?: SortOrder
    amountReversed?: SortOrder
    destination?: SortOrder
    destinationPayment?: SortOrder
    reversed?: SortOrder
    paymentId?: SortOrder
    courierId?: SortOrder
  }

  export type TransferAvgOrderByAggregateInput = {
    amount?: SortOrder
    amountReversed?: SortOrder
  }

  export type TransferMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transferId?: SortOrder
    amount?: SortOrder
    amountReversed?: SortOrder
    destination?: SortOrder
    destinationPayment?: SortOrder
    reversed?: SortOrder
    paymentId?: SortOrder
    courierId?: SortOrder
  }

  export type TransferMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transferId?: SortOrder
    amount?: SortOrder
    amountReversed?: SortOrder
    destination?: SortOrder
    destinationPayment?: SortOrder
    reversed?: SortOrder
    paymentId?: SortOrder
    courierId?: SortOrder
  }

  export type TransferSumOrderByAggregateInput = {
    amount?: SortOrder
    amountReversed?: SortOrder
  }

  export type EnumEnumRefundReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumRefundReason | EnumEnumRefundReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumRefundReason[] | ListEnumEnumRefundReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumRefundReason[] | ListEnumEnumRefundReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumRefundReasonNullableFilter<$PrismaModel> | $Enums.EnumRefundReason | null
  }

  export type EnumEnumRefundStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumRefundStatus | EnumEnumRefundStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumRefundStatus[] | ListEnumEnumRefundStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumRefundStatus[] | ListEnumEnumRefundStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumRefundStatusNullableFilter<$PrismaModel> | $Enums.EnumRefundStatus | null
  }

  export type RefundOrderByRelevanceInput = {
    fields: RefundOrderByRelevanceFieldEnum | RefundOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RefundCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
  }

  export type RefundAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RefundMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
  }

  export type RefundMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
  }

  export type RefundSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumEnumRefundReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumRefundReason | EnumEnumRefundReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumRefundReason[] | ListEnumEnumRefundReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumRefundReason[] | ListEnumEnumRefundReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumRefundReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnumRefundReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnumRefundReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumEnumRefundReasonNullableFilter<$PrismaModel>
  }

  export type EnumEnumRefundStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumRefundStatus | EnumEnumRefundStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumRefundStatus[] | ListEnumEnumRefundStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumRefundStatus[] | ListEnumEnumRefundStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumRefundStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnumRefundStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnumRefundStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumEnumRefundStatusNullableFilter<$PrismaModel>
  }

  export type ConfigOrderByRelevanceInput = {
    fields: ConfigOrderByRelevanceFieldEnum | ConfigOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ConfigCountOrderByAggregateInput = {
    key?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type ConfigMaxOrderByAggregateInput = {
    key?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type ConfigMinOrderByAggregateInput = {
    key?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type spatial_ref_sysOrderByRelevanceInput = {
    fields: spatial_ref_sysOrderByRelevanceFieldEnum | spatial_ref_sysOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type spatial_ref_sysCountOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysAvgOrderByAggregateInput = {
    srid?: SortOrder
    auth_srid?: SortOrder
  }

  export type spatial_ref_sysMaxOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysMinOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysSumOrderByAggregateInput = {
    srid?: SortOrder
    auth_srid?: SortOrder
  }

  export type UserCreateroleInput = {
    set: $Enums.EnumUserRole[]
  }

  export type CourierCreateNestedOneWithoutUserInput = {
    create?: XOR<CourierCreateWithoutUserInput, CourierUncheckedCreateWithoutUserInput>
    connectOrCreate?: CourierCreateOrConnectWithoutUserInput
    connect?: CourierWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutUserInput = {
    create?: XOR<PartnerCreateWithoutUserInput, PartnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutUserInput
    connect?: PartnerWhereUniqueInput
  }

  export type CourierUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CourierCreateWithoutUserInput, CourierUncheckedCreateWithoutUserInput>
    connectOrCreate?: CourierCreateOrConnectWithoutUserInput
    connect?: CourierWhereUniqueInput
  }

  export type PartnerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PartnerCreateWithoutUserInput, PartnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutUserInput
    connect?: PartnerWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateroleInput = {
    set?: $Enums.EnumUserRole[]
    push?: $Enums.EnumUserRole | $Enums.EnumUserRole[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CourierUpdateOneWithoutUserNestedInput = {
    create?: XOR<CourierCreateWithoutUserInput, CourierUncheckedCreateWithoutUserInput>
    connectOrCreate?: CourierCreateOrConnectWithoutUserInput
    upsert?: CourierUpsertWithoutUserInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutUserInput, CourierUpdateWithoutUserInput>, CourierUncheckedUpdateWithoutUserInput>
  }

  export type PartnerUpdateOneWithoutUserNestedInput = {
    create?: XOR<PartnerCreateWithoutUserInput, PartnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutUserInput
    upsert?: PartnerUpsertWithoutUserInput
    disconnect?: PartnerWhereInput | boolean
    delete?: PartnerWhereInput | boolean
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutUserInput, PartnerUpdateWithoutUserInput>, PartnerUncheckedUpdateWithoutUserInput>
  }

  export type CourierUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CourierCreateWithoutUserInput, CourierUncheckedCreateWithoutUserInput>
    connectOrCreate?: CourierCreateOrConnectWithoutUserInput
    upsert?: CourierUpsertWithoutUserInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutUserInput, CourierUpdateWithoutUserInput>, CourierUncheckedUpdateWithoutUserInput>
  }

  export type PartnerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PartnerCreateWithoutUserInput, PartnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutUserInput
    upsert?: PartnerUpsertWithoutUserInput
    disconnect?: PartnerWhereInput | boolean
    delete?: PartnerWhereInput | boolean
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutUserInput, PartnerUpdateWithoutUserInput>, PartnerUncheckedUpdateWithoutUserInput>
  }

  export type CommentCreatelikersInput = {
    set: string[]
  }

  export type CourierCreateNestedOneWithoutCommentsInput = {
    create?: XOR<CourierCreateWithoutCommentsInput, CourierUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CourierCreateOrConnectWithoutCommentsInput
    connect?: CourierWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CommentUpdatelikersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourierUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<CourierCreateWithoutCommentsInput, CourierUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CourierCreateOrConnectWithoutCommentsInput
    upsert?: CourierUpsertWithoutCommentsInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutCommentsInput, CourierUpdateWithoutCommentsInput>, CourierUncheckedUpdateWithoutCommentsInput>
  }

  export type CourierCreaterejectedOffersInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCourierInput = {
    create?: XOR<UserCreateWithoutCourierInput, UserUncheckedCreateWithoutCourierInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourierInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutCouriersInput = {
    create?: XOR<CommentCreateWithoutCouriersInput, CommentUncheckedCreateWithoutCouriersInput> | CommentCreateWithoutCouriersInput[] | CommentUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCouriersInput | CommentCreateOrConnectWithoutCouriersInput[]
    createMany?: CommentCreateManyCouriersInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EarningCreateNestedManyWithoutCouriersInput = {
    create?: XOR<EarningCreateWithoutCouriersInput, EarningUncheckedCreateWithoutCouriersInput> | EarningCreateWithoutCouriersInput[] | EarningUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: EarningCreateOrConnectWithoutCouriersInput | EarningCreateOrConnectWithoutCouriersInput[]
    createMany?: EarningCreateManyCouriersInputEnvelope
    connect?: EarningWhereUniqueInput | EarningWhereUniqueInput[]
  }

  export type DeliveryCreateNestedManyWithoutCourierInput = {
    create?: XOR<DeliveryCreateWithoutCourierInput, DeliveryUncheckedCreateWithoutCourierInput> | DeliveryCreateWithoutCourierInput[] | DeliveryUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCourierInput | DeliveryCreateOrConnectWithoutCourierInput[]
    createMany?: DeliveryCreateManyCourierInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type CourierSettingCreateNestedOneWithoutCouriersInput = {
    create?: XOR<CourierSettingCreateWithoutCouriersInput, CourierSettingUncheckedCreateWithoutCouriersInput>
    connectOrCreate?: CourierSettingCreateOrConnectWithoutCouriersInput
    connect?: CourierSettingWhereUniqueInput
  }

  export type PayoutCreateNestedManyWithoutCourierInput = {
    create?: XOR<PayoutCreateWithoutCourierInput, PayoutUncheckedCreateWithoutCourierInput> | PayoutCreateWithoutCourierInput[] | PayoutUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutCourierInput | PayoutCreateOrConnectWithoutCourierInput[]
    createMany?: PayoutCreateManyCourierInputEnvelope
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutCourierInput = {
    create?: XOR<TransferCreateWithoutCourierInput, TransferUncheckedCreateWithoutCourierInput> | TransferCreateWithoutCourierInput[] | TransferUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCourierInput | TransferCreateOrConnectWithoutCourierInput[]
    createMany?: TransferCreateManyCourierInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type LocationNoteCreateNestedManyWithoutCouriersInput = {
    create?: XOR<LocationNoteCreateWithoutCouriersInput, LocationNoteUncheckedCreateWithoutCouriersInput> | LocationNoteCreateWithoutCouriersInput[] | LocationNoteUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: LocationNoteCreateOrConnectWithoutCouriersInput | LocationNoteCreateOrConnectWithoutCouriersInput[]
    createMany?: LocationNoteCreateManyCouriersInputEnvelope
    connect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
  }

  export type LocationNoteReactionCreateNestedManyWithoutCouriersInput = {
    create?: XOR<LocationNoteReactionCreateWithoutCouriersInput, LocationNoteReactionUncheckedCreateWithoutCouriersInput> | LocationNoteReactionCreateWithoutCouriersInput[] | LocationNoteReactionUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: LocationNoteReactionCreateOrConnectWithoutCouriersInput | LocationNoteReactionCreateOrConnectWithoutCouriersInput[]
    createMany?: LocationNoteReactionCreateManyCouriersInputEnvelope
    connect?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutCouriersInput = {
    create?: XOR<CommentCreateWithoutCouriersInput, CommentUncheckedCreateWithoutCouriersInput> | CommentCreateWithoutCouriersInput[] | CommentUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCouriersInput | CommentCreateOrConnectWithoutCouriersInput[]
    createMany?: CommentCreateManyCouriersInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EarningUncheckedCreateNestedManyWithoutCouriersInput = {
    create?: XOR<EarningCreateWithoutCouriersInput, EarningUncheckedCreateWithoutCouriersInput> | EarningCreateWithoutCouriersInput[] | EarningUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: EarningCreateOrConnectWithoutCouriersInput | EarningCreateOrConnectWithoutCouriersInput[]
    createMany?: EarningCreateManyCouriersInputEnvelope
    connect?: EarningWhereUniqueInput | EarningWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedManyWithoutCourierInput = {
    create?: XOR<DeliveryCreateWithoutCourierInput, DeliveryUncheckedCreateWithoutCourierInput> | DeliveryCreateWithoutCourierInput[] | DeliveryUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCourierInput | DeliveryCreateOrConnectWithoutCourierInput[]
    createMany?: DeliveryCreateManyCourierInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type CourierSettingUncheckedCreateNestedOneWithoutCouriersInput = {
    create?: XOR<CourierSettingCreateWithoutCouriersInput, CourierSettingUncheckedCreateWithoutCouriersInput>
    connectOrCreate?: CourierSettingCreateOrConnectWithoutCouriersInput
    connect?: CourierSettingWhereUniqueInput
  }

  export type PayoutUncheckedCreateNestedManyWithoutCourierInput = {
    create?: XOR<PayoutCreateWithoutCourierInput, PayoutUncheckedCreateWithoutCourierInput> | PayoutCreateWithoutCourierInput[] | PayoutUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutCourierInput | PayoutCreateOrConnectWithoutCourierInput[]
    createMany?: PayoutCreateManyCourierInputEnvelope
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutCourierInput = {
    create?: XOR<TransferCreateWithoutCourierInput, TransferUncheckedCreateWithoutCourierInput> | TransferCreateWithoutCourierInput[] | TransferUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCourierInput | TransferCreateOrConnectWithoutCourierInput[]
    createMany?: TransferCreateManyCourierInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type LocationNoteUncheckedCreateNestedManyWithoutCouriersInput = {
    create?: XOR<LocationNoteCreateWithoutCouriersInput, LocationNoteUncheckedCreateWithoutCouriersInput> | LocationNoteCreateWithoutCouriersInput[] | LocationNoteUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: LocationNoteCreateOrConnectWithoutCouriersInput | LocationNoteCreateOrConnectWithoutCouriersInput[]
    createMany?: LocationNoteCreateManyCouriersInputEnvelope
    connect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
  }

  export type LocationNoteReactionUncheckedCreateNestedManyWithoutCouriersInput = {
    create?: XOR<LocationNoteReactionCreateWithoutCouriersInput, LocationNoteReactionUncheckedCreateWithoutCouriersInput> | LocationNoteReactionCreateWithoutCouriersInput[] | LocationNoteReactionUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: LocationNoteReactionCreateOrConnectWithoutCouriersInput | LocationNoteReactionCreateOrConnectWithoutCouriersInput[]
    createMany?: LocationNoteReactionCreateManyCouriersInputEnvelope
    connect?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
  }

  export type EnumEnumCourierStatusFieldUpdateOperationsInput = {
    set?: $Enums.EnumCourierStatus
  }

  export type EnumEnumCourierDeliverySettingFieldUpdateOperationsInput = {
    set?: $Enums.EnumCourierDeliverySetting
  }

  export type CourierUpdaterejectedOffersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumEnumStripeAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.EnumStripeAccountStatus
  }

  export type UserUpdateOneRequiredWithoutCourierNestedInput = {
    create?: XOR<UserCreateWithoutCourierInput, UserUncheckedCreateWithoutCourierInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourierInput
    upsert?: UserUpsertWithoutCourierInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCourierInput, UserUpdateWithoutCourierInput>, UserUncheckedUpdateWithoutCourierInput>
  }

  export type CommentUpdateManyWithoutCouriersNestedInput = {
    create?: XOR<CommentCreateWithoutCouriersInput, CommentUncheckedCreateWithoutCouriersInput> | CommentCreateWithoutCouriersInput[] | CommentUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCouriersInput | CommentCreateOrConnectWithoutCouriersInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCouriersInput | CommentUpsertWithWhereUniqueWithoutCouriersInput[]
    createMany?: CommentCreateManyCouriersInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCouriersInput | CommentUpdateWithWhereUniqueWithoutCouriersInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCouriersInput | CommentUpdateManyWithWhereWithoutCouriersInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type EarningUpdateManyWithoutCouriersNestedInput = {
    create?: XOR<EarningCreateWithoutCouriersInput, EarningUncheckedCreateWithoutCouriersInput> | EarningCreateWithoutCouriersInput[] | EarningUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: EarningCreateOrConnectWithoutCouriersInput | EarningCreateOrConnectWithoutCouriersInput[]
    upsert?: EarningUpsertWithWhereUniqueWithoutCouriersInput | EarningUpsertWithWhereUniqueWithoutCouriersInput[]
    createMany?: EarningCreateManyCouriersInputEnvelope
    set?: EarningWhereUniqueInput | EarningWhereUniqueInput[]
    disconnect?: EarningWhereUniqueInput | EarningWhereUniqueInput[]
    delete?: EarningWhereUniqueInput | EarningWhereUniqueInput[]
    connect?: EarningWhereUniqueInput | EarningWhereUniqueInput[]
    update?: EarningUpdateWithWhereUniqueWithoutCouriersInput | EarningUpdateWithWhereUniqueWithoutCouriersInput[]
    updateMany?: EarningUpdateManyWithWhereWithoutCouriersInput | EarningUpdateManyWithWhereWithoutCouriersInput[]
    deleteMany?: EarningScalarWhereInput | EarningScalarWhereInput[]
  }

  export type DeliveryUpdateManyWithoutCourierNestedInput = {
    create?: XOR<DeliveryCreateWithoutCourierInput, DeliveryUncheckedCreateWithoutCourierInput> | DeliveryCreateWithoutCourierInput[] | DeliveryUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCourierInput | DeliveryCreateOrConnectWithoutCourierInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutCourierInput | DeliveryUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: DeliveryCreateManyCourierInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutCourierInput | DeliveryUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutCourierInput | DeliveryUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type CourierSettingUpdateOneWithoutCouriersNestedInput = {
    create?: XOR<CourierSettingCreateWithoutCouriersInput, CourierSettingUncheckedCreateWithoutCouriersInput>
    connectOrCreate?: CourierSettingCreateOrConnectWithoutCouriersInput
    upsert?: CourierSettingUpsertWithoutCouriersInput
    disconnect?: CourierSettingWhereInput | boolean
    delete?: CourierSettingWhereInput | boolean
    connect?: CourierSettingWhereUniqueInput
    update?: XOR<XOR<CourierSettingUpdateToOneWithWhereWithoutCouriersInput, CourierSettingUpdateWithoutCouriersInput>, CourierSettingUncheckedUpdateWithoutCouriersInput>
  }

  export type PayoutUpdateManyWithoutCourierNestedInput = {
    create?: XOR<PayoutCreateWithoutCourierInput, PayoutUncheckedCreateWithoutCourierInput> | PayoutCreateWithoutCourierInput[] | PayoutUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutCourierInput | PayoutCreateOrConnectWithoutCourierInput[]
    upsert?: PayoutUpsertWithWhereUniqueWithoutCourierInput | PayoutUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: PayoutCreateManyCourierInputEnvelope
    set?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    disconnect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    delete?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    update?: PayoutUpdateWithWhereUniqueWithoutCourierInput | PayoutUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: PayoutUpdateManyWithWhereWithoutCourierInput | PayoutUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutCourierNestedInput = {
    create?: XOR<TransferCreateWithoutCourierInput, TransferUncheckedCreateWithoutCourierInput> | TransferCreateWithoutCourierInput[] | TransferUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCourierInput | TransferCreateOrConnectWithoutCourierInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutCourierInput | TransferUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: TransferCreateManyCourierInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutCourierInput | TransferUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutCourierInput | TransferUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type LocationNoteUpdateManyWithoutCouriersNestedInput = {
    create?: XOR<LocationNoteCreateWithoutCouriersInput, LocationNoteUncheckedCreateWithoutCouriersInput> | LocationNoteCreateWithoutCouriersInput[] | LocationNoteUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: LocationNoteCreateOrConnectWithoutCouriersInput | LocationNoteCreateOrConnectWithoutCouriersInput[]
    upsert?: LocationNoteUpsertWithWhereUniqueWithoutCouriersInput | LocationNoteUpsertWithWhereUniqueWithoutCouriersInput[]
    createMany?: LocationNoteCreateManyCouriersInputEnvelope
    set?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    disconnect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    delete?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    connect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    update?: LocationNoteUpdateWithWhereUniqueWithoutCouriersInput | LocationNoteUpdateWithWhereUniqueWithoutCouriersInput[]
    updateMany?: LocationNoteUpdateManyWithWhereWithoutCouriersInput | LocationNoteUpdateManyWithWhereWithoutCouriersInput[]
    deleteMany?: LocationNoteScalarWhereInput | LocationNoteScalarWhereInput[]
  }

  export type LocationNoteReactionUpdateManyWithoutCouriersNestedInput = {
    create?: XOR<LocationNoteReactionCreateWithoutCouriersInput, LocationNoteReactionUncheckedCreateWithoutCouriersInput> | LocationNoteReactionCreateWithoutCouriersInput[] | LocationNoteReactionUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: LocationNoteReactionCreateOrConnectWithoutCouriersInput | LocationNoteReactionCreateOrConnectWithoutCouriersInput[]
    upsert?: LocationNoteReactionUpsertWithWhereUniqueWithoutCouriersInput | LocationNoteReactionUpsertWithWhereUniqueWithoutCouriersInput[]
    createMany?: LocationNoteReactionCreateManyCouriersInputEnvelope
    set?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    disconnect?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    delete?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    connect?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    update?: LocationNoteReactionUpdateWithWhereUniqueWithoutCouriersInput | LocationNoteReactionUpdateWithWhereUniqueWithoutCouriersInput[]
    updateMany?: LocationNoteReactionUpdateManyWithWhereWithoutCouriersInput | LocationNoteReactionUpdateManyWithWhereWithoutCouriersInput[]
    deleteMany?: LocationNoteReactionScalarWhereInput | LocationNoteReactionScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutCouriersNestedInput = {
    create?: XOR<CommentCreateWithoutCouriersInput, CommentUncheckedCreateWithoutCouriersInput> | CommentCreateWithoutCouriersInput[] | CommentUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCouriersInput | CommentCreateOrConnectWithoutCouriersInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCouriersInput | CommentUpsertWithWhereUniqueWithoutCouriersInput[]
    createMany?: CommentCreateManyCouriersInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCouriersInput | CommentUpdateWithWhereUniqueWithoutCouriersInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCouriersInput | CommentUpdateManyWithWhereWithoutCouriersInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type EarningUncheckedUpdateManyWithoutCouriersNestedInput = {
    create?: XOR<EarningCreateWithoutCouriersInput, EarningUncheckedCreateWithoutCouriersInput> | EarningCreateWithoutCouriersInput[] | EarningUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: EarningCreateOrConnectWithoutCouriersInput | EarningCreateOrConnectWithoutCouriersInput[]
    upsert?: EarningUpsertWithWhereUniqueWithoutCouriersInput | EarningUpsertWithWhereUniqueWithoutCouriersInput[]
    createMany?: EarningCreateManyCouriersInputEnvelope
    set?: EarningWhereUniqueInput | EarningWhereUniqueInput[]
    disconnect?: EarningWhereUniqueInput | EarningWhereUniqueInput[]
    delete?: EarningWhereUniqueInput | EarningWhereUniqueInput[]
    connect?: EarningWhereUniqueInput | EarningWhereUniqueInput[]
    update?: EarningUpdateWithWhereUniqueWithoutCouriersInput | EarningUpdateWithWhereUniqueWithoutCouriersInput[]
    updateMany?: EarningUpdateManyWithWhereWithoutCouriersInput | EarningUpdateManyWithWhereWithoutCouriersInput[]
    deleteMany?: EarningScalarWhereInput | EarningScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateManyWithoutCourierNestedInput = {
    create?: XOR<DeliveryCreateWithoutCourierInput, DeliveryUncheckedCreateWithoutCourierInput> | DeliveryCreateWithoutCourierInput[] | DeliveryUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutCourierInput | DeliveryCreateOrConnectWithoutCourierInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutCourierInput | DeliveryUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: DeliveryCreateManyCourierInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutCourierInput | DeliveryUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutCourierInput | DeliveryUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type CourierSettingUncheckedUpdateOneWithoutCouriersNestedInput = {
    create?: XOR<CourierSettingCreateWithoutCouriersInput, CourierSettingUncheckedCreateWithoutCouriersInput>
    connectOrCreate?: CourierSettingCreateOrConnectWithoutCouriersInput
    upsert?: CourierSettingUpsertWithoutCouriersInput
    disconnect?: CourierSettingWhereInput | boolean
    delete?: CourierSettingWhereInput | boolean
    connect?: CourierSettingWhereUniqueInput
    update?: XOR<XOR<CourierSettingUpdateToOneWithWhereWithoutCouriersInput, CourierSettingUpdateWithoutCouriersInput>, CourierSettingUncheckedUpdateWithoutCouriersInput>
  }

  export type PayoutUncheckedUpdateManyWithoutCourierNestedInput = {
    create?: XOR<PayoutCreateWithoutCourierInput, PayoutUncheckedCreateWithoutCourierInput> | PayoutCreateWithoutCourierInput[] | PayoutUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutCourierInput | PayoutCreateOrConnectWithoutCourierInput[]
    upsert?: PayoutUpsertWithWhereUniqueWithoutCourierInput | PayoutUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: PayoutCreateManyCourierInputEnvelope
    set?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    disconnect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    delete?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    update?: PayoutUpdateWithWhereUniqueWithoutCourierInput | PayoutUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: PayoutUpdateManyWithWhereWithoutCourierInput | PayoutUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutCourierNestedInput = {
    create?: XOR<TransferCreateWithoutCourierInput, TransferUncheckedCreateWithoutCourierInput> | TransferCreateWithoutCourierInput[] | TransferUncheckedCreateWithoutCourierInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutCourierInput | TransferCreateOrConnectWithoutCourierInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutCourierInput | TransferUpsertWithWhereUniqueWithoutCourierInput[]
    createMany?: TransferCreateManyCourierInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutCourierInput | TransferUpdateWithWhereUniqueWithoutCourierInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutCourierInput | TransferUpdateManyWithWhereWithoutCourierInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type LocationNoteUncheckedUpdateManyWithoutCouriersNestedInput = {
    create?: XOR<LocationNoteCreateWithoutCouriersInput, LocationNoteUncheckedCreateWithoutCouriersInput> | LocationNoteCreateWithoutCouriersInput[] | LocationNoteUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: LocationNoteCreateOrConnectWithoutCouriersInput | LocationNoteCreateOrConnectWithoutCouriersInput[]
    upsert?: LocationNoteUpsertWithWhereUniqueWithoutCouriersInput | LocationNoteUpsertWithWhereUniqueWithoutCouriersInput[]
    createMany?: LocationNoteCreateManyCouriersInputEnvelope
    set?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    disconnect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    delete?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    connect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    update?: LocationNoteUpdateWithWhereUniqueWithoutCouriersInput | LocationNoteUpdateWithWhereUniqueWithoutCouriersInput[]
    updateMany?: LocationNoteUpdateManyWithWhereWithoutCouriersInput | LocationNoteUpdateManyWithWhereWithoutCouriersInput[]
    deleteMany?: LocationNoteScalarWhereInput | LocationNoteScalarWhereInput[]
  }

  export type LocationNoteReactionUncheckedUpdateManyWithoutCouriersNestedInput = {
    create?: XOR<LocationNoteReactionCreateWithoutCouriersInput, LocationNoteReactionUncheckedCreateWithoutCouriersInput> | LocationNoteReactionCreateWithoutCouriersInput[] | LocationNoteReactionUncheckedCreateWithoutCouriersInput[]
    connectOrCreate?: LocationNoteReactionCreateOrConnectWithoutCouriersInput | LocationNoteReactionCreateOrConnectWithoutCouriersInput[]
    upsert?: LocationNoteReactionUpsertWithWhereUniqueWithoutCouriersInput | LocationNoteReactionUpsertWithWhereUniqueWithoutCouriersInput[]
    createMany?: LocationNoteReactionCreateManyCouriersInputEnvelope
    set?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    disconnect?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    delete?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    connect?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    update?: LocationNoteReactionUpdateWithWhereUniqueWithoutCouriersInput | LocationNoteReactionUpdateWithWhereUniqueWithoutCouriersInput[]
    updateMany?: LocationNoteReactionUpdateManyWithWhereWithoutCouriersInput | LocationNoteReactionUpdateManyWithWhereWithoutCouriersInput[]
    deleteMany?: LocationNoteReactionScalarWhereInput | LocationNoteReactionScalarWhereInput[]
  }

  export type CourierCreateNestedOneWithoutEarningsInput = {
    create?: XOR<CourierCreateWithoutEarningsInput, CourierUncheckedCreateWithoutEarningsInput>
    connectOrCreate?: CourierCreateOrConnectWithoutEarningsInput
    connect?: CourierWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourierUpdateOneWithoutEarningsNestedInput = {
    create?: XOR<CourierCreateWithoutEarningsInput, CourierUncheckedCreateWithoutEarningsInput>
    connectOrCreate?: CourierCreateOrConnectWithoutEarningsInput
    upsert?: CourierUpsertWithoutEarningsInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutEarningsInput, CourierUpdateWithoutEarningsInput>, CourierUncheckedUpdateWithoutEarningsInput>
  }

  export type LocationNoteCreateNestedManyWithoutLocationsInput = {
    create?: XOR<LocationNoteCreateWithoutLocationsInput, LocationNoteUncheckedCreateWithoutLocationsInput> | LocationNoteCreateWithoutLocationsInput[] | LocationNoteUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: LocationNoteCreateOrConnectWithoutLocationsInput | LocationNoteCreateOrConnectWithoutLocationsInput[]
    createMany?: LocationNoteCreateManyLocationsInputEnvelope
    connect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
  }

  export type DeliveryCreateNestedManyWithoutPickupLocationInput = {
    create?: XOR<DeliveryCreateWithoutPickupLocationInput, DeliveryUncheckedCreateWithoutPickupLocationInput> | DeliveryCreateWithoutPickupLocationInput[] | DeliveryUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutPickupLocationInput | DeliveryCreateOrConnectWithoutPickupLocationInput[]
    createMany?: DeliveryCreateManyPickupLocationInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type DeliveryCreateNestedManyWithoutDropoffLocationInput = {
    create?: XOR<DeliveryCreateWithoutDropoffLocationInput, DeliveryUncheckedCreateWithoutDropoffLocationInput> | DeliveryCreateWithoutDropoffLocationInput[] | DeliveryUncheckedCreateWithoutDropoffLocationInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutDropoffLocationInput | DeliveryCreateOrConnectWithoutDropoffLocationInput[]
    createMany?: DeliveryCreateManyDropoffLocationInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type DeliveryQuoteCreateNestedManyWithoutPickupLocationInput = {
    create?: XOR<DeliveryQuoteCreateWithoutPickupLocationInput, DeliveryQuoteUncheckedCreateWithoutPickupLocationInput> | DeliveryQuoteCreateWithoutPickupLocationInput[] | DeliveryQuoteUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: DeliveryQuoteCreateOrConnectWithoutPickupLocationInput | DeliveryQuoteCreateOrConnectWithoutPickupLocationInput[]
    createMany?: DeliveryQuoteCreateManyPickupLocationInputEnvelope
    connect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
  }

  export type DeliveryQuoteCreateNestedManyWithoutDropoffLocationInput = {
    create?: XOR<DeliveryQuoteCreateWithoutDropoffLocationInput, DeliveryQuoteUncheckedCreateWithoutDropoffLocationInput> | DeliveryQuoteCreateWithoutDropoffLocationInput[] | DeliveryQuoteUncheckedCreateWithoutDropoffLocationInput[]
    connectOrCreate?: DeliveryQuoteCreateOrConnectWithoutDropoffLocationInput | DeliveryQuoteCreateOrConnectWithoutDropoffLocationInput[]
    createMany?: DeliveryQuoteCreateManyDropoffLocationInputEnvelope
    connect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
  }

  export type LocationNoteUncheckedCreateNestedManyWithoutLocationsInput = {
    create?: XOR<LocationNoteCreateWithoutLocationsInput, LocationNoteUncheckedCreateWithoutLocationsInput> | LocationNoteCreateWithoutLocationsInput[] | LocationNoteUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: LocationNoteCreateOrConnectWithoutLocationsInput | LocationNoteCreateOrConnectWithoutLocationsInput[]
    createMany?: LocationNoteCreateManyLocationsInputEnvelope
    connect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedManyWithoutPickupLocationInput = {
    create?: XOR<DeliveryCreateWithoutPickupLocationInput, DeliveryUncheckedCreateWithoutPickupLocationInput> | DeliveryCreateWithoutPickupLocationInput[] | DeliveryUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutPickupLocationInput | DeliveryCreateOrConnectWithoutPickupLocationInput[]
    createMany?: DeliveryCreateManyPickupLocationInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedManyWithoutDropoffLocationInput = {
    create?: XOR<DeliveryCreateWithoutDropoffLocationInput, DeliveryUncheckedCreateWithoutDropoffLocationInput> | DeliveryCreateWithoutDropoffLocationInput[] | DeliveryUncheckedCreateWithoutDropoffLocationInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutDropoffLocationInput | DeliveryCreateOrConnectWithoutDropoffLocationInput[]
    createMany?: DeliveryCreateManyDropoffLocationInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type DeliveryQuoteUncheckedCreateNestedManyWithoutPickupLocationInput = {
    create?: XOR<DeliveryQuoteCreateWithoutPickupLocationInput, DeliveryQuoteUncheckedCreateWithoutPickupLocationInput> | DeliveryQuoteCreateWithoutPickupLocationInput[] | DeliveryQuoteUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: DeliveryQuoteCreateOrConnectWithoutPickupLocationInput | DeliveryQuoteCreateOrConnectWithoutPickupLocationInput[]
    createMany?: DeliveryQuoteCreateManyPickupLocationInputEnvelope
    connect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
  }

  export type DeliveryQuoteUncheckedCreateNestedManyWithoutDropoffLocationInput = {
    create?: XOR<DeliveryQuoteCreateWithoutDropoffLocationInput, DeliveryQuoteUncheckedCreateWithoutDropoffLocationInput> | DeliveryQuoteCreateWithoutDropoffLocationInput[] | DeliveryQuoteUncheckedCreateWithoutDropoffLocationInput[]
    connectOrCreate?: DeliveryQuoteCreateOrConnectWithoutDropoffLocationInput | DeliveryQuoteCreateOrConnectWithoutDropoffLocationInput[]
    createMany?: DeliveryQuoteCreateManyDropoffLocationInputEnvelope
    connect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
  }

  export type EnumEnumCountryCodeFieldUpdateOperationsInput = {
    set?: $Enums.EnumCountryCode
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LocationNoteUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<LocationNoteCreateWithoutLocationsInput, LocationNoteUncheckedCreateWithoutLocationsInput> | LocationNoteCreateWithoutLocationsInput[] | LocationNoteUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: LocationNoteCreateOrConnectWithoutLocationsInput | LocationNoteCreateOrConnectWithoutLocationsInput[]
    upsert?: LocationNoteUpsertWithWhereUniqueWithoutLocationsInput | LocationNoteUpsertWithWhereUniqueWithoutLocationsInput[]
    createMany?: LocationNoteCreateManyLocationsInputEnvelope
    set?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    disconnect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    delete?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    connect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    update?: LocationNoteUpdateWithWhereUniqueWithoutLocationsInput | LocationNoteUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: LocationNoteUpdateManyWithWhereWithoutLocationsInput | LocationNoteUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: LocationNoteScalarWhereInput | LocationNoteScalarWhereInput[]
  }

  export type DeliveryUpdateManyWithoutPickupLocationNestedInput = {
    create?: XOR<DeliveryCreateWithoutPickupLocationInput, DeliveryUncheckedCreateWithoutPickupLocationInput> | DeliveryCreateWithoutPickupLocationInput[] | DeliveryUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutPickupLocationInput | DeliveryCreateOrConnectWithoutPickupLocationInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutPickupLocationInput | DeliveryUpsertWithWhereUniqueWithoutPickupLocationInput[]
    createMany?: DeliveryCreateManyPickupLocationInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutPickupLocationInput | DeliveryUpdateWithWhereUniqueWithoutPickupLocationInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutPickupLocationInput | DeliveryUpdateManyWithWhereWithoutPickupLocationInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type DeliveryUpdateManyWithoutDropoffLocationNestedInput = {
    create?: XOR<DeliveryCreateWithoutDropoffLocationInput, DeliveryUncheckedCreateWithoutDropoffLocationInput> | DeliveryCreateWithoutDropoffLocationInput[] | DeliveryUncheckedCreateWithoutDropoffLocationInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutDropoffLocationInput | DeliveryCreateOrConnectWithoutDropoffLocationInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutDropoffLocationInput | DeliveryUpsertWithWhereUniqueWithoutDropoffLocationInput[]
    createMany?: DeliveryCreateManyDropoffLocationInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutDropoffLocationInput | DeliveryUpdateWithWhereUniqueWithoutDropoffLocationInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutDropoffLocationInput | DeliveryUpdateManyWithWhereWithoutDropoffLocationInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type DeliveryQuoteUpdateManyWithoutPickupLocationNestedInput = {
    create?: XOR<DeliveryQuoteCreateWithoutPickupLocationInput, DeliveryQuoteUncheckedCreateWithoutPickupLocationInput> | DeliveryQuoteCreateWithoutPickupLocationInput[] | DeliveryQuoteUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: DeliveryQuoteCreateOrConnectWithoutPickupLocationInput | DeliveryQuoteCreateOrConnectWithoutPickupLocationInput[]
    upsert?: DeliveryQuoteUpsertWithWhereUniqueWithoutPickupLocationInput | DeliveryQuoteUpsertWithWhereUniqueWithoutPickupLocationInput[]
    createMany?: DeliveryQuoteCreateManyPickupLocationInputEnvelope
    set?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    disconnect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    delete?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    connect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    update?: DeliveryQuoteUpdateWithWhereUniqueWithoutPickupLocationInput | DeliveryQuoteUpdateWithWhereUniqueWithoutPickupLocationInput[]
    updateMany?: DeliveryQuoteUpdateManyWithWhereWithoutPickupLocationInput | DeliveryQuoteUpdateManyWithWhereWithoutPickupLocationInput[]
    deleteMany?: DeliveryQuoteScalarWhereInput | DeliveryQuoteScalarWhereInput[]
  }

  export type DeliveryQuoteUpdateManyWithoutDropoffLocationNestedInput = {
    create?: XOR<DeliveryQuoteCreateWithoutDropoffLocationInput, DeliveryQuoteUncheckedCreateWithoutDropoffLocationInput> | DeliveryQuoteCreateWithoutDropoffLocationInput[] | DeliveryQuoteUncheckedCreateWithoutDropoffLocationInput[]
    connectOrCreate?: DeliveryQuoteCreateOrConnectWithoutDropoffLocationInput | DeliveryQuoteCreateOrConnectWithoutDropoffLocationInput[]
    upsert?: DeliveryQuoteUpsertWithWhereUniqueWithoutDropoffLocationInput | DeliveryQuoteUpsertWithWhereUniqueWithoutDropoffLocationInput[]
    createMany?: DeliveryQuoteCreateManyDropoffLocationInputEnvelope
    set?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    disconnect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    delete?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    connect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    update?: DeliveryQuoteUpdateWithWhereUniqueWithoutDropoffLocationInput | DeliveryQuoteUpdateWithWhereUniqueWithoutDropoffLocationInput[]
    updateMany?: DeliveryQuoteUpdateManyWithWhereWithoutDropoffLocationInput | DeliveryQuoteUpdateManyWithWhereWithoutDropoffLocationInput[]
    deleteMany?: DeliveryQuoteScalarWhereInput | DeliveryQuoteScalarWhereInput[]
  }

  export type LocationNoteUncheckedUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<LocationNoteCreateWithoutLocationsInput, LocationNoteUncheckedCreateWithoutLocationsInput> | LocationNoteCreateWithoutLocationsInput[] | LocationNoteUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: LocationNoteCreateOrConnectWithoutLocationsInput | LocationNoteCreateOrConnectWithoutLocationsInput[]
    upsert?: LocationNoteUpsertWithWhereUniqueWithoutLocationsInput | LocationNoteUpsertWithWhereUniqueWithoutLocationsInput[]
    createMany?: LocationNoteCreateManyLocationsInputEnvelope
    set?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    disconnect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    delete?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    connect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    update?: LocationNoteUpdateWithWhereUniqueWithoutLocationsInput | LocationNoteUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: LocationNoteUpdateManyWithWhereWithoutLocationsInput | LocationNoteUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: LocationNoteScalarWhereInput | LocationNoteScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateManyWithoutPickupLocationNestedInput = {
    create?: XOR<DeliveryCreateWithoutPickupLocationInput, DeliveryUncheckedCreateWithoutPickupLocationInput> | DeliveryCreateWithoutPickupLocationInput[] | DeliveryUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutPickupLocationInput | DeliveryCreateOrConnectWithoutPickupLocationInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutPickupLocationInput | DeliveryUpsertWithWhereUniqueWithoutPickupLocationInput[]
    createMany?: DeliveryCreateManyPickupLocationInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutPickupLocationInput | DeliveryUpdateWithWhereUniqueWithoutPickupLocationInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutPickupLocationInput | DeliveryUpdateManyWithWhereWithoutPickupLocationInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateManyWithoutDropoffLocationNestedInput = {
    create?: XOR<DeliveryCreateWithoutDropoffLocationInput, DeliveryUncheckedCreateWithoutDropoffLocationInput> | DeliveryCreateWithoutDropoffLocationInput[] | DeliveryUncheckedCreateWithoutDropoffLocationInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutDropoffLocationInput | DeliveryCreateOrConnectWithoutDropoffLocationInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutDropoffLocationInput | DeliveryUpsertWithWhereUniqueWithoutDropoffLocationInput[]
    createMany?: DeliveryCreateManyDropoffLocationInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutDropoffLocationInput | DeliveryUpdateWithWhereUniqueWithoutDropoffLocationInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutDropoffLocationInput | DeliveryUpdateManyWithWhereWithoutDropoffLocationInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type DeliveryQuoteUncheckedUpdateManyWithoutPickupLocationNestedInput = {
    create?: XOR<DeliveryQuoteCreateWithoutPickupLocationInput, DeliveryQuoteUncheckedCreateWithoutPickupLocationInput> | DeliveryQuoteCreateWithoutPickupLocationInput[] | DeliveryQuoteUncheckedCreateWithoutPickupLocationInput[]
    connectOrCreate?: DeliveryQuoteCreateOrConnectWithoutPickupLocationInput | DeliveryQuoteCreateOrConnectWithoutPickupLocationInput[]
    upsert?: DeliveryQuoteUpsertWithWhereUniqueWithoutPickupLocationInput | DeliveryQuoteUpsertWithWhereUniqueWithoutPickupLocationInput[]
    createMany?: DeliveryQuoteCreateManyPickupLocationInputEnvelope
    set?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    disconnect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    delete?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    connect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    update?: DeliveryQuoteUpdateWithWhereUniqueWithoutPickupLocationInput | DeliveryQuoteUpdateWithWhereUniqueWithoutPickupLocationInput[]
    updateMany?: DeliveryQuoteUpdateManyWithWhereWithoutPickupLocationInput | DeliveryQuoteUpdateManyWithWhereWithoutPickupLocationInput[]
    deleteMany?: DeliveryQuoteScalarWhereInput | DeliveryQuoteScalarWhereInput[]
  }

  export type DeliveryQuoteUncheckedUpdateManyWithoutDropoffLocationNestedInput = {
    create?: XOR<DeliveryQuoteCreateWithoutDropoffLocationInput, DeliveryQuoteUncheckedCreateWithoutDropoffLocationInput> | DeliveryQuoteCreateWithoutDropoffLocationInput[] | DeliveryQuoteUncheckedCreateWithoutDropoffLocationInput[]
    connectOrCreate?: DeliveryQuoteCreateOrConnectWithoutDropoffLocationInput | DeliveryQuoteCreateOrConnectWithoutDropoffLocationInput[]
    upsert?: DeliveryQuoteUpsertWithWhereUniqueWithoutDropoffLocationInput | DeliveryQuoteUpsertWithWhereUniqueWithoutDropoffLocationInput[]
    createMany?: DeliveryQuoteCreateManyDropoffLocationInputEnvelope
    set?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    disconnect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    delete?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    connect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    update?: DeliveryQuoteUpdateWithWhereUniqueWithoutDropoffLocationInput | DeliveryQuoteUpdateWithWhereUniqueWithoutDropoffLocationInput[]
    updateMany?: DeliveryQuoteUpdateManyWithWhereWithoutDropoffLocationInput | DeliveryQuoteUpdateManyWithWhereWithoutDropoffLocationInput[]
    deleteMany?: DeliveryQuoteScalarWhereInput | DeliveryQuoteScalarWhereInput[]
  }

  export type DeliveryCreateNestedManyWithoutPartnerInput = {
    create?: XOR<DeliveryCreateWithoutPartnerInput, DeliveryUncheckedCreateWithoutPartnerInput> | DeliveryCreateWithoutPartnerInput[] | DeliveryUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutPartnerInput | DeliveryCreateOrConnectWithoutPartnerInput[]
    createMany?: DeliveryCreateManyPartnerInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type DeliveryQuoteCreateNestedManyWithoutPartnersInput = {
    create?: XOR<DeliveryQuoteCreateWithoutPartnersInput, DeliveryQuoteUncheckedCreateWithoutPartnersInput> | DeliveryQuoteCreateWithoutPartnersInput[] | DeliveryQuoteUncheckedCreateWithoutPartnersInput[]
    connectOrCreate?: DeliveryQuoteCreateOrConnectWithoutPartnersInput | DeliveryQuoteCreateOrConnectWithoutPartnersInput[]
    createMany?: DeliveryQuoteCreateManyPartnersInputEnvelope
    connect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPartnerInput = {
    create?: XOR<UserCreateWithoutPartnerInput, UserUncheckedCreateWithoutPartnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPartnerInput
    connect?: UserWhereUniqueInput
  }

  export type DeliveryUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<DeliveryCreateWithoutPartnerInput, DeliveryUncheckedCreateWithoutPartnerInput> | DeliveryCreateWithoutPartnerInput[] | DeliveryUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutPartnerInput | DeliveryCreateOrConnectWithoutPartnerInput[]
    createMany?: DeliveryCreateManyPartnerInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type DeliveryQuoteUncheckedCreateNestedManyWithoutPartnersInput = {
    create?: XOR<DeliveryQuoteCreateWithoutPartnersInput, DeliveryQuoteUncheckedCreateWithoutPartnersInput> | DeliveryQuoteCreateWithoutPartnersInput[] | DeliveryQuoteUncheckedCreateWithoutPartnersInput[]
    connectOrCreate?: DeliveryQuoteCreateOrConnectWithoutPartnersInput | DeliveryQuoteCreateOrConnectWithoutPartnersInput[]
    createMany?: DeliveryQuoteCreateManyPartnersInputEnvelope
    connect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
  }

  export type DeliveryUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<DeliveryCreateWithoutPartnerInput, DeliveryUncheckedCreateWithoutPartnerInput> | DeliveryCreateWithoutPartnerInput[] | DeliveryUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutPartnerInput | DeliveryCreateOrConnectWithoutPartnerInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutPartnerInput | DeliveryUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: DeliveryCreateManyPartnerInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutPartnerInput | DeliveryUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutPartnerInput | DeliveryUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type DeliveryQuoteUpdateManyWithoutPartnersNestedInput = {
    create?: XOR<DeliveryQuoteCreateWithoutPartnersInput, DeliveryQuoteUncheckedCreateWithoutPartnersInput> | DeliveryQuoteCreateWithoutPartnersInput[] | DeliveryQuoteUncheckedCreateWithoutPartnersInput[]
    connectOrCreate?: DeliveryQuoteCreateOrConnectWithoutPartnersInput | DeliveryQuoteCreateOrConnectWithoutPartnersInput[]
    upsert?: DeliveryQuoteUpsertWithWhereUniqueWithoutPartnersInput | DeliveryQuoteUpsertWithWhereUniqueWithoutPartnersInput[]
    createMany?: DeliveryQuoteCreateManyPartnersInputEnvelope
    set?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    disconnect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    delete?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    connect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    update?: DeliveryQuoteUpdateWithWhereUniqueWithoutPartnersInput | DeliveryQuoteUpdateWithWhereUniqueWithoutPartnersInput[]
    updateMany?: DeliveryQuoteUpdateManyWithWhereWithoutPartnersInput | DeliveryQuoteUpdateManyWithWhereWithoutPartnersInput[]
    deleteMany?: DeliveryQuoteScalarWhereInput | DeliveryQuoteScalarWhereInput[]
  }

  export type UserUpdateOneWithoutPartnerNestedInput = {
    create?: XOR<UserCreateWithoutPartnerInput, UserUncheckedCreateWithoutPartnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPartnerInput
    upsert?: UserUpsertWithoutPartnerInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPartnerInput, UserUpdateWithoutPartnerInput>, UserUncheckedUpdateWithoutPartnerInput>
  }

  export type DeliveryUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<DeliveryCreateWithoutPartnerInput, DeliveryUncheckedCreateWithoutPartnerInput> | DeliveryCreateWithoutPartnerInput[] | DeliveryUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutPartnerInput | DeliveryCreateOrConnectWithoutPartnerInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutPartnerInput | DeliveryUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: DeliveryCreateManyPartnerInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutPartnerInput | DeliveryUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutPartnerInput | DeliveryUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type DeliveryQuoteUncheckedUpdateManyWithoutPartnersNestedInput = {
    create?: XOR<DeliveryQuoteCreateWithoutPartnersInput, DeliveryQuoteUncheckedCreateWithoutPartnersInput> | DeliveryQuoteCreateWithoutPartnersInput[] | DeliveryQuoteUncheckedCreateWithoutPartnersInput[]
    connectOrCreate?: DeliveryQuoteCreateOrConnectWithoutPartnersInput | DeliveryQuoteCreateOrConnectWithoutPartnersInput[]
    upsert?: DeliveryQuoteUpsertWithWhereUniqueWithoutPartnersInput | DeliveryQuoteUpsertWithWhereUniqueWithoutPartnersInput[]
    createMany?: DeliveryQuoteCreateManyPartnersInputEnvelope
    set?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    disconnect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    delete?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    connect?: DeliveryQuoteWhereUniqueInput | DeliveryQuoteWhereUniqueInput[]
    update?: DeliveryQuoteUpdateWithWhereUniqueWithoutPartnersInput | DeliveryQuoteUpdateWithWhereUniqueWithoutPartnersInput[]
    updateMany?: DeliveryQuoteUpdateManyWithWhereWithoutPartnersInput | DeliveryQuoteUpdateManyWithWhereWithoutPartnersInput[]
    deleteMany?: DeliveryQuoteScalarWhereInput | DeliveryQuoteScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutPickupDeliveryQuotesInput = {
    create?: XOR<LocationCreateWithoutPickupDeliveryQuotesInput, LocationUncheckedCreateWithoutPickupDeliveryQuotesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutPickupDeliveryQuotesInput
    connect?: LocationWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutDropoffDeliveryQuotesInput = {
    create?: XOR<LocationCreateWithoutDropoffDeliveryQuotesInput, LocationUncheckedCreateWithoutDropoffDeliveryQuotesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutDropoffDeliveryQuotesInput
    connect?: LocationWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutDeliveryQuotesInput = {
    create?: XOR<PartnerCreateWithoutDeliveryQuotesInput, PartnerUncheckedCreateWithoutDeliveryQuotesInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutDeliveryQuotesInput
    connect?: PartnerWhereUniqueInput
  }

  export type DeliveryCreateNestedOneWithoutDeliveryInput = {
    create?: XOR<DeliveryCreateWithoutDeliveryInput, DeliveryUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutDeliveryInput
    connect?: DeliveryWhereUniqueInput
  }

  export type DeliveryUncheckedCreateNestedOneWithoutDeliveryInput = {
    create?: XOR<DeliveryCreateWithoutDeliveryInput, DeliveryUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutDeliveryInput
    connect?: DeliveryWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumEnumDistanceUnitFieldUpdateOperationsInput = {
    set?: $Enums.EnumDistanceUnit
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type LocationUpdateOneRequiredWithoutPickupDeliveryQuotesNestedInput = {
    create?: XOR<LocationCreateWithoutPickupDeliveryQuotesInput, LocationUncheckedCreateWithoutPickupDeliveryQuotesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutPickupDeliveryQuotesInput
    upsert?: LocationUpsertWithoutPickupDeliveryQuotesInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutPickupDeliveryQuotesInput, LocationUpdateWithoutPickupDeliveryQuotesInput>, LocationUncheckedUpdateWithoutPickupDeliveryQuotesInput>
  }

  export type LocationUpdateOneRequiredWithoutDropoffDeliveryQuotesNestedInput = {
    create?: XOR<LocationCreateWithoutDropoffDeliveryQuotesInput, LocationUncheckedCreateWithoutDropoffDeliveryQuotesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutDropoffDeliveryQuotesInput
    upsert?: LocationUpsertWithoutDropoffDeliveryQuotesInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutDropoffDeliveryQuotesInput, LocationUpdateWithoutDropoffDeliveryQuotesInput>, LocationUncheckedUpdateWithoutDropoffDeliveryQuotesInput>
  }

  export type PartnerUpdateOneWithoutDeliveryQuotesNestedInput = {
    create?: XOR<PartnerCreateWithoutDeliveryQuotesInput, PartnerUncheckedCreateWithoutDeliveryQuotesInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutDeliveryQuotesInput
    upsert?: PartnerUpsertWithoutDeliveryQuotesInput
    disconnect?: PartnerWhereInput | boolean
    delete?: PartnerWhereInput | boolean
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutDeliveryQuotesInput, PartnerUpdateWithoutDeliveryQuotesInput>, PartnerUncheckedUpdateWithoutDeliveryQuotesInput>
  }

  export type DeliveryUpdateOneWithoutDeliveryNestedInput = {
    create?: XOR<DeliveryCreateWithoutDeliveryInput, DeliveryUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutDeliveryInput
    upsert?: DeliveryUpsertWithoutDeliveryInput
    disconnect?: DeliveryWhereInput | boolean
    delete?: DeliveryWhereInput | boolean
    connect?: DeliveryWhereUniqueInput
    update?: XOR<XOR<DeliveryUpdateToOneWithWhereWithoutDeliveryInput, DeliveryUpdateWithoutDeliveryInput>, DeliveryUncheckedUpdateWithoutDeliveryInput>
  }

  export type DeliveryUncheckedUpdateOneWithoutDeliveryNestedInput = {
    create?: XOR<DeliveryCreateWithoutDeliveryInput, DeliveryUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutDeliveryInput
    upsert?: DeliveryUpsertWithoutDeliveryInput
    disconnect?: DeliveryWhereInput | boolean
    delete?: DeliveryWhereInput | boolean
    connect?: DeliveryWhereUniqueInput
    update?: XOR<XOR<DeliveryUpdateToOneWithWhereWithoutDeliveryInput, DeliveryUpdateWithoutDeliveryInput>, DeliveryUncheckedUpdateWithoutDeliveryInput>
  }

  export type DeliveryCreatedeliveryTypesInput = {
    set: string[]
  }

  export type DeliveryCreatecustomerNotesInput = {
    set: string[]
  }

  export type DeliveryCreatepickupTypesInput = {
    set: string[]
  }

  export type DeliveryCreaterejectedByCouriersInput = {
    set: string[]
  }

  export type LocationCreateNestedOneWithoutPickupDeliveryInput = {
    create?: XOR<LocationCreateWithoutPickupDeliveryInput, LocationUncheckedCreateWithoutPickupDeliveryInput>
    connectOrCreate?: LocationCreateOrConnectWithoutPickupDeliveryInput
    connect?: LocationWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutDropoffDeliveryInput = {
    create?: XOR<LocationCreateWithoutDropoffDeliveryInput, LocationUncheckedCreateWithoutDropoffDeliveryInput>
    connectOrCreate?: LocationCreateOrConnectWithoutDropoffDeliveryInput
    connect?: LocationWhereUniqueInput
  }

  export type CourierCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<CourierCreateWithoutDeliveriesInput, CourierUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: CourierCreateOrConnectWithoutDeliveriesInput
    connect?: CourierWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<PartnerCreateWithoutDeliveriesInput, PartnerUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutDeliveriesInput
    connect?: PartnerWhereUniqueInput
  }

  export type DeliveryQuoteCreateNestedOneWithoutDeliveryInput = {
    create?: XOR<DeliveryQuoteCreateWithoutDeliveryInput, DeliveryQuoteUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: DeliveryQuoteCreateOrConnectWithoutDeliveryInput
    connect?: DeliveryQuoteWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<PaymentCreateWithoutDeliveryInput, PaymentUncheckedCreateWithoutDeliveryInput> | PaymentCreateWithoutDeliveryInput[] | PaymentUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutDeliveryInput | PaymentCreateOrConnectWithoutDeliveryInput[]
    createMany?: PaymentCreateManyDeliveryInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DeliveryEventCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<DeliveryEventCreateWithoutDeliveryInput, DeliveryEventUncheckedCreateWithoutDeliveryInput> | DeliveryEventCreateWithoutDeliveryInput[] | DeliveryEventUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryEventCreateOrConnectWithoutDeliveryInput | DeliveryEventCreateOrConnectWithoutDeliveryInput[]
    createMany?: DeliveryEventCreateManyDeliveryInputEnvelope
    connect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
  }

  export type LocationNoteCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<LocationNoteCreateWithoutDeliveryInput, LocationNoteUncheckedCreateWithoutDeliveryInput> | LocationNoteCreateWithoutDeliveryInput[] | LocationNoteUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: LocationNoteCreateOrConnectWithoutDeliveryInput | LocationNoteCreateOrConnectWithoutDeliveryInput[]
    createMany?: LocationNoteCreateManyDeliveryInputEnvelope
    connect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<PaymentCreateWithoutDeliveryInput, PaymentUncheckedCreateWithoutDeliveryInput> | PaymentCreateWithoutDeliveryInput[] | PaymentUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutDeliveryInput | PaymentCreateOrConnectWithoutDeliveryInput[]
    createMany?: PaymentCreateManyDeliveryInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DeliveryEventUncheckedCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<DeliveryEventCreateWithoutDeliveryInput, DeliveryEventUncheckedCreateWithoutDeliveryInput> | DeliveryEventCreateWithoutDeliveryInput[] | DeliveryEventUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryEventCreateOrConnectWithoutDeliveryInput | DeliveryEventCreateOrConnectWithoutDeliveryInput[]
    createMany?: DeliveryEventCreateManyDeliveryInputEnvelope
    connect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
  }

  export type LocationNoteUncheckedCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<LocationNoteCreateWithoutDeliveryInput, LocationNoteUncheckedCreateWithoutDeliveryInput> | LocationNoteCreateWithoutDeliveryInput[] | LocationNoteUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: LocationNoteCreateOrConnectWithoutDeliveryInput | LocationNoteCreateOrConnectWithoutDeliveryInput[]
    createMany?: LocationNoteCreateManyDeliveryInputEnvelope
    connect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
  }

  export type EnumEnumDeliverableActionFieldUpdateOperationsInput = {
    set?: $Enums.EnumDeliverableAction
  }

  export type NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput = {
    set?: $Enums.EnumUndeliverableAction | null
  }

  export type DeliveryUpdatedeliveryTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumEnumDeliveryStatusFieldUpdateOperationsInput = {
    set?: $Enums.EnumDeliveryStatus
  }

  export type DeliveryUpdatecustomerNotesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DeliveryUpdatepickupTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type DeliveryUpdaterejectedByCouriersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LocationUpdateOneWithoutPickupDeliveryNestedInput = {
    create?: XOR<LocationCreateWithoutPickupDeliveryInput, LocationUncheckedCreateWithoutPickupDeliveryInput>
    connectOrCreate?: LocationCreateOrConnectWithoutPickupDeliveryInput
    upsert?: LocationUpsertWithoutPickupDeliveryInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutPickupDeliveryInput, LocationUpdateWithoutPickupDeliveryInput>, LocationUncheckedUpdateWithoutPickupDeliveryInput>
  }

  export type LocationUpdateOneWithoutDropoffDeliveryNestedInput = {
    create?: XOR<LocationCreateWithoutDropoffDeliveryInput, LocationUncheckedCreateWithoutDropoffDeliveryInput>
    connectOrCreate?: LocationCreateOrConnectWithoutDropoffDeliveryInput
    upsert?: LocationUpsertWithoutDropoffDeliveryInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutDropoffDeliveryInput, LocationUpdateWithoutDropoffDeliveryInput>, LocationUncheckedUpdateWithoutDropoffDeliveryInput>
  }

  export type CourierUpdateOneWithoutDeliveriesNestedInput = {
    create?: XOR<CourierCreateWithoutDeliveriesInput, CourierUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: CourierCreateOrConnectWithoutDeliveriesInput
    upsert?: CourierUpsertWithoutDeliveriesInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutDeliveriesInput, CourierUpdateWithoutDeliveriesInput>, CourierUncheckedUpdateWithoutDeliveriesInput>
  }

  export type PartnerUpdateOneWithoutDeliveriesNestedInput = {
    create?: XOR<PartnerCreateWithoutDeliveriesInput, PartnerUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutDeliveriesInput
    upsert?: PartnerUpsertWithoutDeliveriesInput
    disconnect?: PartnerWhereInput | boolean
    delete?: PartnerWhereInput | boolean
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutDeliveriesInput, PartnerUpdateWithoutDeliveriesInput>, PartnerUncheckedUpdateWithoutDeliveriesInput>
  }

  export type DeliveryQuoteUpdateOneRequiredWithoutDeliveryNestedInput = {
    create?: XOR<DeliveryQuoteCreateWithoutDeliveryInput, DeliveryQuoteUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: DeliveryQuoteCreateOrConnectWithoutDeliveryInput
    upsert?: DeliveryQuoteUpsertWithoutDeliveryInput
    connect?: DeliveryQuoteWhereUniqueInput
    update?: XOR<XOR<DeliveryQuoteUpdateToOneWithWhereWithoutDeliveryInput, DeliveryQuoteUpdateWithoutDeliveryInput>, DeliveryQuoteUncheckedUpdateWithoutDeliveryInput>
  }

  export type PaymentUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<PaymentCreateWithoutDeliveryInput, PaymentUncheckedCreateWithoutDeliveryInput> | PaymentCreateWithoutDeliveryInput[] | PaymentUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutDeliveryInput | PaymentCreateOrConnectWithoutDeliveryInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutDeliveryInput | PaymentUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: PaymentCreateManyDeliveryInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutDeliveryInput | PaymentUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutDeliveryInput | PaymentUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DeliveryEventUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<DeliveryEventCreateWithoutDeliveryInput, DeliveryEventUncheckedCreateWithoutDeliveryInput> | DeliveryEventCreateWithoutDeliveryInput[] | DeliveryEventUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryEventCreateOrConnectWithoutDeliveryInput | DeliveryEventCreateOrConnectWithoutDeliveryInput[]
    upsert?: DeliveryEventUpsertWithWhereUniqueWithoutDeliveryInput | DeliveryEventUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: DeliveryEventCreateManyDeliveryInputEnvelope
    set?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    disconnect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    delete?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    connect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    update?: DeliveryEventUpdateWithWhereUniqueWithoutDeliveryInput | DeliveryEventUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: DeliveryEventUpdateManyWithWhereWithoutDeliveryInput | DeliveryEventUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: DeliveryEventScalarWhereInput | DeliveryEventScalarWhereInput[]
  }

  export type LocationNoteUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<LocationNoteCreateWithoutDeliveryInput, LocationNoteUncheckedCreateWithoutDeliveryInput> | LocationNoteCreateWithoutDeliveryInput[] | LocationNoteUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: LocationNoteCreateOrConnectWithoutDeliveryInput | LocationNoteCreateOrConnectWithoutDeliveryInput[]
    upsert?: LocationNoteUpsertWithWhereUniqueWithoutDeliveryInput | LocationNoteUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: LocationNoteCreateManyDeliveryInputEnvelope
    set?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    disconnect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    delete?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    connect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    update?: LocationNoteUpdateWithWhereUniqueWithoutDeliveryInput | LocationNoteUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: LocationNoteUpdateManyWithWhereWithoutDeliveryInput | LocationNoteUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: LocationNoteScalarWhereInput | LocationNoteScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<PaymentCreateWithoutDeliveryInput, PaymentUncheckedCreateWithoutDeliveryInput> | PaymentCreateWithoutDeliveryInput[] | PaymentUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutDeliveryInput | PaymentCreateOrConnectWithoutDeliveryInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutDeliveryInput | PaymentUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: PaymentCreateManyDeliveryInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutDeliveryInput | PaymentUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutDeliveryInput | PaymentUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DeliveryEventUncheckedUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<DeliveryEventCreateWithoutDeliveryInput, DeliveryEventUncheckedCreateWithoutDeliveryInput> | DeliveryEventCreateWithoutDeliveryInput[] | DeliveryEventUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryEventCreateOrConnectWithoutDeliveryInput | DeliveryEventCreateOrConnectWithoutDeliveryInput[]
    upsert?: DeliveryEventUpsertWithWhereUniqueWithoutDeliveryInput | DeliveryEventUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: DeliveryEventCreateManyDeliveryInputEnvelope
    set?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    disconnect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    delete?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    connect?: DeliveryEventWhereUniqueInput | DeliveryEventWhereUniqueInput[]
    update?: DeliveryEventUpdateWithWhereUniqueWithoutDeliveryInput | DeliveryEventUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: DeliveryEventUpdateManyWithWhereWithoutDeliveryInput | DeliveryEventUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: DeliveryEventScalarWhereInput | DeliveryEventScalarWhereInput[]
  }

  export type LocationNoteUncheckedUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<LocationNoteCreateWithoutDeliveryInput, LocationNoteUncheckedCreateWithoutDeliveryInput> | LocationNoteCreateWithoutDeliveryInput[] | LocationNoteUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: LocationNoteCreateOrConnectWithoutDeliveryInput | LocationNoteCreateOrConnectWithoutDeliveryInput[]
    upsert?: LocationNoteUpsertWithWhereUniqueWithoutDeliveryInput | LocationNoteUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: LocationNoteCreateManyDeliveryInputEnvelope
    set?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    disconnect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    delete?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    connect?: LocationNoteWhereUniqueInput | LocationNoteWhereUniqueInput[]
    update?: LocationNoteUpdateWithWhereUniqueWithoutDeliveryInput | LocationNoteUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: LocationNoteUpdateManyWithWhereWithoutDeliveryInput | LocationNoteUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: LocationNoteScalarWhereInput | LocationNoteScalarWhereInput[]
  }

  export type DeliveryCreateNestedOneWithoutDeliveryEventInput = {
    create?: XOR<DeliveryCreateWithoutDeliveryEventInput, DeliveryUncheckedCreateWithoutDeliveryEventInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutDeliveryEventInput
    connect?: DeliveryWhereUniqueInput
  }

  export type EnumEnumDeliveryEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EnumDeliveryEventType
  }

  export type EnumEnumEventActorFieldUpdateOperationsInput = {
    set?: $Enums.EnumEventActor
  }

  export type EnumEnumDeliveryEventSourceFieldUpdateOperationsInput = {
    set?: $Enums.EnumDeliveryEventSource
  }

  export type NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput = {
    set?: $Enums.EnumDeliveryStatus | null
  }

  export type DeliveryUpdateOneRequiredWithoutDeliveryEventNestedInput = {
    create?: XOR<DeliveryCreateWithoutDeliveryEventInput, DeliveryUncheckedCreateWithoutDeliveryEventInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutDeliveryEventInput
    upsert?: DeliveryUpsertWithoutDeliveryEventInput
    connect?: DeliveryWhereUniqueInput
    update?: XOR<XOR<DeliveryUpdateToOneWithWhereWithoutDeliveryEventInput, DeliveryUpdateWithoutDeliveryEventInput>, DeliveryUncheckedUpdateWithoutDeliveryEventInput>
  }

  export type LocationCreateNestedOneWithoutLocationNotesInput = {
    create?: XOR<LocationCreateWithoutLocationNotesInput, LocationUncheckedCreateWithoutLocationNotesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutLocationNotesInput
    connect?: LocationWhereUniqueInput
  }

  export type DeliveryCreateNestedOneWithoutLocationNoteInput = {
    create?: XOR<DeliveryCreateWithoutLocationNoteInput, DeliveryUncheckedCreateWithoutLocationNoteInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutLocationNoteInput
    connect?: DeliveryWhereUniqueInput
  }

  export type CourierCreateNestedOneWithoutLocationNotesInput = {
    create?: XOR<CourierCreateWithoutLocationNotesInput, CourierUncheckedCreateWithoutLocationNotesInput>
    connectOrCreate?: CourierCreateOrConnectWithoutLocationNotesInput
    connect?: CourierWhereUniqueInput
  }

  export type LocationNoteReactionCreateNestedManyWithoutLocationNoteInput = {
    create?: XOR<LocationNoteReactionCreateWithoutLocationNoteInput, LocationNoteReactionUncheckedCreateWithoutLocationNoteInput> | LocationNoteReactionCreateWithoutLocationNoteInput[] | LocationNoteReactionUncheckedCreateWithoutLocationNoteInput[]
    connectOrCreate?: LocationNoteReactionCreateOrConnectWithoutLocationNoteInput | LocationNoteReactionCreateOrConnectWithoutLocationNoteInput[]
    createMany?: LocationNoteReactionCreateManyLocationNoteInputEnvelope
    connect?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
  }

  export type LocationNoteReactionUncheckedCreateNestedManyWithoutLocationNoteInput = {
    create?: XOR<LocationNoteReactionCreateWithoutLocationNoteInput, LocationNoteReactionUncheckedCreateWithoutLocationNoteInput> | LocationNoteReactionCreateWithoutLocationNoteInput[] | LocationNoteReactionUncheckedCreateWithoutLocationNoteInput[]
    connectOrCreate?: LocationNoteReactionCreateOrConnectWithoutLocationNoteInput | LocationNoteReactionCreateOrConnectWithoutLocationNoteInput[]
    createMany?: LocationNoteReactionCreateManyLocationNoteInputEnvelope
    connect?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
  }

  export type EnumEnumLocationNoteActorFieldUpdateOperationsInput = {
    set?: $Enums.EnumLocationNoteActor
  }

  export type LocationUpdateOneWithoutLocationNotesNestedInput = {
    create?: XOR<LocationCreateWithoutLocationNotesInput, LocationUncheckedCreateWithoutLocationNotesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutLocationNotesInput
    upsert?: LocationUpsertWithoutLocationNotesInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutLocationNotesInput, LocationUpdateWithoutLocationNotesInput>, LocationUncheckedUpdateWithoutLocationNotesInput>
  }

  export type DeliveryUpdateOneWithoutLocationNoteNestedInput = {
    create?: XOR<DeliveryCreateWithoutLocationNoteInput, DeliveryUncheckedCreateWithoutLocationNoteInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutLocationNoteInput
    upsert?: DeliveryUpsertWithoutLocationNoteInput
    disconnect?: DeliveryWhereInput | boolean
    delete?: DeliveryWhereInput | boolean
    connect?: DeliveryWhereUniqueInput
    update?: XOR<XOR<DeliveryUpdateToOneWithWhereWithoutLocationNoteInput, DeliveryUpdateWithoutLocationNoteInput>, DeliveryUncheckedUpdateWithoutLocationNoteInput>
  }

  export type CourierUpdateOneWithoutLocationNotesNestedInput = {
    create?: XOR<CourierCreateWithoutLocationNotesInput, CourierUncheckedCreateWithoutLocationNotesInput>
    connectOrCreate?: CourierCreateOrConnectWithoutLocationNotesInput
    upsert?: CourierUpsertWithoutLocationNotesInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutLocationNotesInput, CourierUpdateWithoutLocationNotesInput>, CourierUncheckedUpdateWithoutLocationNotesInput>
  }

  export type LocationNoteReactionUpdateManyWithoutLocationNoteNestedInput = {
    create?: XOR<LocationNoteReactionCreateWithoutLocationNoteInput, LocationNoteReactionUncheckedCreateWithoutLocationNoteInput> | LocationNoteReactionCreateWithoutLocationNoteInput[] | LocationNoteReactionUncheckedCreateWithoutLocationNoteInput[]
    connectOrCreate?: LocationNoteReactionCreateOrConnectWithoutLocationNoteInput | LocationNoteReactionCreateOrConnectWithoutLocationNoteInput[]
    upsert?: LocationNoteReactionUpsertWithWhereUniqueWithoutLocationNoteInput | LocationNoteReactionUpsertWithWhereUniqueWithoutLocationNoteInput[]
    createMany?: LocationNoteReactionCreateManyLocationNoteInputEnvelope
    set?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    disconnect?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    delete?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    connect?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    update?: LocationNoteReactionUpdateWithWhereUniqueWithoutLocationNoteInput | LocationNoteReactionUpdateWithWhereUniqueWithoutLocationNoteInput[]
    updateMany?: LocationNoteReactionUpdateManyWithWhereWithoutLocationNoteInput | LocationNoteReactionUpdateManyWithWhereWithoutLocationNoteInput[]
    deleteMany?: LocationNoteReactionScalarWhereInput | LocationNoteReactionScalarWhereInput[]
  }

  export type LocationNoteReactionUncheckedUpdateManyWithoutLocationNoteNestedInput = {
    create?: XOR<LocationNoteReactionCreateWithoutLocationNoteInput, LocationNoteReactionUncheckedCreateWithoutLocationNoteInput> | LocationNoteReactionCreateWithoutLocationNoteInput[] | LocationNoteReactionUncheckedCreateWithoutLocationNoteInput[]
    connectOrCreate?: LocationNoteReactionCreateOrConnectWithoutLocationNoteInput | LocationNoteReactionCreateOrConnectWithoutLocationNoteInput[]
    upsert?: LocationNoteReactionUpsertWithWhereUniqueWithoutLocationNoteInput | LocationNoteReactionUpsertWithWhereUniqueWithoutLocationNoteInput[]
    createMany?: LocationNoteReactionCreateManyLocationNoteInputEnvelope
    set?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    disconnect?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    delete?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    connect?: LocationNoteReactionWhereUniqueInput | LocationNoteReactionWhereUniqueInput[]
    update?: LocationNoteReactionUpdateWithWhereUniqueWithoutLocationNoteInput | LocationNoteReactionUpdateWithWhereUniqueWithoutLocationNoteInput[]
    updateMany?: LocationNoteReactionUpdateManyWithWhereWithoutLocationNoteInput | LocationNoteReactionUpdateManyWithWhereWithoutLocationNoteInput[]
    deleteMany?: LocationNoteReactionScalarWhereInput | LocationNoteReactionScalarWhereInput[]
  }

  export type LocationNoteCreateNestedOneWithoutNoteReactionsInput = {
    create?: XOR<LocationNoteCreateWithoutNoteReactionsInput, LocationNoteUncheckedCreateWithoutNoteReactionsInput>
    connectOrCreate?: LocationNoteCreateOrConnectWithoutNoteReactionsInput
    connect?: LocationNoteWhereUniqueInput
  }

  export type CourierCreateNestedOneWithoutLocationNoteReactionsInput = {
    create?: XOR<CourierCreateWithoutLocationNoteReactionsInput, CourierUncheckedCreateWithoutLocationNoteReactionsInput>
    connectOrCreate?: CourierCreateOrConnectWithoutLocationNoteReactionsInput
    connect?: CourierWhereUniqueInput
  }

  export type EnumEnumLocationNoteReactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.EnumLocationNoteReactionType
  }

  export type LocationNoteUpdateOneRequiredWithoutNoteReactionsNestedInput = {
    create?: XOR<LocationNoteCreateWithoutNoteReactionsInput, LocationNoteUncheckedCreateWithoutNoteReactionsInput>
    connectOrCreate?: LocationNoteCreateOrConnectWithoutNoteReactionsInput
    upsert?: LocationNoteUpsertWithoutNoteReactionsInput
    connect?: LocationNoteWhereUniqueInput
    update?: XOR<XOR<LocationNoteUpdateToOneWithWhereWithoutNoteReactionsInput, LocationNoteUpdateWithoutNoteReactionsInput>, LocationNoteUncheckedUpdateWithoutNoteReactionsInput>
  }

  export type CourierUpdateOneRequiredWithoutLocationNoteReactionsNestedInput = {
    create?: XOR<CourierCreateWithoutLocationNoteReactionsInput, CourierUncheckedCreateWithoutLocationNoteReactionsInput>
    connectOrCreate?: CourierCreateOrConnectWithoutLocationNoteReactionsInput
    upsert?: CourierUpsertWithoutLocationNoteReactionsInput
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutLocationNoteReactionsInput, CourierUpdateWithoutLocationNoteReactionsInput>, CourierUncheckedUpdateWithoutLocationNoteReactionsInput>
  }

  export type CourierSettingCreatepreferredAreasInput = {
    set: string[]
  }

  export type CourierSettingCreatedeliveryPreferencesInput = {
    set: string[]
  }

  export type CourierSettingCreatefoodPreferencesInput = {
    set: string[]
  }

  export type CourierSettingCreaterestaurantTypesInput = {
    set: string[]
  }

  export type CourierSettingCreatecuisineTypesInput = {
    set: string[]
  }

  export type CourierSettingCreatepreferredRestaurantPartnersInput = {
    set: string[]
  }

  export type CourierSettingCreatedietaryRestrictionsInput = {
    set: string[]
  }

  export type CourierCreateNestedOneWithoutSettingsInput = {
    create?: XOR<CourierCreateWithoutSettingsInput, CourierUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: CourierCreateOrConnectWithoutSettingsInput
    connect?: CourierWhereUniqueInput
  }

  export type NullableEnumEnumSettingVehicleTypeFieldUpdateOperationsInput = {
    set?: $Enums.EnumSettingVehicleType | null
  }

  export type CourierSettingUpdatepreferredAreasInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourierSettingUpdatedeliveryPreferencesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourierSettingUpdatefoodPreferencesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableEnumEnumSettingDeliverySpeedFieldUpdateOperationsInput = {
    set?: $Enums.EnumSettingDeliverySpeed | null
  }

  export type CourierSettingUpdaterestaurantTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourierSettingUpdatecuisineTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourierSettingUpdatepreferredRestaurantPartnersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourierSettingUpdatedietaryRestrictionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourierUpdateOneWithoutSettingsNestedInput = {
    create?: XOR<CourierCreateWithoutSettingsInput, CourierUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: CourierCreateOrConnectWithoutSettingsInput
    upsert?: CourierUpsertWithoutSettingsInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutSettingsInput, CourierUpdateWithoutSettingsInput>, CourierUncheckedUpdateWithoutSettingsInput>
  }

  export type PaymentCreateNestedOneWithoutPayoutsInput = {
    create?: XOR<PaymentCreateWithoutPayoutsInput, PaymentUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutPayoutsInput
    connect?: PaymentWhereUniqueInput
  }

  export type CourierCreateNestedOneWithoutPayoutInput = {
    create?: XOR<CourierCreateWithoutPayoutInput, CourierUncheckedCreateWithoutPayoutInput>
    connectOrCreate?: CourierCreateOrConnectWithoutPayoutInput
    connect?: CourierWhereUniqueInput
  }

  export type EnumEnumPayoutStatusFieldUpdateOperationsInput = {
    set?: $Enums.EnumPayoutStatus
  }

  export type PaymentUpdateOneRequiredWithoutPayoutsNestedInput = {
    create?: XOR<PaymentCreateWithoutPayoutsInput, PaymentUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutPayoutsInput
    upsert?: PaymentUpsertWithoutPayoutsInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutPayoutsInput, PaymentUpdateWithoutPayoutsInput>, PaymentUncheckedUpdateWithoutPayoutsInput>
  }

  export type CourierUpdateOneWithoutPayoutNestedInput = {
    create?: XOR<CourierCreateWithoutPayoutInput, CourierUncheckedCreateWithoutPayoutInput>
    connectOrCreate?: CourierCreateOrConnectWithoutPayoutInput
    upsert?: CourierUpsertWithoutPayoutInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutPayoutInput, CourierUpdateWithoutPayoutInput>, CourierUncheckedUpdateWithoutPayoutInput>
  }

  export type DeliveryCreateNestedOneWithoutPaymentInput = {
    create?: XOR<DeliveryCreateWithoutPaymentInput, DeliveryUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutPaymentInput
    connect?: DeliveryWhereUniqueInput
  }

  export type TransferCreateNestedManyWithoutPaymentInput = {
    create?: XOR<TransferCreateWithoutPaymentInput, TransferUncheckedCreateWithoutPaymentInput> | TransferCreateWithoutPaymentInput[] | TransferUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutPaymentInput | TransferCreateOrConnectWithoutPaymentInput[]
    createMany?: TransferCreateManyPaymentInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type RefundCreateNestedManyWithoutPaymentInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
  }

  export type PayoutCreateNestedManyWithoutPaymentInput = {
    create?: XOR<PayoutCreateWithoutPaymentInput, PayoutUncheckedCreateWithoutPaymentInput> | PayoutCreateWithoutPaymentInput[] | PayoutUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutPaymentInput | PayoutCreateOrConnectWithoutPaymentInput[]
    createMany?: PayoutCreateManyPaymentInputEnvelope
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
  }

  export type StripePaymentDataCreateNestedOneWithoutPaymentInput = {
    create?: XOR<StripePaymentDataCreateWithoutPaymentInput, StripePaymentDataUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: StripePaymentDataCreateOrConnectWithoutPaymentInput
    connect?: StripePaymentDataWhereUniqueInput
  }

  export type TransferUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<TransferCreateWithoutPaymentInput, TransferUncheckedCreateWithoutPaymentInput> | TransferCreateWithoutPaymentInput[] | TransferUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutPaymentInput | TransferCreateOrConnectWithoutPaymentInput[]
    createMany?: TransferCreateManyPaymentInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type RefundUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
  }

  export type PayoutUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<PayoutCreateWithoutPaymentInput, PayoutUncheckedCreateWithoutPaymentInput> | PayoutCreateWithoutPaymentInput[] | PayoutUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutPaymentInput | PayoutCreateOrConnectWithoutPaymentInput[]
    createMany?: PayoutCreateManyPaymentInputEnvelope
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
  }

  export type StripePaymentDataUncheckedCreateNestedOneWithoutPaymentInput = {
    create?: XOR<StripePaymentDataCreateWithoutPaymentInput, StripePaymentDataUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: StripePaymentDataCreateOrConnectWithoutPaymentInput
    connect?: StripePaymentDataWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumEnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.EnumPaymentStatus
  }

  export type EnumEnumPaymentProviderFieldUpdateOperationsInput = {
    set?: $Enums.EnumPaymentProvider
  }

  export type DeliveryUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<DeliveryCreateWithoutPaymentInput, DeliveryUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutPaymentInput
    upsert?: DeliveryUpsertWithoutPaymentInput
    connect?: DeliveryWhereUniqueInput
    update?: XOR<XOR<DeliveryUpdateToOneWithWhereWithoutPaymentInput, DeliveryUpdateWithoutPaymentInput>, DeliveryUncheckedUpdateWithoutPaymentInput>
  }

  export type TransferUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<TransferCreateWithoutPaymentInput, TransferUncheckedCreateWithoutPaymentInput> | TransferCreateWithoutPaymentInput[] | TransferUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutPaymentInput | TransferCreateOrConnectWithoutPaymentInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutPaymentInput | TransferUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: TransferCreateManyPaymentInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutPaymentInput | TransferUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutPaymentInput | TransferUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type RefundUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    upsert?: RefundUpsertWithWhereUniqueWithoutPaymentInput | RefundUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    update?: RefundUpdateWithWhereUniqueWithoutPaymentInput | RefundUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: RefundUpdateManyWithWhereWithoutPaymentInput | RefundUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[]
  }

  export type PayoutUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<PayoutCreateWithoutPaymentInput, PayoutUncheckedCreateWithoutPaymentInput> | PayoutCreateWithoutPaymentInput[] | PayoutUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutPaymentInput | PayoutCreateOrConnectWithoutPaymentInput[]
    upsert?: PayoutUpsertWithWhereUniqueWithoutPaymentInput | PayoutUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: PayoutCreateManyPaymentInputEnvelope
    set?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    disconnect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    delete?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    update?: PayoutUpdateWithWhereUniqueWithoutPaymentInput | PayoutUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: PayoutUpdateManyWithWhereWithoutPaymentInput | PayoutUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
  }

  export type StripePaymentDataUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<StripePaymentDataCreateWithoutPaymentInput, StripePaymentDataUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: StripePaymentDataCreateOrConnectWithoutPaymentInput
    upsert?: StripePaymentDataUpsertWithoutPaymentInput
    disconnect?: StripePaymentDataWhereInput | boolean
    delete?: StripePaymentDataWhereInput | boolean
    connect?: StripePaymentDataWhereUniqueInput
    update?: XOR<XOR<StripePaymentDataUpdateToOneWithWhereWithoutPaymentInput, StripePaymentDataUpdateWithoutPaymentInput>, StripePaymentDataUncheckedUpdateWithoutPaymentInput>
  }

  export type TransferUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<TransferCreateWithoutPaymentInput, TransferUncheckedCreateWithoutPaymentInput> | TransferCreateWithoutPaymentInput[] | TransferUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutPaymentInput | TransferCreateOrConnectWithoutPaymentInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutPaymentInput | TransferUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: TransferCreateManyPaymentInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutPaymentInput | TransferUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutPaymentInput | TransferUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type RefundUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    upsert?: RefundUpsertWithWhereUniqueWithoutPaymentInput | RefundUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    update?: RefundUpdateWithWhereUniqueWithoutPaymentInput | RefundUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: RefundUpdateManyWithWhereWithoutPaymentInput | RefundUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[]
  }

  export type PayoutUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<PayoutCreateWithoutPaymentInput, PayoutUncheckedCreateWithoutPaymentInput> | PayoutCreateWithoutPaymentInput[] | PayoutUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutPaymentInput | PayoutCreateOrConnectWithoutPaymentInput[]
    upsert?: PayoutUpsertWithWhereUniqueWithoutPaymentInput | PayoutUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: PayoutCreateManyPaymentInputEnvelope
    set?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    disconnect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    delete?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    update?: PayoutUpdateWithWhereUniqueWithoutPaymentInput | PayoutUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: PayoutUpdateManyWithWhereWithoutPaymentInput | PayoutUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
  }

  export type StripePaymentDataUncheckedUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<StripePaymentDataCreateWithoutPaymentInput, StripePaymentDataUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: StripePaymentDataCreateOrConnectWithoutPaymentInput
    upsert?: StripePaymentDataUpsertWithoutPaymentInput
    disconnect?: StripePaymentDataWhereInput | boolean
    delete?: StripePaymentDataWhereInput | boolean
    connect?: StripePaymentDataWhereUniqueInput
    update?: XOR<XOR<StripePaymentDataUpdateToOneWithWhereWithoutPaymentInput, StripePaymentDataUpdateWithoutPaymentInput>, StripePaymentDataUncheckedUpdateWithoutPaymentInput>
  }

  export type PaymentCreateNestedOneWithoutStripeDataInput = {
    create?: XOR<PaymentCreateWithoutStripeDataInput, PaymentUncheckedCreateWithoutStripeDataInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutStripeDataInput
    connect?: PaymentWhereUniqueInput
  }

  export type PaymentUpdateOneWithoutStripeDataNestedInput = {
    create?: XOR<PaymentCreateWithoutStripeDataInput, PaymentUncheckedCreateWithoutStripeDataInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutStripeDataInput
    upsert?: PaymentUpsertWithoutStripeDataInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutStripeDataInput, PaymentUpdateWithoutStripeDataInput>, PaymentUncheckedUpdateWithoutStripeDataInput>
  }

  export type PaymentCreateNestedOneWithoutTransfersInput = {
    create?: XOR<PaymentCreateWithoutTransfersInput, PaymentUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransfersInput
    connect?: PaymentWhereUniqueInput
  }

  export type CourierCreateNestedOneWithoutTransferInput = {
    create?: XOR<CourierCreateWithoutTransferInput, CourierUncheckedCreateWithoutTransferInput>
    connectOrCreate?: CourierCreateOrConnectWithoutTransferInput
    connect?: CourierWhereUniqueInput
  }

  export type PaymentUpdateOneWithoutTransfersNestedInput = {
    create?: XOR<PaymentCreateWithoutTransfersInput, PaymentUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransfersInput
    upsert?: PaymentUpsertWithoutTransfersInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutTransfersInput, PaymentUpdateWithoutTransfersInput>, PaymentUncheckedUpdateWithoutTransfersInput>
  }

  export type CourierUpdateOneWithoutTransferNestedInput = {
    create?: XOR<CourierCreateWithoutTransferInput, CourierUncheckedCreateWithoutTransferInput>
    connectOrCreate?: CourierCreateOrConnectWithoutTransferInput
    upsert?: CourierUpsertWithoutTransferInput
    disconnect?: CourierWhereInput | boolean
    delete?: CourierWhereInput | boolean
    connect?: CourierWhereUniqueInput
    update?: XOR<XOR<CourierUpdateToOneWithWhereWithoutTransferInput, CourierUpdateWithoutTransferInput>, CourierUncheckedUpdateWithoutTransferInput>
  }

  export type PaymentCreateNestedOneWithoutRefundsInput = {
    create?: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutRefundsInput
    connect?: PaymentWhereUniqueInput
  }

  export type NullableEnumEnumRefundReasonFieldUpdateOperationsInput = {
    set?: $Enums.EnumRefundReason | null
  }

  export type NullableEnumEnumRefundStatusFieldUpdateOperationsInput = {
    set?: $Enums.EnumRefundStatus | null
  }

  export type PaymentUpdateOneRequiredWithoutRefundsNestedInput = {
    create?: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutRefundsInput
    upsert?: PaymentUpsertWithoutRefundsInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutRefundsInput, PaymentUpdateWithoutRefundsInput>, PaymentUncheckedUpdateWithoutRefundsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEnumCourierStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumCourierStatus | EnumEnumCourierStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumCourierStatus[] | ListEnumEnumCourierStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumCourierStatus[] | ListEnumEnumCourierStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumCourierStatusFilter<$PrismaModel> | $Enums.EnumCourierStatus
  }

  export type NestedEnumEnumCourierDeliverySettingFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumCourierDeliverySetting | EnumEnumCourierDeliverySettingFieldRefInput<$PrismaModel>
    in?: $Enums.EnumCourierDeliverySetting[] | ListEnumEnumCourierDeliverySettingFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumCourierDeliverySetting[] | ListEnumEnumCourierDeliverySettingFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumCourierDeliverySettingFilter<$PrismaModel> | $Enums.EnumCourierDeliverySetting
  }

  export type NestedEnumEnumStripeAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumStripeAccountStatus | EnumEnumStripeAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumStripeAccountStatus[] | ListEnumEnumStripeAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumStripeAccountStatus[] | ListEnumEnumStripeAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumStripeAccountStatusFilter<$PrismaModel> | $Enums.EnumStripeAccountStatus
  }

  export type NestedEnumEnumCourierStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumCourierStatus | EnumEnumCourierStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumCourierStatus[] | ListEnumEnumCourierStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumCourierStatus[] | ListEnumEnumCourierStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumCourierStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnumCourierStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumCourierStatusFilter<$PrismaModel>
    _max?: NestedEnumEnumCourierStatusFilter<$PrismaModel>
  }

  export type NestedEnumEnumCourierDeliverySettingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumCourierDeliverySetting | EnumEnumCourierDeliverySettingFieldRefInput<$PrismaModel>
    in?: $Enums.EnumCourierDeliverySetting[] | ListEnumEnumCourierDeliverySettingFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumCourierDeliverySetting[] | ListEnumEnumCourierDeliverySettingFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumCourierDeliverySettingWithAggregatesFilter<$PrismaModel> | $Enums.EnumCourierDeliverySetting
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumCourierDeliverySettingFilter<$PrismaModel>
    _max?: NestedEnumEnumCourierDeliverySettingFilter<$PrismaModel>
  }

  export type NestedEnumEnumStripeAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumStripeAccountStatus | EnumEnumStripeAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumStripeAccountStatus[] | ListEnumEnumStripeAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumStripeAccountStatus[] | ListEnumEnumStripeAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumStripeAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnumStripeAccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumStripeAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumEnumStripeAccountStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumEnumCountryCodeFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumCountryCode | EnumEnumCountryCodeFieldRefInput<$PrismaModel>
    in?: $Enums.EnumCountryCode[] | ListEnumEnumCountryCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumCountryCode[] | ListEnumEnumCountryCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumCountryCodeFilter<$PrismaModel> | $Enums.EnumCountryCode
  }

  export type NestedEnumEnumCountryCodeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumCountryCode | EnumEnumCountryCodeFieldRefInput<$PrismaModel>
    in?: $Enums.EnumCountryCode[] | ListEnumEnumCountryCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumCountryCode[] | ListEnumEnumCountryCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumCountryCodeWithAggregatesFilter<$PrismaModel> | $Enums.EnumCountryCode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumCountryCodeFilter<$PrismaModel>
    _max?: NestedEnumEnumCountryCodeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumEnumDistanceUnitFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDistanceUnit | EnumEnumDistanceUnitFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDistanceUnit[] | ListEnumEnumDistanceUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDistanceUnit[] | ListEnumEnumDistanceUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDistanceUnitFilter<$PrismaModel> | $Enums.EnumDistanceUnit
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumEnumDistanceUnitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDistanceUnit | EnumEnumDistanceUnitFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDistanceUnit[] | ListEnumEnumDistanceUnitFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDistanceUnit[] | ListEnumEnumDistanceUnitFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDistanceUnitWithAggregatesFilter<$PrismaModel> | $Enums.EnumDistanceUnit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumDistanceUnitFilter<$PrismaModel>
    _max?: NestedEnumEnumDistanceUnitFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumEnumDeliverableActionFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliverableAction | EnumEnumDeliverableActionFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliverableAction[] | ListEnumEnumDeliverableActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliverableAction[] | ListEnumEnumDeliverableActionFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliverableActionFilter<$PrismaModel> | $Enums.EnumDeliverableAction
  }

  export type NestedEnumEnumUndeliverableActionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumUndeliverableAction | EnumEnumUndeliverableActionFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumUndeliverableAction[] | ListEnumEnumUndeliverableActionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumUndeliverableAction[] | ListEnumEnumUndeliverableActionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumUndeliverableActionNullableFilter<$PrismaModel> | $Enums.EnumUndeliverableAction | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumEnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryStatus | EnumEnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliveryStatusFilter<$PrismaModel> | $Enums.EnumDeliveryStatus
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumEnumDeliverableActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliverableAction | EnumEnumDeliverableActionFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliverableAction[] | ListEnumEnumDeliverableActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliverableAction[] | ListEnumEnumDeliverableActionFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliverableActionWithAggregatesFilter<$PrismaModel> | $Enums.EnumDeliverableAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumDeliverableActionFilter<$PrismaModel>
    _max?: NestedEnumEnumDeliverableActionFilter<$PrismaModel>
  }

  export type NestedEnumEnumUndeliverableActionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumUndeliverableAction | EnumEnumUndeliverableActionFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumUndeliverableAction[] | ListEnumEnumUndeliverableActionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumUndeliverableAction[] | ListEnumEnumUndeliverableActionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumUndeliverableActionNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnumUndeliverableAction | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnumUndeliverableActionNullableFilter<$PrismaModel>
    _max?: NestedEnumEnumUndeliverableActionNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumEnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryStatus | EnumEnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnumDeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumEnumDeliveryStatusFilter<$PrismaModel>
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedEnumEnumDeliveryEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryEventType | EnumEnumDeliveryEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliveryEventType[] | ListEnumEnumDeliveryEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliveryEventType[] | ListEnumEnumDeliveryEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliveryEventTypeFilter<$PrismaModel> | $Enums.EnumDeliveryEventType
  }

  export type NestedEnumEnumEventActorFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumEventActor | EnumEnumEventActorFieldRefInput<$PrismaModel>
    in?: $Enums.EnumEventActor[] | ListEnumEnumEventActorFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumEventActor[] | ListEnumEnumEventActorFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumEventActorFilter<$PrismaModel> | $Enums.EnumEventActor
  }

  export type NestedEnumEnumDeliveryEventSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryEventSource | EnumEnumDeliveryEventSourceFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliveryEventSource[] | ListEnumEnumDeliveryEventSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliveryEventSource[] | ListEnumEnumDeliveryEventSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliveryEventSourceFilter<$PrismaModel> | $Enums.EnumDeliveryEventSource
  }

  export type NestedEnumEnumDeliveryStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryStatus | EnumEnumDeliveryStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumDeliveryStatusNullableFilter<$PrismaModel> | $Enums.EnumDeliveryStatus | null
  }

  export type NestedEnumEnumDeliveryEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryEventType | EnumEnumDeliveryEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliveryEventType[] | ListEnumEnumDeliveryEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliveryEventType[] | ListEnumEnumDeliveryEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliveryEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EnumDeliveryEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumDeliveryEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEnumDeliveryEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumEnumEventActorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumEventActor | EnumEnumEventActorFieldRefInput<$PrismaModel>
    in?: $Enums.EnumEventActor[] | ListEnumEnumEventActorFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumEventActor[] | ListEnumEnumEventActorFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumEventActorWithAggregatesFilter<$PrismaModel> | $Enums.EnumEventActor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumEventActorFilter<$PrismaModel>
    _max?: NestedEnumEnumEventActorFilter<$PrismaModel>
  }

  export type NestedEnumEnumDeliveryEventSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryEventSource | EnumEnumDeliveryEventSourceFieldRefInput<$PrismaModel>
    in?: $Enums.EnumDeliveryEventSource[] | ListEnumEnumDeliveryEventSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumDeliveryEventSource[] | ListEnumEnumDeliveryEventSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumDeliveryEventSourceWithAggregatesFilter<$PrismaModel> | $Enums.EnumDeliveryEventSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumDeliveryEventSourceFilter<$PrismaModel>
    _max?: NestedEnumEnumDeliveryEventSourceFilter<$PrismaModel>
  }

  export type NestedEnumEnumDeliveryStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumDeliveryStatus | EnumEnumDeliveryStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumDeliveryStatus[] | ListEnumEnumDeliveryStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumDeliveryStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnumDeliveryStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnumDeliveryStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumEnumDeliveryStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumEnumLocationNoteActorFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumLocationNoteActor | EnumEnumLocationNoteActorFieldRefInput<$PrismaModel>
    in?: $Enums.EnumLocationNoteActor[] | ListEnumEnumLocationNoteActorFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumLocationNoteActor[] | ListEnumEnumLocationNoteActorFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumLocationNoteActorFilter<$PrismaModel> | $Enums.EnumLocationNoteActor
  }

  export type NestedEnumEnumLocationNoteActorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumLocationNoteActor | EnumEnumLocationNoteActorFieldRefInput<$PrismaModel>
    in?: $Enums.EnumLocationNoteActor[] | ListEnumEnumLocationNoteActorFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumLocationNoteActor[] | ListEnumEnumLocationNoteActorFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumLocationNoteActorWithAggregatesFilter<$PrismaModel> | $Enums.EnumLocationNoteActor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumLocationNoteActorFilter<$PrismaModel>
    _max?: NestedEnumEnumLocationNoteActorFilter<$PrismaModel>
  }

  export type NestedEnumEnumLocationNoteReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumLocationNoteReactionType | EnumEnumLocationNoteReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EnumLocationNoteReactionType[] | ListEnumEnumLocationNoteReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumLocationNoteReactionType[] | ListEnumEnumLocationNoteReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumLocationNoteReactionTypeFilter<$PrismaModel> | $Enums.EnumLocationNoteReactionType
  }

  export type NestedEnumEnumLocationNoteReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumLocationNoteReactionType | EnumEnumLocationNoteReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EnumLocationNoteReactionType[] | ListEnumEnumLocationNoteReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumLocationNoteReactionType[] | ListEnumEnumLocationNoteReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumLocationNoteReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.EnumLocationNoteReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumLocationNoteReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumEnumLocationNoteReactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumEnumSettingVehicleTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumSettingVehicleType | EnumEnumSettingVehicleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumSettingVehicleType[] | ListEnumEnumSettingVehicleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumSettingVehicleType[] | ListEnumEnumSettingVehicleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumSettingVehicleTypeNullableFilter<$PrismaModel> | $Enums.EnumSettingVehicleType | null
  }

  export type NestedEnumEnumSettingDeliverySpeedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumSettingDeliverySpeed | EnumEnumSettingDeliverySpeedFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumSettingDeliverySpeed[] | ListEnumEnumSettingDeliverySpeedFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumSettingDeliverySpeed[] | ListEnumEnumSettingDeliverySpeedFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumSettingDeliverySpeedNullableFilter<$PrismaModel> | $Enums.EnumSettingDeliverySpeed | null
  }

  export type NestedEnumEnumSettingVehicleTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumSettingVehicleType | EnumEnumSettingVehicleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumSettingVehicleType[] | ListEnumEnumSettingVehicleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumSettingVehicleType[] | ListEnumEnumSettingVehicleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumSettingVehicleTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnumSettingVehicleType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnumSettingVehicleTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEnumSettingVehicleTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumEnumSettingDeliverySpeedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumSettingDeliverySpeed | EnumEnumSettingDeliverySpeedFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumSettingDeliverySpeed[] | ListEnumEnumSettingDeliverySpeedFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumSettingDeliverySpeed[] | ListEnumEnumSettingDeliverySpeedFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumSettingDeliverySpeedNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnumSettingDeliverySpeed | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnumSettingDeliverySpeedNullableFilter<$PrismaModel>
    _max?: NestedEnumEnumSettingDeliverySpeedNullableFilter<$PrismaModel>
  }

  export type NestedEnumEnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumPayoutStatus | EnumEnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumPayoutStatus[] | ListEnumEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumPayoutStatus[] | ListEnumEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumPayoutStatusFilter<$PrismaModel> | $Enums.EnumPayoutStatus
  }

  export type NestedEnumEnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumPayoutStatus | EnumEnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumPayoutStatus[] | ListEnumEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumPayoutStatus[] | ListEnumEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnumPayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumEnumPayoutStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumPaymentStatus | EnumEnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumPaymentStatus[] | ListEnumEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumPaymentStatus[] | ListEnumEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumPaymentStatusFilter<$PrismaModel> | $Enums.EnumPaymentStatus
  }

  export type NestedEnumEnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumPaymentProvider | EnumEnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.EnumPaymentProvider[] | ListEnumEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumPaymentProvider[] | ListEnumEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumPaymentProviderFilter<$PrismaModel> | $Enums.EnumPaymentProvider
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumPaymentStatus | EnumEnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnumPaymentStatus[] | ListEnumEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumPaymentStatus[] | ListEnumEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnumPaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumEnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumPaymentProvider | EnumEnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.EnumPaymentProvider[] | ListEnumEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnumPaymentProvider[] | ListEnumEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.EnumPaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumEnumPaymentProviderFilter<$PrismaModel>
  }

  export type NestedEnumEnumRefundReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumRefundReason | EnumEnumRefundReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumRefundReason[] | ListEnumEnumRefundReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumRefundReason[] | ListEnumEnumRefundReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumRefundReasonNullableFilter<$PrismaModel> | $Enums.EnumRefundReason | null
  }

  export type NestedEnumEnumRefundStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumRefundStatus | EnumEnumRefundStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumRefundStatus[] | ListEnumEnumRefundStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumRefundStatus[] | ListEnumEnumRefundStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumRefundStatusNullableFilter<$PrismaModel> | $Enums.EnumRefundStatus | null
  }

  export type NestedEnumEnumRefundReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumRefundReason | EnumEnumRefundReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumRefundReason[] | ListEnumEnumRefundReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumRefundReason[] | ListEnumEnumRefundReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumRefundReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnumRefundReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnumRefundReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumEnumRefundReasonNullableFilter<$PrismaModel>
  }

  export type NestedEnumEnumRefundStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnumRefundStatus | EnumEnumRefundStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnumRefundStatus[] | ListEnumEnumRefundStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnumRefundStatus[] | ListEnumEnumRefundStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnumRefundStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnumRefundStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnumRefundStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumEnumRefundStatusNullableFilter<$PrismaModel>
  }

  export type CourierCreateWithoutUserInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    comments?: CommentCreateNestedManyWithoutCouriersInput
    earnings?: EarningCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    settings?: CourierSettingCreateNestedOneWithoutCouriersInput
    Payout?: PayoutCreateNestedManyWithoutCourierInput
    Transfer?: TransferCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionCreateNestedManyWithoutCouriersInput
  }

  export type CourierUncheckedCreateWithoutUserInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedCreateNestedManyWithoutCouriersInput
    earnings?: EarningUncheckedCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    settings?: CourierSettingUncheckedCreateNestedOneWithoutCouriersInput
    Payout?: PayoutUncheckedCreateNestedManyWithoutCourierInput
    Transfer?: TransferUncheckedCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteUncheckedCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionUncheckedCreateNestedManyWithoutCouriersInput
  }

  export type CourierCreateOrConnectWithoutUserInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutUserInput, CourierUncheckedCreateWithoutUserInput>
  }

  export type PartnerCreateWithoutUserInput = {
    id?: string
    name: string
    logo?: string | null
    phoneNumber?: string | null
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: DeliveryCreateNestedManyWithoutPartnerInput
    deliveryQuotes?: DeliveryQuoteCreateNestedManyWithoutPartnersInput
  }

  export type PartnerUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    logo?: string | null
    phoneNumber?: string | null
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutPartnerInput
    deliveryQuotes?: DeliveryQuoteUncheckedCreateNestedManyWithoutPartnersInput
  }

  export type PartnerCreateOrConnectWithoutUserInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutUserInput, PartnerUncheckedCreateWithoutUserInput>
  }

  export type CourierUpsertWithoutUserInput = {
    update: XOR<CourierUpdateWithoutUserInput, CourierUncheckedUpdateWithoutUserInput>
    create: XOR<CourierCreateWithoutUserInput, CourierUncheckedCreateWithoutUserInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutUserInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutUserInput, CourierUncheckedUpdateWithoutUserInput>
  }

  export type CourierUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    comments?: CommentUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUpdateManyWithoutCouriersNestedInput
  }

  export type CourierUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUncheckedUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUncheckedUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUncheckedUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUncheckedUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUncheckedUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUncheckedUpdateManyWithoutCouriersNestedInput
  }

  export type PartnerUpsertWithoutUserInput = {
    update: XOR<PartnerUpdateWithoutUserInput, PartnerUncheckedUpdateWithoutUserInput>
    create: XOR<PartnerCreateWithoutUserInput, PartnerUncheckedCreateWithoutUserInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutUserInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutUserInput, PartnerUncheckedUpdateWithoutUserInput>
  }

  export type PartnerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: DeliveryUpdateManyWithoutPartnerNestedInput
    deliveryQuotes?: DeliveryQuoteUpdateManyWithoutPartnersNestedInput
  }

  export type PartnerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: DeliveryUncheckedUpdateManyWithoutPartnerNestedInput
    deliveryQuotes?: DeliveryQuoteUncheckedUpdateManyWithoutPartnersNestedInput
  }

  export type CourierCreateWithoutCommentsInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    user: UserCreateNestedOneWithoutCourierInput
    earnings?: EarningCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    settings?: CourierSettingCreateNestedOneWithoutCouriersInput
    Payout?: PayoutCreateNestedManyWithoutCourierInput
    Transfer?: TransferCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionCreateNestedManyWithoutCouriersInput
  }

  export type CourierUncheckedCreateWithoutCommentsInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    earnings?: EarningUncheckedCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    settings?: CourierSettingUncheckedCreateNestedOneWithoutCouriersInput
    Payout?: PayoutUncheckedCreateNestedManyWithoutCourierInput
    Transfer?: TransferUncheckedCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteUncheckedCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionUncheckedCreateNestedManyWithoutCouriersInput
  }

  export type CourierCreateOrConnectWithoutCommentsInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutCommentsInput, CourierUncheckedCreateWithoutCommentsInput>
  }

  export type CourierUpsertWithoutCommentsInput = {
    update: XOR<CourierUpdateWithoutCommentsInput, CourierUncheckedUpdateWithoutCommentsInput>
    create: XOR<CourierCreateWithoutCommentsInput, CourierUncheckedCreateWithoutCommentsInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutCommentsInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutCommentsInput, CourierUncheckedUpdateWithoutCommentsInput>
  }

  export type CourierUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    earnings?: EarningUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUpdateManyWithoutCouriersNestedInput
  }

  export type CourierUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    earnings?: EarningUncheckedUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUncheckedUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUncheckedUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUncheckedUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUncheckedUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUncheckedUpdateManyWithoutCouriersNestedInput
  }

  export type UserCreateWithoutCourierInput = {
    id?: string
    email?: string | null
    password?: string | null
    role?: UserCreateroleInput | $Enums.EnumUserRole[]
    username?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partner?: PartnerCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCourierInput = {
    id?: string
    email?: string | null
    password?: string | null
    role?: UserCreateroleInput | $Enums.EnumUserRole[]
    username?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partner?: PartnerUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCourierInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourierInput, UserUncheckedCreateWithoutCourierInput>
  }

  export type CommentCreateWithoutCouriersInput = {
    id?: string
    text?: string | null
    likes?: number | null
    likers?: CommentCreatelikersInput | string[]
    commentableId: string
    commentableType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUncheckedCreateWithoutCouriersInput = {
    id?: string
    text?: string | null
    likes?: number | null
    likers?: CommentCreatelikersInput | string[]
    commentableId: string
    commentableType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutCouriersInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCouriersInput, CommentUncheckedCreateWithoutCouriersInput>
  }

  export type CommentCreateManyCouriersInputEnvelope = {
    data: CommentCreateManyCouriersInput | CommentCreateManyCouriersInput[]
    skipDuplicates?: boolean
  }

  export type EarningCreateWithoutCouriersInput = {
    id?: string
    total: number
    pending: number
    received: number
    payoutMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EarningUncheckedCreateWithoutCouriersInput = {
    id?: string
    total: number
    pending: number
    received: number
    payoutMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EarningCreateOrConnectWithoutCouriersInput = {
    where: EarningWhereUniqueInput
    create: XOR<EarningCreateWithoutCouriersInput, EarningUncheckedCreateWithoutCouriersInput>
  }

  export type EarningCreateManyCouriersInputEnvelope = {
    data: EarningCreateManyCouriersInput | EarningCreateManyCouriersInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryCreateWithoutCourierInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocation?: LocationCreateNestedOneWithoutPickupDeliveryInput
    dropoffLocation?: LocationCreateNestedOneWithoutDropoffDeliveryInput
    partner?: PartnerCreateNestedOneWithoutDeliveriesInput
    delivery: DeliveryQuoteCreateNestedOneWithoutDeliveryInput
    payment?: PaymentCreateNestedManyWithoutDeliveryInput
    deliveryEvent?: DeliveryEventCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutCourierInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId: string
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    dropoffLocationId: string
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    partnerId?: string | null
    deliveryQuoteId: string
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedManyWithoutDeliveryInput
    deliveryEvent?: DeliveryEventUncheckedCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutCourierInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutCourierInput, DeliveryUncheckedCreateWithoutCourierInput>
  }

  export type DeliveryCreateManyCourierInputEnvelope = {
    data: DeliveryCreateManyCourierInput | DeliveryCreateManyCourierInput[]
    skipDuplicates?: boolean
  }

  export type CourierSettingCreateWithoutCouriersInput = {
    id?: string
    vehicleType?: $Enums.EnumSettingVehicleType | null
    preferredAreas?: CourierSettingCreatepreferredAreasInput | string[]
    shiftAvailability?: NullableJsonNullValueInput | InputJsonValue
    deliveryPreferences?: CourierSettingCreatedeliveryPreferencesInput | string[]
    foodPreferences?: CourierSettingCreatefoodPreferencesInput | string[]
    earningGoals?: NullableJsonNullValueInput | InputJsonValue
    deliverySpeed?: $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes?: CourierSettingCreaterestaurantTypesInput | string[]
    cuisineTypes?: CourierSettingCreatecuisineTypesInput | string[]
    preferredRestaurantPartners?: CourierSettingCreatepreferredRestaurantPartnersInput | string[]
    dietaryRestrictions?: CourierSettingCreatedietaryRestrictionsInput | string[]
    payRate?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourierSettingUncheckedCreateWithoutCouriersInput = {
    id?: string
    vehicleType?: $Enums.EnumSettingVehicleType | null
    preferredAreas?: CourierSettingCreatepreferredAreasInput | string[]
    shiftAvailability?: NullableJsonNullValueInput | InputJsonValue
    deliveryPreferences?: CourierSettingCreatedeliveryPreferencesInput | string[]
    foodPreferences?: CourierSettingCreatefoodPreferencesInput | string[]
    earningGoals?: NullableJsonNullValueInput | InputJsonValue
    deliverySpeed?: $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes?: CourierSettingCreaterestaurantTypesInput | string[]
    cuisineTypes?: CourierSettingCreatecuisineTypesInput | string[]
    preferredRestaurantPartners?: CourierSettingCreatepreferredRestaurantPartnersInput | string[]
    dietaryRestrictions?: CourierSettingCreatedietaryRestrictionsInput | string[]
    payRate?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourierSettingCreateOrConnectWithoutCouriersInput = {
    where: CourierSettingWhereUniqueInput
    create: XOR<CourierSettingCreateWithoutCouriersInput, CourierSettingUncheckedCreateWithoutCouriersInput>
  }

  export type PayoutCreateWithoutCourierInput = {
    id?: string
    amount: number
    arrivalDate: Date | string
    description?: string | null
    statementDescriptor?: string | null
    status: $Enums.EnumPayoutStatus
    payment: PaymentCreateNestedOneWithoutPayoutsInput
  }

  export type PayoutUncheckedCreateWithoutCourierInput = {
    id?: string
    amount: number
    arrivalDate: Date | string
    description?: string | null
    statementDescriptor?: string | null
    status: $Enums.EnumPayoutStatus
    paymentId: string
  }

  export type PayoutCreateOrConnectWithoutCourierInput = {
    where: PayoutWhereUniqueInput
    create: XOR<PayoutCreateWithoutCourierInput, PayoutUncheckedCreateWithoutCourierInput>
  }

  export type PayoutCreateManyCourierInputEnvelope = {
    data: PayoutCreateManyCourierInput | PayoutCreateManyCourierInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutCourierInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transferId: string
    amount: number
    amountReversed: number
    destination: string
    destinationPayment?: string | null
    reversed?: boolean
    payment?: PaymentCreateNestedOneWithoutTransfersInput
  }

  export type TransferUncheckedCreateWithoutCourierInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transferId: string
    amount: number
    amountReversed: number
    destination: string
    destinationPayment?: string | null
    reversed?: boolean
    paymentId?: string | null
  }

  export type TransferCreateOrConnectWithoutCourierInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutCourierInput, TransferUncheckedCreateWithoutCourierInput>
  }

  export type TransferCreateManyCourierInputEnvelope = {
    data: TransferCreateManyCourierInput | TransferCreateManyCourierInput[]
    skipDuplicates?: boolean
  }

  export type LocationNoteCreateWithoutCouriersInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor: $Enums.EnumLocationNoteActor
    locations?: LocationCreateNestedOneWithoutLocationNotesInput
    delivery?: DeliveryCreateNestedOneWithoutLocationNoteInput
    noteReactions?: LocationNoteReactionCreateNestedManyWithoutLocationNoteInput
  }

  export type LocationNoteUncheckedCreateWithoutCouriersInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor: $Enums.EnumLocationNoteActor
    locationId?: string | null
    deliveryId?: string | null
    noteReactions?: LocationNoteReactionUncheckedCreateNestedManyWithoutLocationNoteInput
  }

  export type LocationNoteCreateOrConnectWithoutCouriersInput = {
    where: LocationNoteWhereUniqueInput
    create: XOR<LocationNoteCreateWithoutCouriersInput, LocationNoteUncheckedCreateWithoutCouriersInput>
  }

  export type LocationNoteCreateManyCouriersInputEnvelope = {
    data: LocationNoteCreateManyCouriersInput | LocationNoteCreateManyCouriersInput[]
    skipDuplicates?: boolean
  }

  export type LocationNoteReactionCreateWithoutCouriersInput = {
    id?: string
    reaction: $Enums.EnumLocationNoteReactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNote: LocationNoteCreateNestedOneWithoutNoteReactionsInput
  }

  export type LocationNoteReactionUncheckedCreateWithoutCouriersInput = {
    id?: string
    reaction: $Enums.EnumLocationNoteReactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNoteId: string
  }

  export type LocationNoteReactionCreateOrConnectWithoutCouriersInput = {
    where: LocationNoteReactionWhereUniqueInput
    create: XOR<LocationNoteReactionCreateWithoutCouriersInput, LocationNoteReactionUncheckedCreateWithoutCouriersInput>
  }

  export type LocationNoteReactionCreateManyCouriersInputEnvelope = {
    data: LocationNoteReactionCreateManyCouriersInput | LocationNoteReactionCreateManyCouriersInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCourierInput = {
    update: XOR<UserUpdateWithoutCourierInput, UserUncheckedUpdateWithoutCourierInput>
    create: XOR<UserCreateWithoutCourierInput, UserUncheckedCreateWithoutCourierInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCourierInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCourierInput, UserUncheckedUpdateWithoutCourierInput>
  }

  export type UserUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | $Enums.EnumUserRole[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | $Enums.EnumUserRole[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutCouriersInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutCouriersInput, CommentUncheckedUpdateWithoutCouriersInput>
    create: XOR<CommentCreateWithoutCouriersInput, CommentUncheckedCreateWithoutCouriersInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutCouriersInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutCouriersInput, CommentUncheckedUpdateWithoutCouriersInput>
  }

  export type CommentUpdateManyWithWhereWithoutCouriersInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCouriersInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    text?: StringNullableFilter<"Comment"> | string | null
    likes?: IntNullableFilter<"Comment"> | number | null
    likers?: StringNullableListFilter<"Comment">
    commentableId?: StringFilter<"Comment"> | string
    commentableType?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    courierId?: StringNullableFilter<"Comment"> | string | null
  }

  export type EarningUpsertWithWhereUniqueWithoutCouriersInput = {
    where: EarningWhereUniqueInput
    update: XOR<EarningUpdateWithoutCouriersInput, EarningUncheckedUpdateWithoutCouriersInput>
    create: XOR<EarningCreateWithoutCouriersInput, EarningUncheckedCreateWithoutCouriersInput>
  }

  export type EarningUpdateWithWhereUniqueWithoutCouriersInput = {
    where: EarningWhereUniqueInput
    data: XOR<EarningUpdateWithoutCouriersInput, EarningUncheckedUpdateWithoutCouriersInput>
  }

  export type EarningUpdateManyWithWhereWithoutCouriersInput = {
    where: EarningScalarWhereInput
    data: XOR<EarningUpdateManyMutationInput, EarningUncheckedUpdateManyWithoutCouriersInput>
  }

  export type EarningScalarWhereInput = {
    AND?: EarningScalarWhereInput | EarningScalarWhereInput[]
    OR?: EarningScalarWhereInput[]
    NOT?: EarningScalarWhereInput | EarningScalarWhereInput[]
    id?: StringFilter<"Earning"> | string
    total?: IntFilter<"Earning"> | number
    pending?: IntFilter<"Earning"> | number
    received?: IntFilter<"Earning"> | number
    payoutMethod?: StringNullableFilter<"Earning"> | string | null
    createdAt?: DateTimeFilter<"Earning"> | Date | string
    updatedAt?: DateTimeFilter<"Earning"> | Date | string
    courierId?: StringNullableFilter<"Earning"> | string | null
  }

  export type DeliveryUpsertWithWhereUniqueWithoutCourierInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutCourierInput, DeliveryUncheckedUpdateWithoutCourierInput>
    create: XOR<DeliveryCreateWithoutCourierInput, DeliveryUncheckedCreateWithoutCourierInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutCourierInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutCourierInput, DeliveryUncheckedUpdateWithoutCourierInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutCourierInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutCourierInput>
  }

  export type DeliveryScalarWhereInput = {
    AND?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
    OR?: DeliveryScalarWhereInput[]
    NOT?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
    id?: StringFilter<"Delivery"> | string
    pickupName?: StringFilter<"Delivery"> | string
    pickupPhoneNumber?: StringFilter<"Delivery"> | string
    pickupBusinessName?: StringFilter<"Delivery"> | string
    pickupNotes?: StringNullableFilter<"Delivery"> | string | null
    pickupVerification?: JsonNullableFilter<"Delivery">
    pickupLocationId?: StringFilter<"Delivery"> | string
    pickupReadyAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    pickupDeadlineAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    dropoffName?: StringFilter<"Delivery"> | string
    dropoffPhoneNumber?: StringFilter<"Delivery"> | string
    dropoffBusinessName?: StringNullableFilter<"Delivery"> | string | null
    dropoffNotes?: StringNullableFilter<"Delivery"> | string | null
    dropoffSellerNotes?: StringNullableFilter<"Delivery"> | string | null
    dropoffVerification?: JsonNullableFilter<"Delivery">
    dropoffReadyAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    dropoffEta?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    dropoffDeadlineAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFilter<"Delivery"> | $Enums.EnumDeliverableAction
    undeliverableAction?: EnumEnumUndeliverableActionNullableFilter<"Delivery"> | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: StringNullableFilter<"Delivery"> | string | null
    dropoffLocationId?: StringFilter<"Delivery"> | string
    deliveryTypes?: StringNullableListFilter<"Delivery">
    requiresDropoffSignature?: BoolFilter<"Delivery"> | boolean
    requiresId?: BoolFilter<"Delivery"> | boolean
    orderReference?: StringNullableFilter<"Delivery"> | string | null
    orderTotalValue?: IntNullableFilter<"Delivery"> | number | null
    orderItems?: JsonNullableFilter<"Delivery">
    status?: EnumEnumDeliveryStatusFilter<"Delivery"> | $Enums.EnumDeliveryStatus
    customerNotes?: StringNullableListFilter<"Delivery">
    currencyCode?: StringFilter<"Delivery"> | string
    pickupTypes?: StringNullableListFilter<"Delivery">
    imageType?: StringNullableFilter<"Delivery"> | string | null
    imageName?: StringNullableFilter<"Delivery"> | string | null
    imageData?: BytesNullableFilter<"Delivery"> | Buffer | null
    idempotencyKey?: StringNullableFilter<"Delivery"> | string | null
    externalStoreId?: StringNullableFilter<"Delivery"> | string | null
    returnVerification?: JsonNullableFilter<"Delivery">
    externalUserInfo?: JsonNullableFilter<"Delivery">
    externalId?: StringNullableFilter<"Delivery"> | string | null
    courierId?: StringNullableFilter<"Delivery"> | string | null
    partnerId?: StringNullableFilter<"Delivery"> | string | null
    deliveryQuoteId?: StringFilter<"Delivery"> | string
    totalCost?: FloatNullableFilter<"Delivery"> | number | null
    fee?: FloatNullableFilter<"Delivery"> | number | null
    feePercentage?: FloatNullableFilter<"Delivery"> | number | null
    pay?: FloatNullableFilter<"Delivery"> | number | null
    tips?: FloatFilter<"Delivery"> | number
    totalCompensation?: FloatNullableFilter<"Delivery"> | number | null
    rejectedByCouriers?: StringNullableListFilter<"Delivery">
    matchedCourierId?: StringNullableFilter<"Delivery"> | string | null
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
  }

  export type CourierSettingUpsertWithoutCouriersInput = {
    update: XOR<CourierSettingUpdateWithoutCouriersInput, CourierSettingUncheckedUpdateWithoutCouriersInput>
    create: XOR<CourierSettingCreateWithoutCouriersInput, CourierSettingUncheckedCreateWithoutCouriersInput>
    where?: CourierSettingWhereInput
  }

  export type CourierSettingUpdateToOneWithWhereWithoutCouriersInput = {
    where?: CourierSettingWhereInput
    data: XOR<CourierSettingUpdateWithoutCouriersInput, CourierSettingUncheckedUpdateWithoutCouriersInput>
  }

  export type CourierSettingUpdateWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableEnumEnumSettingVehicleTypeFieldUpdateOperationsInput | $Enums.EnumSettingVehicleType | null
    preferredAreas?: CourierSettingUpdatepreferredAreasInput | string[]
    shiftAvailability?: NullableJsonNullValueInput | InputJsonValue
    deliveryPreferences?: CourierSettingUpdatedeliveryPreferencesInput | string[]
    foodPreferences?: CourierSettingUpdatefoodPreferencesInput | string[]
    earningGoals?: NullableJsonNullValueInput | InputJsonValue
    deliverySpeed?: NullableEnumEnumSettingDeliverySpeedFieldUpdateOperationsInput | $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes?: CourierSettingUpdaterestaurantTypesInput | string[]
    cuisineTypes?: CourierSettingUpdatecuisineTypesInput | string[]
    preferredRestaurantPartners?: CourierSettingUpdatepreferredRestaurantPartnersInput | string[]
    dietaryRestrictions?: CourierSettingUpdatedietaryRestrictionsInput | string[]
    payRate?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourierSettingUncheckedUpdateWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableEnumEnumSettingVehicleTypeFieldUpdateOperationsInput | $Enums.EnumSettingVehicleType | null
    preferredAreas?: CourierSettingUpdatepreferredAreasInput | string[]
    shiftAvailability?: NullableJsonNullValueInput | InputJsonValue
    deliveryPreferences?: CourierSettingUpdatedeliveryPreferencesInput | string[]
    foodPreferences?: CourierSettingUpdatefoodPreferencesInput | string[]
    earningGoals?: NullableJsonNullValueInput | InputJsonValue
    deliverySpeed?: NullableEnumEnumSettingDeliverySpeedFieldUpdateOperationsInput | $Enums.EnumSettingDeliverySpeed | null
    restaurantTypes?: CourierSettingUpdaterestaurantTypesInput | string[]
    cuisineTypes?: CourierSettingUpdatecuisineTypesInput | string[]
    preferredRestaurantPartners?: CourierSettingUpdatepreferredRestaurantPartnersInput | string[]
    dietaryRestrictions?: CourierSettingUpdatedietaryRestrictionsInput | string[]
    payRate?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutUpsertWithWhereUniqueWithoutCourierInput = {
    where: PayoutWhereUniqueInput
    update: XOR<PayoutUpdateWithoutCourierInput, PayoutUncheckedUpdateWithoutCourierInput>
    create: XOR<PayoutCreateWithoutCourierInput, PayoutUncheckedCreateWithoutCourierInput>
  }

  export type PayoutUpdateWithWhereUniqueWithoutCourierInput = {
    where: PayoutWhereUniqueInput
    data: XOR<PayoutUpdateWithoutCourierInput, PayoutUncheckedUpdateWithoutCourierInput>
  }

  export type PayoutUpdateManyWithWhereWithoutCourierInput = {
    where: PayoutScalarWhereInput
    data: XOR<PayoutUpdateManyMutationInput, PayoutUncheckedUpdateManyWithoutCourierInput>
  }

  export type PayoutScalarWhereInput = {
    AND?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
    OR?: PayoutScalarWhereInput[]
    NOT?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
    id?: StringFilter<"Payout"> | string
    amount?: IntFilter<"Payout"> | number
    arrivalDate?: DateTimeFilter<"Payout"> | Date | string
    description?: StringNullableFilter<"Payout"> | string | null
    statementDescriptor?: StringNullableFilter<"Payout"> | string | null
    status?: EnumEnumPayoutStatusFilter<"Payout"> | $Enums.EnumPayoutStatus
    paymentId?: StringFilter<"Payout"> | string
    courierId?: StringNullableFilter<"Payout"> | string | null
  }

  export type TransferUpsertWithWhereUniqueWithoutCourierInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutCourierInput, TransferUncheckedUpdateWithoutCourierInput>
    create: XOR<TransferCreateWithoutCourierInput, TransferUncheckedCreateWithoutCourierInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutCourierInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutCourierInput, TransferUncheckedUpdateWithoutCourierInput>
  }

  export type TransferUpdateManyWithWhereWithoutCourierInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutCourierInput>
  }

  export type TransferScalarWhereInput = {
    AND?: TransferScalarWhereInput | TransferScalarWhereInput[]
    OR?: TransferScalarWhereInput[]
    NOT?: TransferScalarWhereInput | TransferScalarWhereInput[]
    id?: StringFilter<"Transfer"> | string
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    transferId?: StringFilter<"Transfer"> | string
    amount?: IntFilter<"Transfer"> | number
    amountReversed?: IntFilter<"Transfer"> | number
    destination?: StringFilter<"Transfer"> | string
    destinationPayment?: StringNullableFilter<"Transfer"> | string | null
    reversed?: BoolFilter<"Transfer"> | boolean
    paymentId?: StringNullableFilter<"Transfer"> | string | null
    courierId?: StringNullableFilter<"Transfer"> | string | null
  }

  export type LocationNoteUpsertWithWhereUniqueWithoutCouriersInput = {
    where: LocationNoteWhereUniqueInput
    update: XOR<LocationNoteUpdateWithoutCouriersInput, LocationNoteUncheckedUpdateWithoutCouriersInput>
    create: XOR<LocationNoteCreateWithoutCouriersInput, LocationNoteUncheckedCreateWithoutCouriersInput>
  }

  export type LocationNoteUpdateWithWhereUniqueWithoutCouriersInput = {
    where: LocationNoteWhereUniqueInput
    data: XOR<LocationNoteUpdateWithoutCouriersInput, LocationNoteUncheckedUpdateWithoutCouriersInput>
  }

  export type LocationNoteUpdateManyWithWhereWithoutCouriersInput = {
    where: LocationNoteScalarWhereInput
    data: XOR<LocationNoteUpdateManyMutationInput, LocationNoteUncheckedUpdateManyWithoutCouriersInput>
  }

  export type LocationNoteScalarWhereInput = {
    AND?: LocationNoteScalarWhereInput | LocationNoteScalarWhereInput[]
    OR?: LocationNoteScalarWhereInput[]
    NOT?: LocationNoteScalarWhereInput | LocationNoteScalarWhereInput[]
    id?: StringFilter<"LocationNote"> | string
    note?: StringNullableFilter<"LocationNote"> | string | null
    createdAt?: DateTimeFilter<"LocationNote"> | Date | string
    updatedAt?: DateTimeFilter<"LocationNote"> | Date | string
    actor?: EnumEnumLocationNoteActorFilter<"LocationNote"> | $Enums.EnumLocationNoteActor
    locationId?: StringNullableFilter<"LocationNote"> | string | null
    deliveryId?: StringNullableFilter<"LocationNote"> | string | null
    courierId?: StringNullableFilter<"LocationNote"> | string | null
  }

  export type LocationNoteReactionUpsertWithWhereUniqueWithoutCouriersInput = {
    where: LocationNoteReactionWhereUniqueInput
    update: XOR<LocationNoteReactionUpdateWithoutCouriersInput, LocationNoteReactionUncheckedUpdateWithoutCouriersInput>
    create: XOR<LocationNoteReactionCreateWithoutCouriersInput, LocationNoteReactionUncheckedCreateWithoutCouriersInput>
  }

  export type LocationNoteReactionUpdateWithWhereUniqueWithoutCouriersInput = {
    where: LocationNoteReactionWhereUniqueInput
    data: XOR<LocationNoteReactionUpdateWithoutCouriersInput, LocationNoteReactionUncheckedUpdateWithoutCouriersInput>
  }

  export type LocationNoteReactionUpdateManyWithWhereWithoutCouriersInput = {
    where: LocationNoteReactionScalarWhereInput
    data: XOR<LocationNoteReactionUpdateManyMutationInput, LocationNoteReactionUncheckedUpdateManyWithoutCouriersInput>
  }

  export type LocationNoteReactionScalarWhereInput = {
    AND?: LocationNoteReactionScalarWhereInput | LocationNoteReactionScalarWhereInput[]
    OR?: LocationNoteReactionScalarWhereInput[]
    NOT?: LocationNoteReactionScalarWhereInput | LocationNoteReactionScalarWhereInput[]
    id?: StringFilter<"LocationNoteReaction"> | string
    reaction?: EnumEnumLocationNoteReactionTypeFilter<"LocationNoteReaction"> | $Enums.EnumLocationNoteReactionType
    createdAt?: DateTimeFilter<"LocationNoteReaction"> | Date | string
    updatedAt?: DateTimeFilter<"LocationNoteReaction"> | Date | string
    locationNoteId?: StringFilter<"LocationNoteReaction"> | string
    courierId?: StringFilter<"LocationNoteReaction"> | string
  }

  export type CourierCreateWithoutEarningsInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    user: UserCreateNestedOneWithoutCourierInput
    comments?: CommentCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    settings?: CourierSettingCreateNestedOneWithoutCouriersInput
    Payout?: PayoutCreateNestedManyWithoutCourierInput
    Transfer?: TransferCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionCreateNestedManyWithoutCouriersInput
  }

  export type CourierUncheckedCreateWithoutEarningsInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    settings?: CourierSettingUncheckedCreateNestedOneWithoutCouriersInput
    Payout?: PayoutUncheckedCreateNestedManyWithoutCourierInput
    Transfer?: TransferUncheckedCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteUncheckedCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionUncheckedCreateNestedManyWithoutCouriersInput
  }

  export type CourierCreateOrConnectWithoutEarningsInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutEarningsInput, CourierUncheckedCreateWithoutEarningsInput>
  }

  export type CourierUpsertWithoutEarningsInput = {
    update: XOR<CourierUpdateWithoutEarningsInput, CourierUncheckedUpdateWithoutEarningsInput>
    create: XOR<CourierCreateWithoutEarningsInput, CourierUncheckedCreateWithoutEarningsInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutEarningsInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutEarningsInput, CourierUncheckedUpdateWithoutEarningsInput>
  }

  export type CourierUpdateWithoutEarningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    comments?: CommentUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUpdateManyWithoutCouriersNestedInput
  }

  export type CourierUncheckedUpdateWithoutEarningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUncheckedUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUncheckedUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUncheckedUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUncheckedUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUncheckedUpdateManyWithoutCouriersNestedInput
  }

  export type LocationNoteCreateWithoutLocationsInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor: $Enums.EnumLocationNoteActor
    delivery?: DeliveryCreateNestedOneWithoutLocationNoteInput
    couriers?: CourierCreateNestedOneWithoutLocationNotesInput
    noteReactions?: LocationNoteReactionCreateNestedManyWithoutLocationNoteInput
  }

  export type LocationNoteUncheckedCreateWithoutLocationsInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor: $Enums.EnumLocationNoteActor
    deliveryId?: string | null
    courierId?: string | null
    noteReactions?: LocationNoteReactionUncheckedCreateNestedManyWithoutLocationNoteInput
  }

  export type LocationNoteCreateOrConnectWithoutLocationsInput = {
    where: LocationNoteWhereUniqueInput
    create: XOR<LocationNoteCreateWithoutLocationsInput, LocationNoteUncheckedCreateWithoutLocationsInput>
  }

  export type LocationNoteCreateManyLocationsInputEnvelope = {
    data: LocationNoteCreateManyLocationsInput | LocationNoteCreateManyLocationsInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryCreateWithoutPickupLocationInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropoffLocation?: LocationCreateNestedOneWithoutDropoffDeliveryInput
    courier?: CourierCreateNestedOneWithoutDeliveriesInput
    partner?: PartnerCreateNestedOneWithoutDeliveriesInput
    delivery: DeliveryQuoteCreateNestedOneWithoutDeliveryInput
    payment?: PaymentCreateNestedManyWithoutDeliveryInput
    deliveryEvent?: DeliveryEventCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutPickupLocationInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    dropoffLocationId: string
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    courierId?: string | null
    partnerId?: string | null
    deliveryQuoteId: string
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedManyWithoutDeliveryInput
    deliveryEvent?: DeliveryEventUncheckedCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutPickupLocationInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutPickupLocationInput, DeliveryUncheckedCreateWithoutPickupLocationInput>
  }

  export type DeliveryCreateManyPickupLocationInputEnvelope = {
    data: DeliveryCreateManyPickupLocationInput | DeliveryCreateManyPickupLocationInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryCreateWithoutDropoffLocationInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocation?: LocationCreateNestedOneWithoutPickupDeliveryInput
    courier?: CourierCreateNestedOneWithoutDeliveriesInput
    partner?: PartnerCreateNestedOneWithoutDeliveriesInput
    delivery: DeliveryQuoteCreateNestedOneWithoutDeliveryInput
    payment?: PaymentCreateNestedManyWithoutDeliveryInput
    deliveryEvent?: DeliveryEventCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutDropoffLocationInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId: string
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    courierId?: string | null
    partnerId?: string | null
    deliveryQuoteId: string
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedManyWithoutDeliveryInput
    deliveryEvent?: DeliveryEventUncheckedCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutDropoffLocationInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutDropoffLocationInput, DeliveryUncheckedCreateWithoutDropoffLocationInput>
  }

  export type DeliveryCreateManyDropoffLocationInputEnvelope = {
    data: DeliveryCreateManyDropoffLocationInput | DeliveryCreateManyDropoffLocationInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryQuoteCreateWithoutPickupLocationInput = {
    id?: string
    quote?: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage?: number
    currency: string
    duration: number
    distance: number
    distanceUnit?: $Enums.EnumDistanceUnit
    pickupPhoneNumber?: string | null
    pickupName?: string | null
    dropoffPhoneNumber?: string | null
    dropoffName?: string | null
    expiresAt?: Date | string | null
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    orderTotalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryId?: string | null
    dropoffLocation: LocationCreateNestedOneWithoutDropoffDeliveryQuotesInput
    partners?: PartnerCreateNestedOneWithoutDeliveryQuotesInput
    Delivery?: DeliveryCreateNestedOneWithoutDeliveryInput
  }

  export type DeliveryQuoteUncheckedCreateWithoutPickupLocationInput = {
    id?: string
    quote?: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage?: number
    currency: string
    duration: number
    distance: number
    distanceUnit?: $Enums.EnumDistanceUnit
    pickupPhoneNumber?: string | null
    pickupName?: string | null
    dropoffPhoneNumber?: string | null
    dropoffName?: string | null
    expiresAt?: Date | string | null
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    orderTotalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dropoffLocationId: string
    partnerId?: string | null
    deliveryId?: string | null
    Delivery?: DeliveryUncheckedCreateNestedOneWithoutDeliveryInput
  }

  export type DeliveryQuoteCreateOrConnectWithoutPickupLocationInput = {
    where: DeliveryQuoteWhereUniqueInput
    create: XOR<DeliveryQuoteCreateWithoutPickupLocationInput, DeliveryQuoteUncheckedCreateWithoutPickupLocationInput>
  }

  export type DeliveryQuoteCreateManyPickupLocationInputEnvelope = {
    data: DeliveryQuoteCreateManyPickupLocationInput | DeliveryQuoteCreateManyPickupLocationInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryQuoteCreateWithoutDropoffLocationInput = {
    id?: string
    quote?: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage?: number
    currency: string
    duration: number
    distance: number
    distanceUnit?: $Enums.EnumDistanceUnit
    pickupPhoneNumber?: string | null
    pickupName?: string | null
    dropoffPhoneNumber?: string | null
    dropoffName?: string | null
    expiresAt?: Date | string | null
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    orderTotalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryId?: string | null
    pickupLocation: LocationCreateNestedOneWithoutPickupDeliveryQuotesInput
    partners?: PartnerCreateNestedOneWithoutDeliveryQuotesInput
    Delivery?: DeliveryCreateNestedOneWithoutDeliveryInput
  }

  export type DeliveryQuoteUncheckedCreateWithoutDropoffLocationInput = {
    id?: string
    quote?: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage?: number
    currency: string
    duration: number
    distance: number
    distanceUnit?: $Enums.EnumDistanceUnit
    pickupPhoneNumber?: string | null
    pickupName?: string | null
    dropoffPhoneNumber?: string | null
    dropoffName?: string | null
    expiresAt?: Date | string | null
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    orderTotalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocationId: string
    partnerId?: string | null
    deliveryId?: string | null
    Delivery?: DeliveryUncheckedCreateNestedOneWithoutDeliveryInput
  }

  export type DeliveryQuoteCreateOrConnectWithoutDropoffLocationInput = {
    where: DeliveryQuoteWhereUniqueInput
    create: XOR<DeliveryQuoteCreateWithoutDropoffLocationInput, DeliveryQuoteUncheckedCreateWithoutDropoffLocationInput>
  }

  export type DeliveryQuoteCreateManyDropoffLocationInputEnvelope = {
    data: DeliveryQuoteCreateManyDropoffLocationInput | DeliveryQuoteCreateManyDropoffLocationInput[]
    skipDuplicates?: boolean
  }

  export type LocationNoteUpsertWithWhereUniqueWithoutLocationsInput = {
    where: LocationNoteWhereUniqueInput
    update: XOR<LocationNoteUpdateWithoutLocationsInput, LocationNoteUncheckedUpdateWithoutLocationsInput>
    create: XOR<LocationNoteCreateWithoutLocationsInput, LocationNoteUncheckedCreateWithoutLocationsInput>
  }

  export type LocationNoteUpdateWithWhereUniqueWithoutLocationsInput = {
    where: LocationNoteWhereUniqueInput
    data: XOR<LocationNoteUpdateWithoutLocationsInput, LocationNoteUncheckedUpdateWithoutLocationsInput>
  }

  export type LocationNoteUpdateManyWithWhereWithoutLocationsInput = {
    where: LocationNoteScalarWhereInput
    data: XOR<LocationNoteUpdateManyMutationInput, LocationNoteUncheckedUpdateManyWithoutLocationsInput>
  }

  export type DeliveryUpsertWithWhereUniqueWithoutPickupLocationInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutPickupLocationInput, DeliveryUncheckedUpdateWithoutPickupLocationInput>
    create: XOR<DeliveryCreateWithoutPickupLocationInput, DeliveryUncheckedCreateWithoutPickupLocationInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutPickupLocationInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutPickupLocationInput, DeliveryUncheckedUpdateWithoutPickupLocationInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutPickupLocationInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutPickupLocationInput>
  }

  export type DeliveryUpsertWithWhereUniqueWithoutDropoffLocationInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutDropoffLocationInput, DeliveryUncheckedUpdateWithoutDropoffLocationInput>
    create: XOR<DeliveryCreateWithoutDropoffLocationInput, DeliveryUncheckedCreateWithoutDropoffLocationInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutDropoffLocationInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutDropoffLocationInput, DeliveryUncheckedUpdateWithoutDropoffLocationInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutDropoffLocationInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutDropoffLocationInput>
  }

  export type DeliveryQuoteUpsertWithWhereUniqueWithoutPickupLocationInput = {
    where: DeliveryQuoteWhereUniqueInput
    update: XOR<DeliveryQuoteUpdateWithoutPickupLocationInput, DeliveryQuoteUncheckedUpdateWithoutPickupLocationInput>
    create: XOR<DeliveryQuoteCreateWithoutPickupLocationInput, DeliveryQuoteUncheckedCreateWithoutPickupLocationInput>
  }

  export type DeliveryQuoteUpdateWithWhereUniqueWithoutPickupLocationInput = {
    where: DeliveryQuoteWhereUniqueInput
    data: XOR<DeliveryQuoteUpdateWithoutPickupLocationInput, DeliveryQuoteUncheckedUpdateWithoutPickupLocationInput>
  }

  export type DeliveryQuoteUpdateManyWithWhereWithoutPickupLocationInput = {
    where: DeliveryQuoteScalarWhereInput
    data: XOR<DeliveryQuoteUpdateManyMutationInput, DeliveryQuoteUncheckedUpdateManyWithoutPickupLocationInput>
  }

  export type DeliveryQuoteScalarWhereInput = {
    AND?: DeliveryQuoteScalarWhereInput | DeliveryQuoteScalarWhereInput[]
    OR?: DeliveryQuoteScalarWhereInput[]
    NOT?: DeliveryQuoteScalarWhereInput | DeliveryQuoteScalarWhereInput[]
    id?: StringFilter<"DeliveryQuote"> | string
    quote?: FloatNullableFilter<"DeliveryQuote"> | number | null
    quoteRangeFrom?: FloatFilter<"DeliveryQuote"> | number
    quoteRangeTo?: FloatFilter<"DeliveryQuote"> | number
    feePercentage?: FloatFilter<"DeliveryQuote"> | number
    currency?: StringFilter<"DeliveryQuote"> | string
    duration?: IntFilter<"DeliveryQuote"> | number
    distance?: FloatFilter<"DeliveryQuote"> | number
    distanceUnit?: EnumEnumDistanceUnitFilter<"DeliveryQuote"> | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: StringNullableFilter<"DeliveryQuote"> | string | null
    pickupName?: StringNullableFilter<"DeliveryQuote"> | string | null
    dropoffPhoneNumber?: StringNullableFilter<"DeliveryQuote"> | string | null
    dropoffName?: StringNullableFilter<"DeliveryQuote"> | string | null
    expiresAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    pickupReadyAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    pickupDeadlineAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    dropoffReadyAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    dropoffEta?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    dropoffDeadlineAt?: DateTimeNullableFilter<"DeliveryQuote"> | Date | string | null
    orderTotalValue?: FloatFilter<"DeliveryQuote"> | number
    createdAt?: DateTimeFilter<"DeliveryQuote"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryQuote"> | Date | string
    pickupLocationId?: StringFilter<"DeliveryQuote"> | string
    dropoffLocationId?: StringFilter<"DeliveryQuote"> | string
    partnerId?: StringNullableFilter<"DeliveryQuote"> | string | null
    deliveryId?: StringNullableFilter<"DeliveryQuote"> | string | null
  }

  export type DeliveryQuoteUpsertWithWhereUniqueWithoutDropoffLocationInput = {
    where: DeliveryQuoteWhereUniqueInput
    update: XOR<DeliveryQuoteUpdateWithoutDropoffLocationInput, DeliveryQuoteUncheckedUpdateWithoutDropoffLocationInput>
    create: XOR<DeliveryQuoteCreateWithoutDropoffLocationInput, DeliveryQuoteUncheckedCreateWithoutDropoffLocationInput>
  }

  export type DeliveryQuoteUpdateWithWhereUniqueWithoutDropoffLocationInput = {
    where: DeliveryQuoteWhereUniqueInput
    data: XOR<DeliveryQuoteUpdateWithoutDropoffLocationInput, DeliveryQuoteUncheckedUpdateWithoutDropoffLocationInput>
  }

  export type DeliveryQuoteUpdateManyWithWhereWithoutDropoffLocationInput = {
    where: DeliveryQuoteScalarWhereInput
    data: XOR<DeliveryQuoteUpdateManyMutationInput, DeliveryQuoteUncheckedUpdateManyWithoutDropoffLocationInput>
  }

  export type DeliveryCreateWithoutPartnerInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocation?: LocationCreateNestedOneWithoutPickupDeliveryInput
    dropoffLocation?: LocationCreateNestedOneWithoutDropoffDeliveryInput
    courier?: CourierCreateNestedOneWithoutDeliveriesInput
    delivery: DeliveryQuoteCreateNestedOneWithoutDeliveryInput
    payment?: PaymentCreateNestedManyWithoutDeliveryInput
    deliveryEvent?: DeliveryEventCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutPartnerInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId: string
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    dropoffLocationId: string
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    courierId?: string | null
    deliveryQuoteId: string
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedManyWithoutDeliveryInput
    deliveryEvent?: DeliveryEventUncheckedCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutPartnerInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutPartnerInput, DeliveryUncheckedCreateWithoutPartnerInput>
  }

  export type DeliveryCreateManyPartnerInputEnvelope = {
    data: DeliveryCreateManyPartnerInput | DeliveryCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryQuoteCreateWithoutPartnersInput = {
    id?: string
    quote?: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage?: number
    currency: string
    duration: number
    distance: number
    distanceUnit?: $Enums.EnumDistanceUnit
    pickupPhoneNumber?: string | null
    pickupName?: string | null
    dropoffPhoneNumber?: string | null
    dropoffName?: string | null
    expiresAt?: Date | string | null
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    orderTotalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryId?: string | null
    pickupLocation: LocationCreateNestedOneWithoutPickupDeliveryQuotesInput
    dropoffLocation: LocationCreateNestedOneWithoutDropoffDeliveryQuotesInput
    Delivery?: DeliveryCreateNestedOneWithoutDeliveryInput
  }

  export type DeliveryQuoteUncheckedCreateWithoutPartnersInput = {
    id?: string
    quote?: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage?: number
    currency: string
    duration: number
    distance: number
    distanceUnit?: $Enums.EnumDistanceUnit
    pickupPhoneNumber?: string | null
    pickupName?: string | null
    dropoffPhoneNumber?: string | null
    dropoffName?: string | null
    expiresAt?: Date | string | null
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    orderTotalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocationId: string
    dropoffLocationId: string
    deliveryId?: string | null
    Delivery?: DeliveryUncheckedCreateNestedOneWithoutDeliveryInput
  }

  export type DeliveryQuoteCreateOrConnectWithoutPartnersInput = {
    where: DeliveryQuoteWhereUniqueInput
    create: XOR<DeliveryQuoteCreateWithoutPartnersInput, DeliveryQuoteUncheckedCreateWithoutPartnersInput>
  }

  export type DeliveryQuoteCreateManyPartnersInputEnvelope = {
    data: DeliveryQuoteCreateManyPartnersInput | DeliveryQuoteCreateManyPartnersInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPartnerInput = {
    id?: string
    email?: string | null
    password?: string | null
    role?: UserCreateroleInput | $Enums.EnumUserRole[]
    username?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courier?: CourierCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPartnerInput = {
    id?: string
    email?: string | null
    password?: string | null
    role?: UserCreateroleInput | $Enums.EnumUserRole[]
    username?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courier?: CourierUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPartnerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPartnerInput, UserUncheckedCreateWithoutPartnerInput>
  }

  export type DeliveryUpsertWithWhereUniqueWithoutPartnerInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutPartnerInput, DeliveryUncheckedUpdateWithoutPartnerInput>
    create: XOR<DeliveryCreateWithoutPartnerInput, DeliveryUncheckedCreateWithoutPartnerInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutPartnerInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutPartnerInput, DeliveryUncheckedUpdateWithoutPartnerInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutPartnerInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutPartnerInput>
  }

  export type DeliveryQuoteUpsertWithWhereUniqueWithoutPartnersInput = {
    where: DeliveryQuoteWhereUniqueInput
    update: XOR<DeliveryQuoteUpdateWithoutPartnersInput, DeliveryQuoteUncheckedUpdateWithoutPartnersInput>
    create: XOR<DeliveryQuoteCreateWithoutPartnersInput, DeliveryQuoteUncheckedCreateWithoutPartnersInput>
  }

  export type DeliveryQuoteUpdateWithWhereUniqueWithoutPartnersInput = {
    where: DeliveryQuoteWhereUniqueInput
    data: XOR<DeliveryQuoteUpdateWithoutPartnersInput, DeliveryQuoteUncheckedUpdateWithoutPartnersInput>
  }

  export type DeliveryQuoteUpdateManyWithWhereWithoutPartnersInput = {
    where: DeliveryQuoteScalarWhereInput
    data: XOR<DeliveryQuoteUpdateManyMutationInput, DeliveryQuoteUncheckedUpdateManyWithoutPartnersInput>
  }

  export type UserUpsertWithoutPartnerInput = {
    update: XOR<UserUpdateWithoutPartnerInput, UserUncheckedUpdateWithoutPartnerInput>
    create: XOR<UserCreateWithoutPartnerInput, UserUncheckedCreateWithoutPartnerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPartnerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPartnerInput, UserUncheckedUpdateWithoutPartnerInput>
  }

  export type UserUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | $Enums.EnumUserRole[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courier?: CourierUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: UserUpdateroleInput | $Enums.EnumUserRole[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courier?: CourierUncheckedUpdateOneWithoutUserNestedInput
  }

  export type LocationCreateWithoutPickupDeliveryQuotesInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    street?: string | null
    zipCode?: string | null
    countryCode?: $Enums.EnumCountryCode
    stateCode?: string | null
    houseNumber?: string | null
    longitude: number
    latitude: number
    formattedAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNotes?: LocationNoteCreateNestedManyWithoutLocationsInput
    pickupDelivery?: DeliveryCreateNestedManyWithoutPickupLocationInput
    dropoffDelivery?: DeliveryCreateNestedManyWithoutDropoffLocationInput
    dropoffDeliveryQuotes?: DeliveryQuoteCreateNestedManyWithoutDropoffLocationInput
  }

  export type LocationUncheckedCreateWithoutPickupDeliveryQuotesInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    street?: string | null
    zipCode?: string | null
    countryCode?: $Enums.EnumCountryCode
    stateCode?: string | null
    houseNumber?: string | null
    longitude: number
    latitude: number
    formattedAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNotes?: LocationNoteUncheckedCreateNestedManyWithoutLocationsInput
    pickupDelivery?: DeliveryUncheckedCreateNestedManyWithoutPickupLocationInput
    dropoffDelivery?: DeliveryUncheckedCreateNestedManyWithoutDropoffLocationInput
    dropoffDeliveryQuotes?: DeliveryQuoteUncheckedCreateNestedManyWithoutDropoffLocationInput
  }

  export type LocationCreateOrConnectWithoutPickupDeliveryQuotesInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutPickupDeliveryQuotesInput, LocationUncheckedCreateWithoutPickupDeliveryQuotesInput>
  }

  export type LocationCreateWithoutDropoffDeliveryQuotesInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    street?: string | null
    zipCode?: string | null
    countryCode?: $Enums.EnumCountryCode
    stateCode?: string | null
    houseNumber?: string | null
    longitude: number
    latitude: number
    formattedAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNotes?: LocationNoteCreateNestedManyWithoutLocationsInput
    pickupDelivery?: DeliveryCreateNestedManyWithoutPickupLocationInput
    dropoffDelivery?: DeliveryCreateNestedManyWithoutDropoffLocationInput
    pickupDeliveryQuotes?: DeliveryQuoteCreateNestedManyWithoutPickupLocationInput
  }

  export type LocationUncheckedCreateWithoutDropoffDeliveryQuotesInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    street?: string | null
    zipCode?: string | null
    countryCode?: $Enums.EnumCountryCode
    stateCode?: string | null
    houseNumber?: string | null
    longitude: number
    latitude: number
    formattedAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNotes?: LocationNoteUncheckedCreateNestedManyWithoutLocationsInput
    pickupDelivery?: DeliveryUncheckedCreateNestedManyWithoutPickupLocationInput
    dropoffDelivery?: DeliveryUncheckedCreateNestedManyWithoutDropoffLocationInput
    pickupDeliveryQuotes?: DeliveryQuoteUncheckedCreateNestedManyWithoutPickupLocationInput
  }

  export type LocationCreateOrConnectWithoutDropoffDeliveryQuotesInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutDropoffDeliveryQuotesInput, LocationUncheckedCreateWithoutDropoffDeliveryQuotesInput>
  }

  export type PartnerCreateWithoutDeliveryQuotesInput = {
    id?: string
    name: string
    logo?: string | null
    phoneNumber?: string | null
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: DeliveryCreateNestedManyWithoutPartnerInput
    user?: UserCreateNestedOneWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutDeliveryQuotesInput = {
    id?: string
    name: string
    logo?: string | null
    phoneNumber?: string | null
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutDeliveryQuotesInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutDeliveryQuotesInput, PartnerUncheckedCreateWithoutDeliveryQuotesInput>
  }

  export type DeliveryCreateWithoutDeliveryInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocation?: LocationCreateNestedOneWithoutPickupDeliveryInput
    dropoffLocation?: LocationCreateNestedOneWithoutDropoffDeliveryInput
    courier?: CourierCreateNestedOneWithoutDeliveriesInput
    partner?: PartnerCreateNestedOneWithoutDeliveriesInput
    payment?: PaymentCreateNestedManyWithoutDeliveryInput
    deliveryEvent?: DeliveryEventCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutDeliveryInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId: string
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    dropoffLocationId: string
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    courierId?: string | null
    partnerId?: string | null
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedManyWithoutDeliveryInput
    deliveryEvent?: DeliveryEventUncheckedCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutDeliveryInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutDeliveryInput, DeliveryUncheckedCreateWithoutDeliveryInput>
  }

  export type LocationUpsertWithoutPickupDeliveryQuotesInput = {
    update: XOR<LocationUpdateWithoutPickupDeliveryQuotesInput, LocationUncheckedUpdateWithoutPickupDeliveryQuotesInput>
    create: XOR<LocationCreateWithoutPickupDeliveryQuotesInput, LocationUncheckedCreateWithoutPickupDeliveryQuotesInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutPickupDeliveryQuotesInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutPickupDeliveryQuotesInput, LocationUncheckedUpdateWithoutPickupDeliveryQuotesInput>
  }

  export type LocationUpdateWithoutPickupDeliveryQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: EnumEnumCountryCodeFieldUpdateOperationsInput | $Enums.EnumCountryCode
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    formattedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNotes?: LocationNoteUpdateManyWithoutLocationsNestedInput
    pickupDelivery?: DeliveryUpdateManyWithoutPickupLocationNestedInput
    dropoffDelivery?: DeliveryUpdateManyWithoutDropoffLocationNestedInput
    dropoffDeliveryQuotes?: DeliveryQuoteUpdateManyWithoutDropoffLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutPickupDeliveryQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: EnumEnumCountryCodeFieldUpdateOperationsInput | $Enums.EnumCountryCode
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    formattedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNotes?: LocationNoteUncheckedUpdateManyWithoutLocationsNestedInput
    pickupDelivery?: DeliveryUncheckedUpdateManyWithoutPickupLocationNestedInput
    dropoffDelivery?: DeliveryUncheckedUpdateManyWithoutDropoffLocationNestedInput
    dropoffDeliveryQuotes?: DeliveryQuoteUncheckedUpdateManyWithoutDropoffLocationNestedInput
  }

  export type LocationUpsertWithoutDropoffDeliveryQuotesInput = {
    update: XOR<LocationUpdateWithoutDropoffDeliveryQuotesInput, LocationUncheckedUpdateWithoutDropoffDeliveryQuotesInput>
    create: XOR<LocationCreateWithoutDropoffDeliveryQuotesInput, LocationUncheckedCreateWithoutDropoffDeliveryQuotesInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutDropoffDeliveryQuotesInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutDropoffDeliveryQuotesInput, LocationUncheckedUpdateWithoutDropoffDeliveryQuotesInput>
  }

  export type LocationUpdateWithoutDropoffDeliveryQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: EnumEnumCountryCodeFieldUpdateOperationsInput | $Enums.EnumCountryCode
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    formattedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNotes?: LocationNoteUpdateManyWithoutLocationsNestedInput
    pickupDelivery?: DeliveryUpdateManyWithoutPickupLocationNestedInput
    dropoffDelivery?: DeliveryUpdateManyWithoutDropoffLocationNestedInput
    pickupDeliveryQuotes?: DeliveryQuoteUpdateManyWithoutPickupLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutDropoffDeliveryQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: EnumEnumCountryCodeFieldUpdateOperationsInput | $Enums.EnumCountryCode
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    formattedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNotes?: LocationNoteUncheckedUpdateManyWithoutLocationsNestedInput
    pickupDelivery?: DeliveryUncheckedUpdateManyWithoutPickupLocationNestedInput
    dropoffDelivery?: DeliveryUncheckedUpdateManyWithoutDropoffLocationNestedInput
    pickupDeliveryQuotes?: DeliveryQuoteUncheckedUpdateManyWithoutPickupLocationNestedInput
  }

  export type PartnerUpsertWithoutDeliveryQuotesInput = {
    update: XOR<PartnerUpdateWithoutDeliveryQuotesInput, PartnerUncheckedUpdateWithoutDeliveryQuotesInput>
    create: XOR<PartnerCreateWithoutDeliveryQuotesInput, PartnerUncheckedCreateWithoutDeliveryQuotesInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutDeliveryQuotesInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutDeliveryQuotesInput, PartnerUncheckedUpdateWithoutDeliveryQuotesInput>
  }

  export type PartnerUpdateWithoutDeliveryQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: DeliveryUpdateManyWithoutPartnerNestedInput
    user?: UserUpdateOneWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutDeliveryQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveries?: DeliveryUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type DeliveryUpsertWithoutDeliveryInput = {
    update: XOR<DeliveryUpdateWithoutDeliveryInput, DeliveryUncheckedUpdateWithoutDeliveryInput>
    create: XOR<DeliveryCreateWithoutDeliveryInput, DeliveryUncheckedCreateWithoutDeliveryInput>
    where?: DeliveryWhereInput
  }

  export type DeliveryUpdateToOneWithWhereWithoutDeliveryInput = {
    where?: DeliveryWhereInput
    data: XOR<DeliveryUpdateWithoutDeliveryInput, DeliveryUncheckedUpdateWithoutDeliveryInput>
  }

  export type DeliveryUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocation?: LocationUpdateOneWithoutPickupDeliveryNestedInput
    dropoffLocation?: LocationUpdateOneWithoutDropoffDeliveryNestedInput
    courier?: CourierUpdateOneWithoutDeliveriesNestedInput
    partner?: PartnerUpdateOneWithoutDeliveriesNestedInput
    payment?: PaymentUpdateManyWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateManyWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUncheckedUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type LocationCreateWithoutPickupDeliveryInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    street?: string | null
    zipCode?: string | null
    countryCode?: $Enums.EnumCountryCode
    stateCode?: string | null
    houseNumber?: string | null
    longitude: number
    latitude: number
    formattedAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNotes?: LocationNoteCreateNestedManyWithoutLocationsInput
    dropoffDelivery?: DeliveryCreateNestedManyWithoutDropoffLocationInput
    pickupDeliveryQuotes?: DeliveryQuoteCreateNestedManyWithoutPickupLocationInput
    dropoffDeliveryQuotes?: DeliveryQuoteCreateNestedManyWithoutDropoffLocationInput
  }

  export type LocationUncheckedCreateWithoutPickupDeliveryInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    street?: string | null
    zipCode?: string | null
    countryCode?: $Enums.EnumCountryCode
    stateCode?: string | null
    houseNumber?: string | null
    longitude: number
    latitude: number
    formattedAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNotes?: LocationNoteUncheckedCreateNestedManyWithoutLocationsInput
    dropoffDelivery?: DeliveryUncheckedCreateNestedManyWithoutDropoffLocationInput
    pickupDeliveryQuotes?: DeliveryQuoteUncheckedCreateNestedManyWithoutPickupLocationInput
    dropoffDeliveryQuotes?: DeliveryQuoteUncheckedCreateNestedManyWithoutDropoffLocationInput
  }

  export type LocationCreateOrConnectWithoutPickupDeliveryInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutPickupDeliveryInput, LocationUncheckedCreateWithoutPickupDeliveryInput>
  }

  export type LocationCreateWithoutDropoffDeliveryInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    street?: string | null
    zipCode?: string | null
    countryCode?: $Enums.EnumCountryCode
    stateCode?: string | null
    houseNumber?: string | null
    longitude: number
    latitude: number
    formattedAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNotes?: LocationNoteCreateNestedManyWithoutLocationsInput
    pickupDelivery?: DeliveryCreateNestedManyWithoutPickupLocationInput
    pickupDeliveryQuotes?: DeliveryQuoteCreateNestedManyWithoutPickupLocationInput
    dropoffDeliveryQuotes?: DeliveryQuoteCreateNestedManyWithoutDropoffLocationInput
  }

  export type LocationUncheckedCreateWithoutDropoffDeliveryInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    street?: string | null
    zipCode?: string | null
    countryCode?: $Enums.EnumCountryCode
    stateCode?: string | null
    houseNumber?: string | null
    longitude: number
    latitude: number
    formattedAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNotes?: LocationNoteUncheckedCreateNestedManyWithoutLocationsInput
    pickupDelivery?: DeliveryUncheckedCreateNestedManyWithoutPickupLocationInput
    pickupDeliveryQuotes?: DeliveryQuoteUncheckedCreateNestedManyWithoutPickupLocationInput
    dropoffDeliveryQuotes?: DeliveryQuoteUncheckedCreateNestedManyWithoutDropoffLocationInput
  }

  export type LocationCreateOrConnectWithoutDropoffDeliveryInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutDropoffDeliveryInput, LocationUncheckedCreateWithoutDropoffDeliveryInput>
  }

  export type CourierCreateWithoutDeliveriesInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    user: UserCreateNestedOneWithoutCourierInput
    comments?: CommentCreateNestedManyWithoutCouriersInput
    earnings?: EarningCreateNestedManyWithoutCouriersInput
    settings?: CourierSettingCreateNestedOneWithoutCouriersInput
    Payout?: PayoutCreateNestedManyWithoutCourierInput
    Transfer?: TransferCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionCreateNestedManyWithoutCouriersInput
  }

  export type CourierUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedCreateNestedManyWithoutCouriersInput
    earnings?: EarningUncheckedCreateNestedManyWithoutCouriersInput
    settings?: CourierSettingUncheckedCreateNestedOneWithoutCouriersInput
    Payout?: PayoutUncheckedCreateNestedManyWithoutCourierInput
    Transfer?: TransferUncheckedCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteUncheckedCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionUncheckedCreateNestedManyWithoutCouriersInput
  }

  export type CourierCreateOrConnectWithoutDeliveriesInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutDeliveriesInput, CourierUncheckedCreateWithoutDeliveriesInput>
  }

  export type PartnerCreateWithoutDeliveriesInput = {
    id?: string
    name: string
    logo?: string | null
    phoneNumber?: string | null
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryQuotes?: DeliveryQuoteCreateNestedManyWithoutPartnersInput
    user?: UserCreateNestedOneWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    name: string
    logo?: string | null
    phoneNumber?: string | null
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    deliveryQuotes?: DeliveryQuoteUncheckedCreateNestedManyWithoutPartnersInput
  }

  export type PartnerCreateOrConnectWithoutDeliveriesInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutDeliveriesInput, PartnerUncheckedCreateWithoutDeliveriesInput>
  }

  export type DeliveryQuoteCreateWithoutDeliveryInput = {
    id?: string
    quote?: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage?: number
    currency: string
    duration: number
    distance: number
    distanceUnit?: $Enums.EnumDistanceUnit
    pickupPhoneNumber?: string | null
    pickupName?: string | null
    dropoffPhoneNumber?: string | null
    dropoffName?: string | null
    expiresAt?: Date | string | null
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    orderTotalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryId?: string | null
    pickupLocation: LocationCreateNestedOneWithoutPickupDeliveryQuotesInput
    dropoffLocation: LocationCreateNestedOneWithoutDropoffDeliveryQuotesInput
    partners?: PartnerCreateNestedOneWithoutDeliveryQuotesInput
  }

  export type DeliveryQuoteUncheckedCreateWithoutDeliveryInput = {
    id?: string
    quote?: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage?: number
    currency: string
    duration: number
    distance: number
    distanceUnit?: $Enums.EnumDistanceUnit
    pickupPhoneNumber?: string | null
    pickupName?: string | null
    dropoffPhoneNumber?: string | null
    dropoffName?: string | null
    expiresAt?: Date | string | null
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    orderTotalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocationId: string
    dropoffLocationId: string
    partnerId?: string | null
    deliveryId?: string | null
  }

  export type DeliveryQuoteCreateOrConnectWithoutDeliveryInput = {
    where: DeliveryQuoteWhereUniqueInput
    create: XOR<DeliveryQuoteCreateWithoutDeliveryInput, DeliveryQuoteUncheckedCreateWithoutDeliveryInput>
  }

  export type PaymentCreateWithoutDeliveryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capturedAt?: Date | string | null
    canceledAt?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.EnumPaymentStatus
    provider?: $Enums.EnumPaymentProvider
    transfers?: TransferCreateNestedManyWithoutPaymentInput
    refunds?: RefundCreateNestedManyWithoutPaymentInput
    payouts?: PayoutCreateNestedManyWithoutPaymentInput
    stripeData?: StripePaymentDataCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutDeliveryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capturedAt?: Date | string | null
    canceledAt?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.EnumPaymentStatus
    provider?: $Enums.EnumPaymentProvider
    transfers?: TransferUncheckedCreateNestedManyWithoutPaymentInput
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutPaymentInput
    stripeData?: StripePaymentDataUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutDeliveryInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutDeliveryInput, PaymentUncheckedCreateWithoutDeliveryInput>
  }

  export type PaymentCreateManyDeliveryInputEnvelope = {
    data: PaymentCreateManyDeliveryInput | PaymentCreateManyDeliveryInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryEventCreateWithoutDeliveryInput = {
    id?: string
    transitionSuccessful: boolean
    type: $Enums.EnumDeliveryEventType
    actor: $Enums.EnumEventActor
    eventSource: $Enums.EnumDeliveryEventSource
    oldStatus?: $Enums.EnumDeliveryStatus | null
    newStatus?: $Enums.EnumDeliveryStatus | null
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryEventUncheckedCreateWithoutDeliveryInput = {
    id?: string
    transitionSuccessful: boolean
    type: $Enums.EnumDeliveryEventType
    actor: $Enums.EnumEventActor
    eventSource: $Enums.EnumDeliveryEventSource
    oldStatus?: $Enums.EnumDeliveryStatus | null
    newStatus?: $Enums.EnumDeliveryStatus | null
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryEventCreateOrConnectWithoutDeliveryInput = {
    where: DeliveryEventWhereUniqueInput
    create: XOR<DeliveryEventCreateWithoutDeliveryInput, DeliveryEventUncheckedCreateWithoutDeliveryInput>
  }

  export type DeliveryEventCreateManyDeliveryInputEnvelope = {
    data: DeliveryEventCreateManyDeliveryInput | DeliveryEventCreateManyDeliveryInput[]
    skipDuplicates?: boolean
  }

  export type LocationNoteCreateWithoutDeliveryInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor: $Enums.EnumLocationNoteActor
    locations?: LocationCreateNestedOneWithoutLocationNotesInput
    couriers?: CourierCreateNestedOneWithoutLocationNotesInput
    noteReactions?: LocationNoteReactionCreateNestedManyWithoutLocationNoteInput
  }

  export type LocationNoteUncheckedCreateWithoutDeliveryInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor: $Enums.EnumLocationNoteActor
    locationId?: string | null
    courierId?: string | null
    noteReactions?: LocationNoteReactionUncheckedCreateNestedManyWithoutLocationNoteInput
  }

  export type LocationNoteCreateOrConnectWithoutDeliveryInput = {
    where: LocationNoteWhereUniqueInput
    create: XOR<LocationNoteCreateWithoutDeliveryInput, LocationNoteUncheckedCreateWithoutDeliveryInput>
  }

  export type LocationNoteCreateManyDeliveryInputEnvelope = {
    data: LocationNoteCreateManyDeliveryInput | LocationNoteCreateManyDeliveryInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutPickupDeliveryInput = {
    update: XOR<LocationUpdateWithoutPickupDeliveryInput, LocationUncheckedUpdateWithoutPickupDeliveryInput>
    create: XOR<LocationCreateWithoutPickupDeliveryInput, LocationUncheckedCreateWithoutPickupDeliveryInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutPickupDeliveryInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutPickupDeliveryInput, LocationUncheckedUpdateWithoutPickupDeliveryInput>
  }

  export type LocationUpdateWithoutPickupDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: EnumEnumCountryCodeFieldUpdateOperationsInput | $Enums.EnumCountryCode
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    formattedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNotes?: LocationNoteUpdateManyWithoutLocationsNestedInput
    dropoffDelivery?: DeliveryUpdateManyWithoutDropoffLocationNestedInput
    pickupDeliveryQuotes?: DeliveryQuoteUpdateManyWithoutPickupLocationNestedInput
    dropoffDeliveryQuotes?: DeliveryQuoteUpdateManyWithoutDropoffLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutPickupDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: EnumEnumCountryCodeFieldUpdateOperationsInput | $Enums.EnumCountryCode
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    formattedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNotes?: LocationNoteUncheckedUpdateManyWithoutLocationsNestedInput
    dropoffDelivery?: DeliveryUncheckedUpdateManyWithoutDropoffLocationNestedInput
    pickupDeliveryQuotes?: DeliveryQuoteUncheckedUpdateManyWithoutPickupLocationNestedInput
    dropoffDeliveryQuotes?: DeliveryQuoteUncheckedUpdateManyWithoutDropoffLocationNestedInput
  }

  export type LocationUpsertWithoutDropoffDeliveryInput = {
    update: XOR<LocationUpdateWithoutDropoffDeliveryInput, LocationUncheckedUpdateWithoutDropoffDeliveryInput>
    create: XOR<LocationCreateWithoutDropoffDeliveryInput, LocationUncheckedCreateWithoutDropoffDeliveryInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutDropoffDeliveryInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutDropoffDeliveryInput, LocationUncheckedUpdateWithoutDropoffDeliveryInput>
  }

  export type LocationUpdateWithoutDropoffDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: EnumEnumCountryCodeFieldUpdateOperationsInput | $Enums.EnumCountryCode
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    formattedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNotes?: LocationNoteUpdateManyWithoutLocationsNestedInput
    pickupDelivery?: DeliveryUpdateManyWithoutPickupLocationNestedInput
    pickupDeliveryQuotes?: DeliveryQuoteUpdateManyWithoutPickupLocationNestedInput
    dropoffDeliveryQuotes?: DeliveryQuoteUpdateManyWithoutDropoffLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutDropoffDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: EnumEnumCountryCodeFieldUpdateOperationsInput | $Enums.EnumCountryCode
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    formattedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNotes?: LocationNoteUncheckedUpdateManyWithoutLocationsNestedInput
    pickupDelivery?: DeliveryUncheckedUpdateManyWithoutPickupLocationNestedInput
    pickupDeliveryQuotes?: DeliveryQuoteUncheckedUpdateManyWithoutPickupLocationNestedInput
    dropoffDeliveryQuotes?: DeliveryQuoteUncheckedUpdateManyWithoutDropoffLocationNestedInput
  }

  export type CourierUpsertWithoutDeliveriesInput = {
    update: XOR<CourierUpdateWithoutDeliveriesInput, CourierUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<CourierCreateWithoutDeliveriesInput, CourierUncheckedCreateWithoutDeliveriesInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutDeliveriesInput, CourierUncheckedUpdateWithoutDeliveriesInput>
  }

  export type CourierUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    comments?: CommentUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUpdateManyWithoutCouriersNestedInput
    settings?: CourierSettingUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUpdateManyWithoutCouriersNestedInput
  }

  export type CourierUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUncheckedUpdateManyWithoutCouriersNestedInput
    settings?: CourierSettingUncheckedUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUncheckedUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUncheckedUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUncheckedUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUncheckedUpdateManyWithoutCouriersNestedInput
  }

  export type PartnerUpsertWithoutDeliveriesInput = {
    update: XOR<PartnerUpdateWithoutDeliveriesInput, PartnerUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<PartnerCreateWithoutDeliveriesInput, PartnerUncheckedCreateWithoutDeliveriesInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutDeliveriesInput, PartnerUncheckedUpdateWithoutDeliveriesInput>
  }

  export type PartnerUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryQuotes?: DeliveryQuoteUpdateManyWithoutPartnersNestedInput
    user?: UserUpdateOneWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQuotes?: DeliveryQuoteUncheckedUpdateManyWithoutPartnersNestedInput
  }

  export type DeliveryQuoteUpsertWithoutDeliveryInput = {
    update: XOR<DeliveryQuoteUpdateWithoutDeliveryInput, DeliveryQuoteUncheckedUpdateWithoutDeliveryInput>
    create: XOR<DeliveryQuoteCreateWithoutDeliveryInput, DeliveryQuoteUncheckedCreateWithoutDeliveryInput>
    where?: DeliveryQuoteWhereInput
  }

  export type DeliveryQuoteUpdateToOneWithWhereWithoutDeliveryInput = {
    where?: DeliveryQuoteWhereInput
    data: XOR<DeliveryQuoteUpdateWithoutDeliveryInput, DeliveryQuoteUncheckedUpdateWithoutDeliveryInput>
  }

  export type DeliveryQuoteUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLocation?: LocationUpdateOneRequiredWithoutPickupDeliveryQuotesNestedInput
    dropoffLocation?: LocationUpdateOneRequiredWithoutDropoffDeliveryQuotesNestedInput
    partners?: PartnerUpdateOneWithoutDeliveryQuotesNestedInput
  }

  export type DeliveryQuoteUncheckedUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutDeliveryInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutDeliveryInput, PaymentUncheckedUpdateWithoutDeliveryInput>
    create: XOR<PaymentCreateWithoutDeliveryInput, PaymentUncheckedCreateWithoutDeliveryInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutDeliveryInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutDeliveryInput, PaymentUncheckedUpdateWithoutDeliveryInput>
  }

  export type PaymentUpdateManyWithWhereWithoutDeliveryInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutDeliveryInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    capturedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFilter<"Payment"> | $Enums.EnumPaymentStatus
    deliveryId?: StringFilter<"Payment"> | string
    provider?: EnumEnumPaymentProviderFilter<"Payment"> | $Enums.EnumPaymentProvider
  }

  export type DeliveryEventUpsertWithWhereUniqueWithoutDeliveryInput = {
    where: DeliveryEventWhereUniqueInput
    update: XOR<DeliveryEventUpdateWithoutDeliveryInput, DeliveryEventUncheckedUpdateWithoutDeliveryInput>
    create: XOR<DeliveryEventCreateWithoutDeliveryInput, DeliveryEventUncheckedCreateWithoutDeliveryInput>
  }

  export type DeliveryEventUpdateWithWhereUniqueWithoutDeliveryInput = {
    where: DeliveryEventWhereUniqueInput
    data: XOR<DeliveryEventUpdateWithoutDeliveryInput, DeliveryEventUncheckedUpdateWithoutDeliveryInput>
  }

  export type DeliveryEventUpdateManyWithWhereWithoutDeliveryInput = {
    where: DeliveryEventScalarWhereInput
    data: XOR<DeliveryEventUpdateManyMutationInput, DeliveryEventUncheckedUpdateManyWithoutDeliveryInput>
  }

  export type DeliveryEventScalarWhereInput = {
    AND?: DeliveryEventScalarWhereInput | DeliveryEventScalarWhereInput[]
    OR?: DeliveryEventScalarWhereInput[]
    NOT?: DeliveryEventScalarWhereInput | DeliveryEventScalarWhereInput[]
    id?: StringFilter<"DeliveryEvent"> | string
    transitionSuccessful?: BoolFilter<"DeliveryEvent"> | boolean
    type?: EnumEnumDeliveryEventTypeFilter<"DeliveryEvent"> | $Enums.EnumDeliveryEventType
    actor?: EnumEnumEventActorFilter<"DeliveryEvent"> | $Enums.EnumEventActor
    eventSource?: EnumEnumDeliveryEventSourceFilter<"DeliveryEvent"> | $Enums.EnumDeliveryEventSource
    oldStatus?: EnumEnumDeliveryStatusNullableFilter<"DeliveryEvent"> | $Enums.EnumDeliveryStatus | null
    newStatus?: EnumEnumDeliveryStatusNullableFilter<"DeliveryEvent"> | $Enums.EnumDeliveryStatus | null
    message?: StringNullableFilter<"DeliveryEvent"> | string | null
    deliveryId?: StringFilter<"DeliveryEvent"> | string
    createdAt?: DateTimeFilter<"DeliveryEvent"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryEvent"> | Date | string
  }

  export type LocationNoteUpsertWithWhereUniqueWithoutDeliveryInput = {
    where: LocationNoteWhereUniqueInput
    update: XOR<LocationNoteUpdateWithoutDeliveryInput, LocationNoteUncheckedUpdateWithoutDeliveryInput>
    create: XOR<LocationNoteCreateWithoutDeliveryInput, LocationNoteUncheckedCreateWithoutDeliveryInput>
  }

  export type LocationNoteUpdateWithWhereUniqueWithoutDeliveryInput = {
    where: LocationNoteWhereUniqueInput
    data: XOR<LocationNoteUpdateWithoutDeliveryInput, LocationNoteUncheckedUpdateWithoutDeliveryInput>
  }

  export type LocationNoteUpdateManyWithWhereWithoutDeliveryInput = {
    where: LocationNoteScalarWhereInput
    data: XOR<LocationNoteUpdateManyMutationInput, LocationNoteUncheckedUpdateManyWithoutDeliveryInput>
  }

  export type DeliveryCreateWithoutDeliveryEventInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocation?: LocationCreateNestedOneWithoutPickupDeliveryInput
    dropoffLocation?: LocationCreateNestedOneWithoutDropoffDeliveryInput
    courier?: CourierCreateNestedOneWithoutDeliveriesInput
    partner?: PartnerCreateNestedOneWithoutDeliveriesInput
    delivery: DeliveryQuoteCreateNestedOneWithoutDeliveryInput
    payment?: PaymentCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutDeliveryEventInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId: string
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    dropoffLocationId: string
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    courierId?: string | null
    partnerId?: string | null
    deliveryQuoteId: string
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutDeliveryEventInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutDeliveryEventInput, DeliveryUncheckedCreateWithoutDeliveryEventInput>
  }

  export type DeliveryUpsertWithoutDeliveryEventInput = {
    update: XOR<DeliveryUpdateWithoutDeliveryEventInput, DeliveryUncheckedUpdateWithoutDeliveryEventInput>
    create: XOR<DeliveryCreateWithoutDeliveryEventInput, DeliveryUncheckedCreateWithoutDeliveryEventInput>
    where?: DeliveryWhereInput
  }

  export type DeliveryUpdateToOneWithWhereWithoutDeliveryEventInput = {
    where?: DeliveryWhereInput
    data: XOR<DeliveryUpdateWithoutDeliveryEventInput, DeliveryUncheckedUpdateWithoutDeliveryEventInput>
  }

  export type DeliveryUpdateWithoutDeliveryEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocation?: LocationUpdateOneWithoutPickupDeliveryNestedInput
    dropoffLocation?: LocationUpdateOneWithoutDropoffDeliveryNestedInput
    courier?: CourierUpdateOneWithoutDeliveriesNestedInput
    partner?: PartnerUpdateOneWithoutDeliveriesNestedInput
    delivery?: DeliveryQuoteUpdateOneRequiredWithoutDeliveryNestedInput
    payment?: PaymentUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutDeliveryEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQuoteId?: StringFieldUpdateOperationsInput | string
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type LocationCreateWithoutLocationNotesInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    street?: string | null
    zipCode?: string | null
    countryCode?: $Enums.EnumCountryCode
    stateCode?: string | null
    houseNumber?: string | null
    longitude: number
    latitude: number
    formattedAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupDelivery?: DeliveryCreateNestedManyWithoutPickupLocationInput
    dropoffDelivery?: DeliveryCreateNestedManyWithoutDropoffLocationInput
    pickupDeliveryQuotes?: DeliveryQuoteCreateNestedManyWithoutPickupLocationInput
    dropoffDeliveryQuotes?: DeliveryQuoteCreateNestedManyWithoutDropoffLocationInput
  }

  export type LocationUncheckedCreateWithoutLocationNotesInput = {
    id?: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    street?: string | null
    zipCode?: string | null
    countryCode?: $Enums.EnumCountryCode
    stateCode?: string | null
    houseNumber?: string | null
    longitude: number
    latitude: number
    formattedAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupDelivery?: DeliveryUncheckedCreateNestedManyWithoutPickupLocationInput
    dropoffDelivery?: DeliveryUncheckedCreateNestedManyWithoutDropoffLocationInput
    pickupDeliveryQuotes?: DeliveryQuoteUncheckedCreateNestedManyWithoutPickupLocationInput
    dropoffDeliveryQuotes?: DeliveryQuoteUncheckedCreateNestedManyWithoutDropoffLocationInput
  }

  export type LocationCreateOrConnectWithoutLocationNotesInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutLocationNotesInput, LocationUncheckedCreateWithoutLocationNotesInput>
  }

  export type DeliveryCreateWithoutLocationNoteInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocation?: LocationCreateNestedOneWithoutPickupDeliveryInput
    dropoffLocation?: LocationCreateNestedOneWithoutDropoffDeliveryInput
    courier?: CourierCreateNestedOneWithoutDeliveriesInput
    partner?: PartnerCreateNestedOneWithoutDeliveriesInput
    delivery: DeliveryQuoteCreateNestedOneWithoutDeliveryInput
    payment?: PaymentCreateNestedManyWithoutDeliveryInput
    deliveryEvent?: DeliveryEventCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutLocationNoteInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId: string
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    dropoffLocationId: string
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    courierId?: string | null
    partnerId?: string | null
    deliveryQuoteId: string
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedManyWithoutDeliveryInput
    deliveryEvent?: DeliveryEventUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutLocationNoteInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutLocationNoteInput, DeliveryUncheckedCreateWithoutLocationNoteInput>
  }

  export type CourierCreateWithoutLocationNotesInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    user: UserCreateNestedOneWithoutCourierInput
    comments?: CommentCreateNestedManyWithoutCouriersInput
    earnings?: EarningCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    settings?: CourierSettingCreateNestedOneWithoutCouriersInput
    Payout?: PayoutCreateNestedManyWithoutCourierInput
    Transfer?: TransferCreateNestedManyWithoutCourierInput
    locationNoteReactions?: LocationNoteReactionCreateNestedManyWithoutCouriersInput
  }

  export type CourierUncheckedCreateWithoutLocationNotesInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedCreateNestedManyWithoutCouriersInput
    earnings?: EarningUncheckedCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    settings?: CourierSettingUncheckedCreateNestedOneWithoutCouriersInput
    Payout?: PayoutUncheckedCreateNestedManyWithoutCourierInput
    Transfer?: TransferUncheckedCreateNestedManyWithoutCourierInput
    locationNoteReactions?: LocationNoteReactionUncheckedCreateNestedManyWithoutCouriersInput
  }

  export type CourierCreateOrConnectWithoutLocationNotesInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutLocationNotesInput, CourierUncheckedCreateWithoutLocationNotesInput>
  }

  export type LocationNoteReactionCreateWithoutLocationNoteInput = {
    id?: string
    reaction: $Enums.EnumLocationNoteReactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    couriers: CourierCreateNestedOneWithoutLocationNoteReactionsInput
  }

  export type LocationNoteReactionUncheckedCreateWithoutLocationNoteInput = {
    id?: string
    reaction: $Enums.EnumLocationNoteReactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    courierId: string
  }

  export type LocationNoteReactionCreateOrConnectWithoutLocationNoteInput = {
    where: LocationNoteReactionWhereUniqueInput
    create: XOR<LocationNoteReactionCreateWithoutLocationNoteInput, LocationNoteReactionUncheckedCreateWithoutLocationNoteInput>
  }

  export type LocationNoteReactionCreateManyLocationNoteInputEnvelope = {
    data: LocationNoteReactionCreateManyLocationNoteInput | LocationNoteReactionCreateManyLocationNoteInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutLocationNotesInput = {
    update: XOR<LocationUpdateWithoutLocationNotesInput, LocationUncheckedUpdateWithoutLocationNotesInput>
    create: XOR<LocationCreateWithoutLocationNotesInput, LocationUncheckedCreateWithoutLocationNotesInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutLocationNotesInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutLocationNotesInput, LocationUncheckedUpdateWithoutLocationNotesInput>
  }

  export type LocationUpdateWithoutLocationNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: EnumEnumCountryCodeFieldUpdateOperationsInput | $Enums.EnumCountryCode
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    formattedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupDelivery?: DeliveryUpdateManyWithoutPickupLocationNestedInput
    dropoffDelivery?: DeliveryUpdateManyWithoutDropoffLocationNestedInput
    pickupDeliveryQuotes?: DeliveryQuoteUpdateManyWithoutPickupLocationNestedInput
    dropoffDeliveryQuotes?: DeliveryQuoteUpdateManyWithoutDropoffLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutLocationNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: EnumEnumCountryCodeFieldUpdateOperationsInput | $Enums.EnumCountryCode
    stateCode?: NullableStringFieldUpdateOperationsInput | string | null
    houseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    formattedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupDelivery?: DeliveryUncheckedUpdateManyWithoutPickupLocationNestedInput
    dropoffDelivery?: DeliveryUncheckedUpdateManyWithoutDropoffLocationNestedInput
    pickupDeliveryQuotes?: DeliveryQuoteUncheckedUpdateManyWithoutPickupLocationNestedInput
    dropoffDeliveryQuotes?: DeliveryQuoteUncheckedUpdateManyWithoutDropoffLocationNestedInput
  }

  export type DeliveryUpsertWithoutLocationNoteInput = {
    update: XOR<DeliveryUpdateWithoutLocationNoteInput, DeliveryUncheckedUpdateWithoutLocationNoteInput>
    create: XOR<DeliveryCreateWithoutLocationNoteInput, DeliveryUncheckedCreateWithoutLocationNoteInput>
    where?: DeliveryWhereInput
  }

  export type DeliveryUpdateToOneWithWhereWithoutLocationNoteInput = {
    where?: DeliveryWhereInput
    data: XOR<DeliveryUpdateWithoutLocationNoteInput, DeliveryUncheckedUpdateWithoutLocationNoteInput>
  }

  export type DeliveryUpdateWithoutLocationNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocation?: LocationUpdateOneWithoutPickupDeliveryNestedInput
    dropoffLocation?: LocationUpdateOneWithoutDropoffDeliveryNestedInput
    courier?: CourierUpdateOneWithoutDeliveriesNestedInput
    partner?: PartnerUpdateOneWithoutDeliveriesNestedInput
    delivery?: DeliveryQuoteUpdateOneRequiredWithoutDeliveryNestedInput
    payment?: PaymentUpdateManyWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutLocationNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQuoteId?: StringFieldUpdateOperationsInput | string
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateManyWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type CourierUpsertWithoutLocationNotesInput = {
    update: XOR<CourierUpdateWithoutLocationNotesInput, CourierUncheckedUpdateWithoutLocationNotesInput>
    create: XOR<CourierCreateWithoutLocationNotesInput, CourierUncheckedCreateWithoutLocationNotesInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutLocationNotesInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutLocationNotesInput, CourierUncheckedUpdateWithoutLocationNotesInput>
  }

  export type CourierUpdateWithoutLocationNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    comments?: CommentUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUpdateManyWithoutCourierNestedInput
    locationNoteReactions?: LocationNoteReactionUpdateManyWithoutCouriersNestedInput
  }

  export type CourierUncheckedUpdateWithoutLocationNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUncheckedUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUncheckedUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUncheckedUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUncheckedUpdateManyWithoutCourierNestedInput
    locationNoteReactions?: LocationNoteReactionUncheckedUpdateManyWithoutCouriersNestedInput
  }

  export type LocationNoteReactionUpsertWithWhereUniqueWithoutLocationNoteInput = {
    where: LocationNoteReactionWhereUniqueInput
    update: XOR<LocationNoteReactionUpdateWithoutLocationNoteInput, LocationNoteReactionUncheckedUpdateWithoutLocationNoteInput>
    create: XOR<LocationNoteReactionCreateWithoutLocationNoteInput, LocationNoteReactionUncheckedCreateWithoutLocationNoteInput>
  }

  export type LocationNoteReactionUpdateWithWhereUniqueWithoutLocationNoteInput = {
    where: LocationNoteReactionWhereUniqueInput
    data: XOR<LocationNoteReactionUpdateWithoutLocationNoteInput, LocationNoteReactionUncheckedUpdateWithoutLocationNoteInput>
  }

  export type LocationNoteReactionUpdateManyWithWhereWithoutLocationNoteInput = {
    where: LocationNoteReactionScalarWhereInput
    data: XOR<LocationNoteReactionUpdateManyMutationInput, LocationNoteReactionUncheckedUpdateManyWithoutLocationNoteInput>
  }

  export type LocationNoteCreateWithoutNoteReactionsInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor: $Enums.EnumLocationNoteActor
    locations?: LocationCreateNestedOneWithoutLocationNotesInput
    delivery?: DeliveryCreateNestedOneWithoutLocationNoteInput
    couriers?: CourierCreateNestedOneWithoutLocationNotesInput
  }

  export type LocationNoteUncheckedCreateWithoutNoteReactionsInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor: $Enums.EnumLocationNoteActor
    locationId?: string | null
    deliveryId?: string | null
    courierId?: string | null
  }

  export type LocationNoteCreateOrConnectWithoutNoteReactionsInput = {
    where: LocationNoteWhereUniqueInput
    create: XOR<LocationNoteCreateWithoutNoteReactionsInput, LocationNoteUncheckedCreateWithoutNoteReactionsInput>
  }

  export type CourierCreateWithoutLocationNoteReactionsInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    user: UserCreateNestedOneWithoutCourierInput
    comments?: CommentCreateNestedManyWithoutCouriersInput
    earnings?: EarningCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    settings?: CourierSettingCreateNestedOneWithoutCouriersInput
    Payout?: PayoutCreateNestedManyWithoutCourierInput
    Transfer?: TransferCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteCreateNestedManyWithoutCouriersInput
  }

  export type CourierUncheckedCreateWithoutLocationNoteReactionsInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedCreateNestedManyWithoutCouriersInput
    earnings?: EarningUncheckedCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    settings?: CourierSettingUncheckedCreateNestedOneWithoutCouriersInput
    Payout?: PayoutUncheckedCreateNestedManyWithoutCourierInput
    Transfer?: TransferUncheckedCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteUncheckedCreateNestedManyWithoutCouriersInput
  }

  export type CourierCreateOrConnectWithoutLocationNoteReactionsInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutLocationNoteReactionsInput, CourierUncheckedCreateWithoutLocationNoteReactionsInput>
  }

  export type LocationNoteUpsertWithoutNoteReactionsInput = {
    update: XOR<LocationNoteUpdateWithoutNoteReactionsInput, LocationNoteUncheckedUpdateWithoutNoteReactionsInput>
    create: XOR<LocationNoteCreateWithoutNoteReactionsInput, LocationNoteUncheckedCreateWithoutNoteReactionsInput>
    where?: LocationNoteWhereInput
  }

  export type LocationNoteUpdateToOneWithWhereWithoutNoteReactionsInput = {
    where?: LocationNoteWhereInput
    data: XOR<LocationNoteUpdateWithoutNoteReactionsInput, LocationNoteUncheckedUpdateWithoutNoteReactionsInput>
  }

  export type LocationNoteUpdateWithoutNoteReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
    locations?: LocationUpdateOneWithoutLocationNotesNestedInput
    delivery?: DeliveryUpdateOneWithoutLocationNoteNestedInput
    couriers?: CourierUpdateOneWithoutLocationNotesNestedInput
  }

  export type LocationNoteUncheckedUpdateWithoutNoteReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourierUpsertWithoutLocationNoteReactionsInput = {
    update: XOR<CourierUpdateWithoutLocationNoteReactionsInput, CourierUncheckedUpdateWithoutLocationNoteReactionsInput>
    create: XOR<CourierCreateWithoutLocationNoteReactionsInput, CourierUncheckedCreateWithoutLocationNoteReactionsInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutLocationNoteReactionsInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutLocationNoteReactionsInput, CourierUncheckedUpdateWithoutLocationNoteReactionsInput>
  }

  export type CourierUpdateWithoutLocationNoteReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    comments?: CommentUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUpdateManyWithoutCouriersNestedInput
  }

  export type CourierUncheckedUpdateWithoutLocationNoteReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUncheckedUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUncheckedUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUncheckedUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUncheckedUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUncheckedUpdateManyWithoutCouriersNestedInput
  }

  export type CourierCreateWithoutSettingsInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    user: UserCreateNestedOneWithoutCourierInput
    comments?: CommentCreateNestedManyWithoutCouriersInput
    earnings?: EarningCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    Payout?: PayoutCreateNestedManyWithoutCourierInput
    Transfer?: TransferCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionCreateNestedManyWithoutCouriersInput
  }

  export type CourierUncheckedCreateWithoutSettingsInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedCreateNestedManyWithoutCouriersInput
    earnings?: EarningUncheckedCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    Payout?: PayoutUncheckedCreateNestedManyWithoutCourierInput
    Transfer?: TransferUncheckedCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteUncheckedCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionUncheckedCreateNestedManyWithoutCouriersInput
  }

  export type CourierCreateOrConnectWithoutSettingsInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutSettingsInput, CourierUncheckedCreateWithoutSettingsInput>
  }

  export type CourierUpsertWithoutSettingsInput = {
    update: XOR<CourierUpdateWithoutSettingsInput, CourierUncheckedUpdateWithoutSettingsInput>
    create: XOR<CourierCreateWithoutSettingsInput, CourierUncheckedCreateWithoutSettingsInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutSettingsInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutSettingsInput, CourierUncheckedUpdateWithoutSettingsInput>
  }

  export type CourierUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    comments?: CommentUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    Payout?: PayoutUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUpdateManyWithoutCouriersNestedInput
  }

  export type CourierUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUncheckedUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    Payout?: PayoutUncheckedUpdateManyWithoutCourierNestedInput
    Transfer?: TransferUncheckedUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUncheckedUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUncheckedUpdateManyWithoutCouriersNestedInput
  }

  export type PaymentCreateWithoutPayoutsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capturedAt?: Date | string | null
    canceledAt?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.EnumPaymentStatus
    provider?: $Enums.EnumPaymentProvider
    delivery: DeliveryCreateNestedOneWithoutPaymentInput
    transfers?: TransferCreateNestedManyWithoutPaymentInput
    refunds?: RefundCreateNestedManyWithoutPaymentInput
    stripeData?: StripePaymentDataCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutPayoutsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capturedAt?: Date | string | null
    canceledAt?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.EnumPaymentStatus
    deliveryId: string
    provider?: $Enums.EnumPaymentProvider
    transfers?: TransferUncheckedCreateNestedManyWithoutPaymentInput
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
    stripeData?: StripePaymentDataUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutPayoutsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPayoutsInput, PaymentUncheckedCreateWithoutPayoutsInput>
  }

  export type CourierCreateWithoutPayoutInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    user: UserCreateNestedOneWithoutCourierInput
    comments?: CommentCreateNestedManyWithoutCouriersInput
    earnings?: EarningCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    settings?: CourierSettingCreateNestedOneWithoutCouriersInput
    Transfer?: TransferCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionCreateNestedManyWithoutCouriersInput
  }

  export type CourierUncheckedCreateWithoutPayoutInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedCreateNestedManyWithoutCouriersInput
    earnings?: EarningUncheckedCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    settings?: CourierSettingUncheckedCreateNestedOneWithoutCouriersInput
    Transfer?: TransferUncheckedCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteUncheckedCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionUncheckedCreateNestedManyWithoutCouriersInput
  }

  export type CourierCreateOrConnectWithoutPayoutInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutPayoutInput, CourierUncheckedCreateWithoutPayoutInput>
  }

  export type PaymentUpsertWithoutPayoutsInput = {
    update: XOR<PaymentUpdateWithoutPayoutsInput, PaymentUncheckedUpdateWithoutPayoutsInput>
    create: XOR<PaymentCreateWithoutPayoutsInput, PaymentUncheckedCreateWithoutPayoutsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutPayoutsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutPayoutsInput, PaymentUncheckedUpdateWithoutPayoutsInput>
  }

  export type PaymentUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
    delivery?: DeliveryUpdateOneRequiredWithoutPaymentNestedInput
    transfers?: TransferUpdateManyWithoutPaymentNestedInput
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
    stripeData?: StripePaymentDataUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    deliveryId?: StringFieldUpdateOperationsInput | string
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
    transfers?: TransferUncheckedUpdateManyWithoutPaymentNestedInput
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
    stripeData?: StripePaymentDataUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type CourierUpsertWithoutPayoutInput = {
    update: XOR<CourierUpdateWithoutPayoutInput, CourierUncheckedUpdateWithoutPayoutInput>
    create: XOR<CourierCreateWithoutPayoutInput, CourierUncheckedCreateWithoutPayoutInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutPayoutInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutPayoutInput, CourierUncheckedUpdateWithoutPayoutInput>
  }

  export type CourierUpdateWithoutPayoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    comments?: CommentUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUpdateOneWithoutCouriersNestedInput
    Transfer?: TransferUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUpdateManyWithoutCouriersNestedInput
  }

  export type CourierUncheckedUpdateWithoutPayoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUncheckedUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUncheckedUpdateOneWithoutCouriersNestedInput
    Transfer?: TransferUncheckedUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUncheckedUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUncheckedUpdateManyWithoutCouriersNestedInput
  }

  export type DeliveryCreateWithoutPaymentInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocation?: LocationCreateNestedOneWithoutPickupDeliveryInput
    dropoffLocation?: LocationCreateNestedOneWithoutDropoffDeliveryInput
    courier?: CourierCreateNestedOneWithoutDeliveriesInput
    partner?: PartnerCreateNestedOneWithoutDeliveriesInput
    delivery: DeliveryQuoteCreateNestedOneWithoutDeliveryInput
    deliveryEvent?: DeliveryEventCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutPaymentInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId: string
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    dropoffLocationId: string
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    courierId?: string | null
    partnerId?: string | null
    deliveryQuoteId: string
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryEvent?: DeliveryEventUncheckedCreateNestedManyWithoutDeliveryInput
    locationNote?: LocationNoteUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutPaymentInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutPaymentInput, DeliveryUncheckedCreateWithoutPaymentInput>
  }

  export type TransferCreateWithoutPaymentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transferId: string
    amount: number
    amountReversed: number
    destination: string
    destinationPayment?: string | null
    reversed?: boolean
    courier?: CourierCreateNestedOneWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutPaymentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transferId: string
    amount: number
    amountReversed: number
    destination: string
    destinationPayment?: string | null
    reversed?: boolean
    courierId?: string | null
  }

  export type TransferCreateOrConnectWithoutPaymentInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutPaymentInput, TransferUncheckedCreateWithoutPaymentInput>
  }

  export type TransferCreateManyPaymentInputEnvelope = {
    data: TransferCreateManyPaymentInput | TransferCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type RefundCreateWithoutPaymentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refundId?: string | null
    amount: number
    description?: string | null
    reason?: $Enums.EnumRefundReason | null
    status?: $Enums.EnumRefundStatus | null
  }

  export type RefundUncheckedCreateWithoutPaymentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refundId?: string | null
    amount: number
    description?: string | null
    reason?: $Enums.EnumRefundReason | null
    status?: $Enums.EnumRefundStatus | null
  }

  export type RefundCreateOrConnectWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    create: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput>
  }

  export type RefundCreateManyPaymentInputEnvelope = {
    data: RefundCreateManyPaymentInput | RefundCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type PayoutCreateWithoutPaymentInput = {
    id?: string
    amount: number
    arrivalDate: Date | string
    description?: string | null
    statementDescriptor?: string | null
    status: $Enums.EnumPayoutStatus
    courier?: CourierCreateNestedOneWithoutPayoutInput
  }

  export type PayoutUncheckedCreateWithoutPaymentInput = {
    id?: string
    amount: number
    arrivalDate: Date | string
    description?: string | null
    statementDescriptor?: string | null
    status: $Enums.EnumPayoutStatus
    courierId?: string | null
  }

  export type PayoutCreateOrConnectWithoutPaymentInput = {
    where: PayoutWhereUniqueInput
    create: XOR<PayoutCreateWithoutPaymentInput, PayoutUncheckedCreateWithoutPaymentInput>
  }

  export type PayoutCreateManyPaymentInputEnvelope = {
    data: PayoutCreateManyPaymentInput | PayoutCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type StripePaymentDataCreateWithoutPaymentInput = {
    id?: string
    paymentIntentId: string
    paymentMethodId: string
    latestChargeId?: string | null
  }

  export type StripePaymentDataUncheckedCreateWithoutPaymentInput = {
    id?: string
    paymentIntentId: string
    paymentMethodId: string
    latestChargeId?: string | null
  }

  export type StripePaymentDataCreateOrConnectWithoutPaymentInput = {
    where: StripePaymentDataWhereUniqueInput
    create: XOR<StripePaymentDataCreateWithoutPaymentInput, StripePaymentDataUncheckedCreateWithoutPaymentInput>
  }

  export type DeliveryUpsertWithoutPaymentInput = {
    update: XOR<DeliveryUpdateWithoutPaymentInput, DeliveryUncheckedUpdateWithoutPaymentInput>
    create: XOR<DeliveryCreateWithoutPaymentInput, DeliveryUncheckedCreateWithoutPaymentInput>
    where?: DeliveryWhereInput
  }

  export type DeliveryUpdateToOneWithWhereWithoutPaymentInput = {
    where?: DeliveryWhereInput
    data: XOR<DeliveryUpdateWithoutPaymentInput, DeliveryUncheckedUpdateWithoutPaymentInput>
  }

  export type DeliveryUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocation?: LocationUpdateOneWithoutPickupDeliveryNestedInput
    dropoffLocation?: LocationUpdateOneWithoutDropoffDeliveryNestedInput
    courier?: CourierUpdateOneWithoutDeliveriesNestedInput
    partner?: PartnerUpdateOneWithoutDeliveriesNestedInput
    delivery?: DeliveryQuoteUpdateOneRequiredWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQuoteId?: StringFieldUpdateOperationsInput | string
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryEvent?: DeliveryEventUncheckedUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type TransferUpsertWithWhereUniqueWithoutPaymentInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutPaymentInput, TransferUncheckedUpdateWithoutPaymentInput>
    create: XOR<TransferCreateWithoutPaymentInput, TransferUncheckedCreateWithoutPaymentInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutPaymentInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutPaymentInput, TransferUncheckedUpdateWithoutPaymentInput>
  }

  export type TransferUpdateManyWithWhereWithoutPaymentInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutPaymentInput>
  }

  export type RefundUpsertWithWhereUniqueWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    update: XOR<RefundUpdateWithoutPaymentInput, RefundUncheckedUpdateWithoutPaymentInput>
    create: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput>
  }

  export type RefundUpdateWithWhereUniqueWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    data: XOR<RefundUpdateWithoutPaymentInput, RefundUncheckedUpdateWithoutPaymentInput>
  }

  export type RefundUpdateManyWithWhereWithoutPaymentInput = {
    where: RefundScalarWhereInput
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyWithoutPaymentInput>
  }

  export type RefundScalarWhereInput = {
    AND?: RefundScalarWhereInput | RefundScalarWhereInput[]
    OR?: RefundScalarWhereInput[]
    NOT?: RefundScalarWhereInput | RefundScalarWhereInput[]
    id?: StringFilter<"Refund"> | string
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    updatedAt?: DateTimeFilter<"Refund"> | Date | string
    refundId?: StringNullableFilter<"Refund"> | string | null
    amount?: IntFilter<"Refund"> | number
    description?: StringNullableFilter<"Refund"> | string | null
    reason?: EnumEnumRefundReasonNullableFilter<"Refund"> | $Enums.EnumRefundReason | null
    status?: EnumEnumRefundStatusNullableFilter<"Refund"> | $Enums.EnumRefundStatus | null
    paymentId?: StringFilter<"Refund"> | string
  }

  export type PayoutUpsertWithWhereUniqueWithoutPaymentInput = {
    where: PayoutWhereUniqueInput
    update: XOR<PayoutUpdateWithoutPaymentInput, PayoutUncheckedUpdateWithoutPaymentInput>
    create: XOR<PayoutCreateWithoutPaymentInput, PayoutUncheckedCreateWithoutPaymentInput>
  }

  export type PayoutUpdateWithWhereUniqueWithoutPaymentInput = {
    where: PayoutWhereUniqueInput
    data: XOR<PayoutUpdateWithoutPaymentInput, PayoutUncheckedUpdateWithoutPaymentInput>
  }

  export type PayoutUpdateManyWithWhereWithoutPaymentInput = {
    where: PayoutScalarWhereInput
    data: XOR<PayoutUpdateManyMutationInput, PayoutUncheckedUpdateManyWithoutPaymentInput>
  }

  export type StripePaymentDataUpsertWithoutPaymentInput = {
    update: XOR<StripePaymentDataUpdateWithoutPaymentInput, StripePaymentDataUncheckedUpdateWithoutPaymentInput>
    create: XOR<StripePaymentDataCreateWithoutPaymentInput, StripePaymentDataUncheckedCreateWithoutPaymentInput>
    where?: StripePaymentDataWhereInput
  }

  export type StripePaymentDataUpdateToOneWithWhereWithoutPaymentInput = {
    where?: StripePaymentDataWhereInput
    data: XOR<StripePaymentDataUpdateWithoutPaymentInput, StripePaymentDataUncheckedUpdateWithoutPaymentInput>
  }

  export type StripePaymentDataUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    latestChargeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StripePaymentDataUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    latestChargeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateWithoutStripeDataInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capturedAt?: Date | string | null
    canceledAt?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.EnumPaymentStatus
    provider?: $Enums.EnumPaymentProvider
    delivery: DeliveryCreateNestedOneWithoutPaymentInput
    transfers?: TransferCreateNestedManyWithoutPaymentInput
    refunds?: RefundCreateNestedManyWithoutPaymentInput
    payouts?: PayoutCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutStripeDataInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capturedAt?: Date | string | null
    canceledAt?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.EnumPaymentStatus
    deliveryId: string
    provider?: $Enums.EnumPaymentProvider
    transfers?: TransferUncheckedCreateNestedManyWithoutPaymentInput
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutStripeDataInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutStripeDataInput, PaymentUncheckedCreateWithoutStripeDataInput>
  }

  export type PaymentUpsertWithoutStripeDataInput = {
    update: XOR<PaymentUpdateWithoutStripeDataInput, PaymentUncheckedUpdateWithoutStripeDataInput>
    create: XOR<PaymentCreateWithoutStripeDataInput, PaymentUncheckedCreateWithoutStripeDataInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutStripeDataInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutStripeDataInput, PaymentUncheckedUpdateWithoutStripeDataInput>
  }

  export type PaymentUpdateWithoutStripeDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
    delivery?: DeliveryUpdateOneRequiredWithoutPaymentNestedInput
    transfers?: TransferUpdateManyWithoutPaymentNestedInput
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
    payouts?: PayoutUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutStripeDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    deliveryId?: StringFieldUpdateOperationsInput | string
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
    transfers?: TransferUncheckedUpdateManyWithoutPaymentNestedInput
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateWithoutTransfersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capturedAt?: Date | string | null
    canceledAt?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.EnumPaymentStatus
    provider?: $Enums.EnumPaymentProvider
    delivery: DeliveryCreateNestedOneWithoutPaymentInput
    refunds?: RefundCreateNestedManyWithoutPaymentInput
    payouts?: PayoutCreateNestedManyWithoutPaymentInput
    stripeData?: StripePaymentDataCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutTransfersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capturedAt?: Date | string | null
    canceledAt?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.EnumPaymentStatus
    deliveryId: string
    provider?: $Enums.EnumPaymentProvider
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutPaymentInput
    stripeData?: StripePaymentDataUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutTransfersInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTransfersInput, PaymentUncheckedCreateWithoutTransfersInput>
  }

  export type CourierCreateWithoutTransferInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    user: UserCreateNestedOneWithoutCourierInput
    comments?: CommentCreateNestedManyWithoutCouriersInput
    earnings?: EarningCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryCreateNestedManyWithoutCourierInput
    settings?: CourierSettingCreateNestedOneWithoutCouriersInput
    Payout?: PayoutCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionCreateNestedManyWithoutCouriersInput
  }

  export type CourierUncheckedCreateWithoutTransferInput = {
    id?: string
    node_uri?: string | null
    firstName: string
    lastName: string
    phoneNumber?: string | null
    status?: $Enums.EnumCourierStatus
    deliverySetting?: $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierCreaterejectedOffersInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    stripeAccountId?: string | null
    stripeAccountStatus?: $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedCreateNestedManyWithoutCouriersInput
    earnings?: EarningUncheckedCreateNestedManyWithoutCouriersInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutCourierInput
    settings?: CourierSettingUncheckedCreateNestedOneWithoutCouriersInput
    Payout?: PayoutUncheckedCreateNestedManyWithoutCourierInput
    locationNotes?: LocationNoteUncheckedCreateNestedManyWithoutCouriersInput
    locationNoteReactions?: LocationNoteReactionUncheckedCreateNestedManyWithoutCouriersInput
  }

  export type CourierCreateOrConnectWithoutTransferInput = {
    where: CourierWhereUniqueInput
    create: XOR<CourierCreateWithoutTransferInput, CourierUncheckedCreateWithoutTransferInput>
  }

  export type PaymentUpsertWithoutTransfersInput = {
    update: XOR<PaymentUpdateWithoutTransfersInput, PaymentUncheckedUpdateWithoutTransfersInput>
    create: XOR<PaymentCreateWithoutTransfersInput, PaymentUncheckedCreateWithoutTransfersInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutTransfersInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutTransfersInput, PaymentUncheckedUpdateWithoutTransfersInput>
  }

  export type PaymentUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
    delivery?: DeliveryUpdateOneRequiredWithoutPaymentNestedInput
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
    payouts?: PayoutUpdateManyWithoutPaymentNestedInput
    stripeData?: StripePaymentDataUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    deliveryId?: StringFieldUpdateOperationsInput | string
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutPaymentNestedInput
    stripeData?: StripePaymentDataUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type CourierUpsertWithoutTransferInput = {
    update: XOR<CourierUpdateWithoutTransferInput, CourierUncheckedUpdateWithoutTransferInput>
    create: XOR<CourierCreateWithoutTransferInput, CourierUncheckedCreateWithoutTransferInput>
    where?: CourierWhereInput
  }

  export type CourierUpdateToOneWithWhereWithoutTransferInput = {
    where?: CourierWhereInput
    data: XOR<CourierUpdateWithoutTransferInput, CourierUncheckedUpdateWithoutTransferInput>
  }

  export type CourierUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    user?: UserUpdateOneRequiredWithoutCourierNestedInput
    comments?: CommentUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUpdateManyWithoutCouriersNestedInput
  }

  export type CourierUncheckedUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    node_uri?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumCourierStatusFieldUpdateOperationsInput | $Enums.EnumCourierStatus
    deliverySetting?: EnumEnumCourierDeliverySettingFieldUpdateOperationsInput | $Enums.EnumCourierDeliverySetting
    rejectedOffers?: CourierUpdaterejectedOffersInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: EnumEnumStripeAccountStatusFieldUpdateOperationsInput | $Enums.EnumStripeAccountStatus
    comments?: CommentUncheckedUpdateManyWithoutCouriersNestedInput
    earnings?: EarningUncheckedUpdateManyWithoutCouriersNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutCourierNestedInput
    settings?: CourierSettingUncheckedUpdateOneWithoutCouriersNestedInput
    Payout?: PayoutUncheckedUpdateManyWithoutCourierNestedInput
    locationNotes?: LocationNoteUncheckedUpdateManyWithoutCouriersNestedInput
    locationNoteReactions?: LocationNoteReactionUncheckedUpdateManyWithoutCouriersNestedInput
  }

  export type PaymentCreateWithoutRefundsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capturedAt?: Date | string | null
    canceledAt?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.EnumPaymentStatus
    provider?: $Enums.EnumPaymentProvider
    delivery: DeliveryCreateNestedOneWithoutPaymentInput
    transfers?: TransferCreateNestedManyWithoutPaymentInput
    payouts?: PayoutCreateNestedManyWithoutPaymentInput
    stripeData?: StripePaymentDataCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutRefundsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capturedAt?: Date | string | null
    canceledAt?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.EnumPaymentStatus
    deliveryId: string
    provider?: $Enums.EnumPaymentProvider
    transfers?: TransferUncheckedCreateNestedManyWithoutPaymentInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutPaymentInput
    stripeData?: StripePaymentDataUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutRefundsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
  }

  export type PaymentUpsertWithoutRefundsInput = {
    update: XOR<PaymentUpdateWithoutRefundsInput, PaymentUncheckedUpdateWithoutRefundsInput>
    create: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutRefundsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutRefundsInput, PaymentUncheckedUpdateWithoutRefundsInput>
  }

  export type PaymentUpdateWithoutRefundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
    delivery?: DeliveryUpdateOneRequiredWithoutPaymentNestedInput
    transfers?: TransferUpdateManyWithoutPaymentNestedInput
    payouts?: PayoutUpdateManyWithoutPaymentNestedInput
    stripeData?: StripePaymentDataUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutRefundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    deliveryId?: StringFieldUpdateOperationsInput | string
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
    transfers?: TransferUncheckedUpdateManyWithoutPaymentNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutPaymentNestedInput
    stripeData?: StripePaymentDataUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type CommentCreateManyCouriersInput = {
    id?: string
    text?: string | null
    likes?: number | null
    likers?: CommentCreatelikersInput | string[]
    commentableId: string
    commentableType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EarningCreateManyCouriersInput = {
    id?: string
    total: number
    pending: number
    received: number
    payoutMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryCreateManyCourierInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId: string
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    dropoffLocationId: string
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    partnerId?: string | null
    deliveryQuoteId: string
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayoutCreateManyCourierInput = {
    id?: string
    amount: number
    arrivalDate: Date | string
    description?: string | null
    statementDescriptor?: string | null
    status: $Enums.EnumPayoutStatus
    paymentId: string
  }

  export type TransferCreateManyCourierInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transferId: string
    amount: number
    amountReversed: number
    destination: string
    destinationPayment?: string | null
    reversed?: boolean
    paymentId?: string | null
  }

  export type LocationNoteCreateManyCouriersInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor: $Enums.EnumLocationNoteActor
    locationId?: string | null
    deliveryId?: string | null
  }

  export type LocationNoteReactionCreateManyCouriersInput = {
    id?: string
    reaction: $Enums.EnumLocationNoteReactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    locationNoteId: string
  }

  export type CommentUpdateWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    likers?: CommentUpdatelikersInput | string[]
    commentableId?: StringFieldUpdateOperationsInput | string
    commentableType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    likers?: CommentUpdatelikersInput | string[]
    commentableId?: StringFieldUpdateOperationsInput | string
    commentableType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: NullableIntFieldUpdateOperationsInput | number | null
    likers?: CommentUpdatelikersInput | string[]
    commentableId?: StringFieldUpdateOperationsInput | string
    commentableType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EarningUpdateWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    received?: IntFieldUpdateOperationsInput | number
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EarningUncheckedUpdateWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    received?: IntFieldUpdateOperationsInput | number
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EarningUncheckedUpdateManyWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    pending?: IntFieldUpdateOperationsInput | number
    received?: IntFieldUpdateOperationsInput | number
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocation?: LocationUpdateOneWithoutPickupDeliveryNestedInput
    dropoffLocation?: LocationUpdateOneWithoutDropoffDeliveryNestedInput
    partner?: PartnerUpdateOneWithoutDeliveriesNestedInput
    delivery?: DeliveryQuoteUpdateOneRequiredWithoutDeliveryNestedInput
    payment?: PaymentUpdateManyWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQuoteId?: StringFieldUpdateOperationsInput | string
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateManyWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUncheckedUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateManyWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQuoteId?: StringFieldUpdateOperationsInput | string
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statementDescriptor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumPayoutStatusFieldUpdateOperationsInput | $Enums.EnumPayoutStatus
    payment?: PaymentUpdateOneRequiredWithoutPayoutsNestedInput
  }

  export type PayoutUncheckedUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statementDescriptor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumPayoutStatusFieldUpdateOperationsInput | $Enums.EnumPayoutStatus
    paymentId?: StringFieldUpdateOperationsInput | string
  }

  export type PayoutUncheckedUpdateManyWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statementDescriptor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumPayoutStatusFieldUpdateOperationsInput | $Enums.EnumPayoutStatus
    paymentId?: StringFieldUpdateOperationsInput | string
  }

  export type TransferUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    amountReversed?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    destinationPayment?: NullableStringFieldUpdateOperationsInput | string | null
    reversed?: BoolFieldUpdateOperationsInput | boolean
    payment?: PaymentUpdateOneWithoutTransfersNestedInput
  }

  export type TransferUncheckedUpdateWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    amountReversed?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    destinationPayment?: NullableStringFieldUpdateOperationsInput | string | null
    reversed?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransferUncheckedUpdateManyWithoutCourierInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    amountReversed?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    destinationPayment?: NullableStringFieldUpdateOperationsInput | string | null
    reversed?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationNoteUpdateWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
    locations?: LocationUpdateOneWithoutLocationNotesNestedInput
    delivery?: DeliveryUpdateOneWithoutLocationNoteNestedInput
    noteReactions?: LocationNoteReactionUpdateManyWithoutLocationNoteNestedInput
  }

  export type LocationNoteUncheckedUpdateWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    noteReactions?: LocationNoteReactionUncheckedUpdateManyWithoutLocationNoteNestedInput
  }

  export type LocationNoteUncheckedUpdateManyWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationNoteReactionUpdateWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    reaction?: EnumEnumLocationNoteReactionTypeFieldUpdateOperationsInput | $Enums.EnumLocationNoteReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNote?: LocationNoteUpdateOneRequiredWithoutNoteReactionsNestedInput
  }

  export type LocationNoteReactionUncheckedUpdateWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    reaction?: EnumEnumLocationNoteReactionTypeFieldUpdateOperationsInput | $Enums.EnumLocationNoteReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNoteId?: StringFieldUpdateOperationsInput | string
  }

  export type LocationNoteReactionUncheckedUpdateManyWithoutCouriersInput = {
    id?: StringFieldUpdateOperationsInput | string
    reaction?: EnumEnumLocationNoteReactionTypeFieldUpdateOperationsInput | $Enums.EnumLocationNoteReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationNoteId?: StringFieldUpdateOperationsInput | string
  }

  export type LocationNoteCreateManyLocationsInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor: $Enums.EnumLocationNoteActor
    deliveryId?: string | null
    courierId?: string | null
  }

  export type DeliveryCreateManyPickupLocationInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    dropoffLocationId: string
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    courierId?: string | null
    partnerId?: string | null
    deliveryQuoteId: string
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryCreateManyDropoffLocationInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId: string
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    courierId?: string | null
    partnerId?: string | null
    deliveryQuoteId: string
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryQuoteCreateManyPickupLocationInput = {
    id?: string
    quote?: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage?: number
    currency: string
    duration: number
    distance: number
    distanceUnit?: $Enums.EnumDistanceUnit
    pickupPhoneNumber?: string | null
    pickupName?: string | null
    dropoffPhoneNumber?: string | null
    dropoffName?: string | null
    expiresAt?: Date | string | null
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    orderTotalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dropoffLocationId: string
    partnerId?: string | null
    deliveryId?: string | null
  }

  export type DeliveryQuoteCreateManyDropoffLocationInput = {
    id?: string
    quote?: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage?: number
    currency: string
    duration: number
    distance: number
    distanceUnit?: $Enums.EnumDistanceUnit
    pickupPhoneNumber?: string | null
    pickupName?: string | null
    dropoffPhoneNumber?: string | null
    dropoffName?: string | null
    expiresAt?: Date | string | null
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    orderTotalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocationId: string
    partnerId?: string | null
    deliveryId?: string | null
  }

  export type LocationNoteUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
    delivery?: DeliveryUpdateOneWithoutLocationNoteNestedInput
    couriers?: CourierUpdateOneWithoutLocationNotesNestedInput
    noteReactions?: LocationNoteReactionUpdateManyWithoutLocationNoteNestedInput
  }

  export type LocationNoteUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    noteReactions?: LocationNoteReactionUncheckedUpdateManyWithoutLocationNoteNestedInput
  }

  export type LocationNoteUncheckedUpdateManyWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryUpdateWithoutPickupLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropoffLocation?: LocationUpdateOneWithoutDropoffDeliveryNestedInput
    courier?: CourierUpdateOneWithoutDeliveriesNestedInput
    partner?: PartnerUpdateOneWithoutDeliveriesNestedInput
    delivery?: DeliveryQuoteUpdateOneRequiredWithoutDeliveryNestedInput
    payment?: PaymentUpdateManyWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutPickupLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQuoteId?: StringFieldUpdateOperationsInput | string
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateManyWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUncheckedUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateManyWithoutPickupLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQuoteId?: StringFieldUpdateOperationsInput | string
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUpdateWithoutDropoffLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocation?: LocationUpdateOneWithoutPickupDeliveryNestedInput
    courier?: CourierUpdateOneWithoutDeliveriesNestedInput
    partner?: PartnerUpdateOneWithoutDeliveriesNestedInput
    delivery?: DeliveryQuoteUpdateOneRequiredWithoutDeliveryNestedInput
    payment?: PaymentUpdateManyWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutDropoffLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQuoteId?: StringFieldUpdateOperationsInput | string
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateManyWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUncheckedUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateManyWithoutDropoffLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQuoteId?: StringFieldUpdateOperationsInput | string
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryQuoteUpdateWithoutPickupLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffLocation?: LocationUpdateOneRequiredWithoutDropoffDeliveryQuotesNestedInput
    partners?: PartnerUpdateOneWithoutDeliveryQuotesNestedInput
    Delivery?: DeliveryUpdateOneWithoutDeliveryNestedInput
  }

  export type DeliveryQuoteUncheckedUpdateWithoutPickupLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    Delivery?: DeliveryUncheckedUpdateOneWithoutDeliveryNestedInput
  }

  export type DeliveryQuoteUncheckedUpdateManyWithoutPickupLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryQuoteUpdateWithoutDropoffLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLocation?: LocationUpdateOneRequiredWithoutPickupDeliveryQuotesNestedInput
    partners?: PartnerUpdateOneWithoutDeliveryQuotesNestedInput
    Delivery?: DeliveryUpdateOneWithoutDeliveryNestedInput
  }

  export type DeliveryQuoteUncheckedUpdateWithoutDropoffLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    Delivery?: DeliveryUncheckedUpdateOneWithoutDeliveryNestedInput
  }

  export type DeliveryQuoteUncheckedUpdateManyWithoutDropoffLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryCreateManyPartnerInput = {
    id?: string
    pickupName: string
    pickupPhoneNumber: string
    pickupBusinessName: string
    pickupNotes?: string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId: string
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffName: string
    dropoffPhoneNumber: string
    dropoffBusinessName?: string | null
    dropoffNotes?: string | null
    dropoffSellerNotes?: string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    deliverableAction?: $Enums.EnumDeliverableAction
    undeliverableAction?: $Enums.EnumUndeliverableAction | null
    undeliverableReason?: string | null
    dropoffLocationId: string
    deliveryTypes?: DeliveryCreatedeliveryTypesInput | string[]
    requiresDropoffSignature?: boolean
    requiresId?: boolean
    orderReference?: string | null
    orderTotalValue?: number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryCreatecustomerNotesInput | string[]
    currencyCode: string
    pickupTypes?: DeliveryCreatepickupTypesInput | string[]
    imageType?: string | null
    imageName?: string | null
    imageData?: Buffer | null
    idempotencyKey?: string | null
    externalStoreId?: string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    courierId?: string | null
    deliveryQuoteId: string
    totalCost?: number | null
    fee?: number | null
    feePercentage?: number | null
    pay?: number | null
    tips?: number
    totalCompensation?: number | null
    rejectedByCouriers?: DeliveryCreaterejectedByCouriersInput | string[]
    matchedCourierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryQuoteCreateManyPartnersInput = {
    id?: string
    quote?: number | null
    quoteRangeFrom: number
    quoteRangeTo: number
    feePercentage?: number
    currency: string
    duration: number
    distance: number
    distanceUnit?: $Enums.EnumDistanceUnit
    pickupPhoneNumber?: string | null
    pickupName?: string | null
    dropoffPhoneNumber?: string | null
    dropoffName?: string | null
    expiresAt?: Date | string | null
    pickupReadyAt?: Date | string | null
    pickupDeadlineAt?: Date | string | null
    dropoffReadyAt?: Date | string | null
    dropoffEta?: Date | string | null
    dropoffDeadlineAt?: Date | string | null
    orderTotalValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupLocationId: string
    dropoffLocationId: string
    deliveryId?: string | null
  }

  export type DeliveryUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocation?: LocationUpdateOneWithoutPickupDeliveryNestedInput
    dropoffLocation?: LocationUpdateOneWithoutDropoffDeliveryNestedInput
    courier?: CourierUpdateOneWithoutDeliveriesNestedInput
    delivery?: DeliveryQuoteUpdateOneRequiredWithoutDeliveryNestedInput
    payment?: PaymentUpdateManyWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQuoteId?: StringFieldUpdateOperationsInput | string
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateManyWithoutDeliveryNestedInput
    deliveryEvent?: DeliveryEventUncheckedUpdateManyWithoutDeliveryNestedInput
    locationNote?: LocationNoteUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupName?: StringFieldUpdateOperationsInput | string
    pickupPhoneNumber?: StringFieldUpdateOperationsInput | string
    pickupBusinessName?: StringFieldUpdateOperationsInput | string
    pickupNotes?: NullableStringFieldUpdateOperationsInput | string | null
    pickupVerification?: NullableJsonNullValueInput | InputJsonValue
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffName?: StringFieldUpdateOperationsInput | string
    dropoffPhoneNumber?: StringFieldUpdateOperationsInput | string
    dropoffBusinessName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffSellerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffVerification?: NullableJsonNullValueInput | InputJsonValue
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliverableAction?: EnumEnumDeliverableActionFieldUpdateOperationsInput | $Enums.EnumDeliverableAction
    undeliverableAction?: NullableEnumEnumUndeliverableActionFieldUpdateOperationsInput | $Enums.EnumUndeliverableAction | null
    undeliverableReason?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    deliveryTypes?: DeliveryUpdatedeliveryTypesInput | string[]
    requiresDropoffSignature?: BoolFieldUpdateOperationsInput | boolean
    requiresId?: BoolFieldUpdateOperationsInput | boolean
    orderReference?: NullableStringFieldUpdateOperationsInput | string | null
    orderTotalValue?: NullableIntFieldUpdateOperationsInput | number | null
    orderItems?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus
    customerNotes?: DeliveryUpdatecustomerNotesInput | string[]
    currencyCode?: StringFieldUpdateOperationsInput | string
    pickupTypes?: DeliveryUpdatepickupTypesInput | string[]
    imageType?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    externalStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    returnVerification?: NullableJsonNullValueInput | InputJsonValue
    externalUserInfo?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQuoteId?: StringFieldUpdateOperationsInput | string
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    feePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    pay?: NullableFloatFieldUpdateOperationsInput | number | null
    tips?: FloatFieldUpdateOperationsInput | number
    totalCompensation?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedByCouriers?: DeliveryUpdaterejectedByCouriersInput | string[]
    matchedCourierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryQuoteUpdateWithoutPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLocation?: LocationUpdateOneRequiredWithoutPickupDeliveryQuotesNestedInput
    dropoffLocation?: LocationUpdateOneRequiredWithoutDropoffDeliveryQuotesNestedInput
    Delivery?: DeliveryUpdateOneWithoutDeliveryNestedInput
  }

  export type DeliveryQuoteUncheckedUpdateWithoutPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    Delivery?: DeliveryUncheckedUpdateOneWithoutDeliveryNestedInput
  }

  export type DeliveryQuoteUncheckedUpdateManyWithoutPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: NullableFloatFieldUpdateOperationsInput | number | null
    quoteRangeFrom?: FloatFieldUpdateOperationsInput | number
    quoteRangeTo?: FloatFieldUpdateOperationsInput | number
    feePercentage?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    distanceUnit?: EnumEnumDistanceUnitFieldUpdateOperationsInput | $Enums.EnumDistanceUnit
    pickupPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    pickupName?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffPhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dropoffName?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dropoffDeadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotalValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupLocationId?: StringFieldUpdateOperationsInput | string
    dropoffLocationId?: StringFieldUpdateOperationsInput | string
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyDeliveryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capturedAt?: Date | string | null
    canceledAt?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.EnumPaymentStatus
    provider?: $Enums.EnumPaymentProvider
  }

  export type DeliveryEventCreateManyDeliveryInput = {
    id?: string
    transitionSuccessful: boolean
    type: $Enums.EnumDeliveryEventType
    actor: $Enums.EnumEventActor
    eventSource: $Enums.EnumDeliveryEventSource
    oldStatus?: $Enums.EnumDeliveryStatus | null
    newStatus?: $Enums.EnumDeliveryStatus | null
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationNoteCreateManyDeliveryInput = {
    id?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actor: $Enums.EnumLocationNoteActor
    locationId?: string | null
    courierId?: string | null
  }

  export type PaymentUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
    transfers?: TransferUpdateManyWithoutPaymentNestedInput
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
    payouts?: PayoutUpdateManyWithoutPaymentNestedInput
    stripeData?: StripePaymentDataUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
    transfers?: TransferUncheckedUpdateManyWithoutPaymentNestedInput
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutPaymentNestedInput
    stripeData?: StripePaymentDataUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumEnumPaymentStatusFieldUpdateOperationsInput | $Enums.EnumPaymentStatus
    provider?: EnumEnumPaymentProviderFieldUpdateOperationsInput | $Enums.EnumPaymentProvider
  }

  export type DeliveryEventUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    transitionSuccessful?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumEnumDeliveryEventTypeFieldUpdateOperationsInput | $Enums.EnumDeliveryEventType
    actor?: EnumEnumEventActorFieldUpdateOperationsInput | $Enums.EnumEventActor
    eventSource?: EnumEnumDeliveryEventSourceFieldUpdateOperationsInput | $Enums.EnumDeliveryEventSource
    oldStatus?: NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus | null
    newStatus?: NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEventUncheckedUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    transitionSuccessful?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumEnumDeliveryEventTypeFieldUpdateOperationsInput | $Enums.EnumDeliveryEventType
    actor?: EnumEnumEventActorFieldUpdateOperationsInput | $Enums.EnumEventActor
    eventSource?: EnumEnumDeliveryEventSourceFieldUpdateOperationsInput | $Enums.EnumDeliveryEventSource
    oldStatus?: NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus | null
    newStatus?: NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEventUncheckedUpdateManyWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    transitionSuccessful?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumEnumDeliveryEventTypeFieldUpdateOperationsInput | $Enums.EnumDeliveryEventType
    actor?: EnumEnumEventActorFieldUpdateOperationsInput | $Enums.EnumEventActor
    eventSource?: EnumEnumDeliveryEventSourceFieldUpdateOperationsInput | $Enums.EnumDeliveryEventSource
    oldStatus?: NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus | null
    newStatus?: NullableEnumEnumDeliveryStatusFieldUpdateOperationsInput | $Enums.EnumDeliveryStatus | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationNoteUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
    locations?: LocationUpdateOneWithoutLocationNotesNestedInput
    couriers?: CourierUpdateOneWithoutLocationNotesNestedInput
    noteReactions?: LocationNoteReactionUpdateManyWithoutLocationNoteNestedInput
  }

  export type LocationNoteUncheckedUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
    noteReactions?: LocationNoteReactionUncheckedUpdateManyWithoutLocationNoteNestedInput
  }

  export type LocationNoteUncheckedUpdateManyWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: EnumEnumLocationNoteActorFieldUpdateOperationsInput | $Enums.EnumLocationNoteActor
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationNoteReactionCreateManyLocationNoteInput = {
    id?: string
    reaction: $Enums.EnumLocationNoteReactionType
    createdAt?: Date | string
    updatedAt?: Date | string
    courierId: string
  }

  export type LocationNoteReactionUpdateWithoutLocationNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    reaction?: EnumEnumLocationNoteReactionTypeFieldUpdateOperationsInput | $Enums.EnumLocationNoteReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couriers?: CourierUpdateOneRequiredWithoutLocationNoteReactionsNestedInput
  }

  export type LocationNoteReactionUncheckedUpdateWithoutLocationNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    reaction?: EnumEnumLocationNoteReactionTypeFieldUpdateOperationsInput | $Enums.EnumLocationNoteReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courierId?: StringFieldUpdateOperationsInput | string
  }

  export type LocationNoteReactionUncheckedUpdateManyWithoutLocationNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    reaction?: EnumEnumLocationNoteReactionTypeFieldUpdateOperationsInput | $Enums.EnumLocationNoteReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courierId?: StringFieldUpdateOperationsInput | string
  }

  export type TransferCreateManyPaymentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transferId: string
    amount: number
    amountReversed: number
    destination: string
    destinationPayment?: string | null
    reversed?: boolean
    courierId?: string | null
  }

  export type RefundCreateManyPaymentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refundId?: string | null
    amount: number
    description?: string | null
    reason?: $Enums.EnumRefundReason | null
    status?: $Enums.EnumRefundStatus | null
  }

  export type PayoutCreateManyPaymentInput = {
    id?: string
    amount: number
    arrivalDate: Date | string
    description?: string | null
    statementDescriptor?: string | null
    status: $Enums.EnumPayoutStatus
    courierId?: string | null
  }

  export type TransferUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    amountReversed?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    destinationPayment?: NullableStringFieldUpdateOperationsInput | string | null
    reversed?: BoolFieldUpdateOperationsInput | boolean
    courier?: CourierUpdateOneWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    amountReversed?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    destinationPayment?: NullableStringFieldUpdateOperationsInput | string | null
    reversed?: BoolFieldUpdateOperationsInput | boolean
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransferUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transferId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    amountReversed?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    destinationPayment?: NullableStringFieldUpdateOperationsInput | string | null
    reversed?: BoolFieldUpdateOperationsInput | boolean
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefundUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableEnumEnumRefundReasonFieldUpdateOperationsInput | $Enums.EnumRefundReason | null
    status?: NullableEnumEnumRefundStatusFieldUpdateOperationsInput | $Enums.EnumRefundStatus | null
  }

  export type RefundUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableEnumEnumRefundReasonFieldUpdateOperationsInput | $Enums.EnumRefundReason | null
    status?: NullableEnumEnumRefundStatusFieldUpdateOperationsInput | $Enums.EnumRefundStatus | null
  }

  export type RefundUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableEnumEnumRefundReasonFieldUpdateOperationsInput | $Enums.EnumRefundReason | null
    status?: NullableEnumEnumRefundStatusFieldUpdateOperationsInput | $Enums.EnumRefundStatus | null
  }

  export type PayoutUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statementDescriptor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumPayoutStatusFieldUpdateOperationsInput | $Enums.EnumPayoutStatus
    courier?: CourierUpdateOneWithoutPayoutNestedInput
  }

  export type PayoutUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statementDescriptor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumPayoutStatusFieldUpdateOperationsInput | $Enums.EnumPayoutStatus
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PayoutUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statementDescriptor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEnumPayoutStatusFieldUpdateOperationsInput | $Enums.EnumPayoutStatus
    courierId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CourierCountOutputTypeDefaultArgs instead
     */
    export type CourierCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CourierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationCountOutputTypeDefaultArgs instead
     */
    export type LocationCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = LocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartnerCountOutputTypeDefaultArgs instead
     */
    export type PartnerCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PartnerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeliveryCountOutputTypeDefaultArgs instead
     */
    export type DeliveryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DeliveryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationNoteCountOutputTypeDefaultArgs instead
     */
    export type LocationNoteCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = LocationNoteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentCountOutputTypeDefaultArgs instead
     */
    export type PaymentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PaymentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourierDefaultArgs instead
     */
    export type CourierArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CourierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EarningDefaultArgs instead
     */
    export type EarningArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = EarningDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationDefaultArgs instead
     */
    export type LocationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = LocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartnerDefaultArgs instead
     */
    export type PartnerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PartnerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeliveryQuoteDefaultArgs instead
     */
    export type DeliveryQuoteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DeliveryQuoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeliveryDefaultArgs instead
     */
    export type DeliveryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DeliveryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeliveryEventDefaultArgs instead
     */
    export type DeliveryEventArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DeliveryEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationNoteDefaultArgs instead
     */
    export type LocationNoteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = LocationNoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationNoteReactionDefaultArgs instead
     */
    export type LocationNoteReactionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = LocationNoteReactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourierSettingDefaultArgs instead
     */
    export type CourierSettingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CourierSettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PayoutDefaultArgs instead
     */
    export type PayoutArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PayoutDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StripePaymentDataDefaultArgs instead
     */
    export type StripePaymentDataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = StripePaymentDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransferDefaultArgs instead
     */
    export type TransferArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TransferDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefundDefaultArgs instead
     */
    export type RefundArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = RefundDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfigDefaultArgs instead
     */
    export type ConfigArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use spatial_ref_sysDefaultArgs instead
     */
    export type spatial_ref_sysArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = spatial_ref_sysDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}